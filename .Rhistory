data$counts = data$counts[-bad_cells,]
dim(data$counts)
y = data$counts[,1]
X = data$niche
lambda = data$deconv
family = "spot poisson"
initialization = "full"
beta_0 = NULL
fix_coef = NULL
offset = log(Matrix::rowSums(data$counts))
min_deconv = 0.1
min_freq = 50
CT = NULL
weights = NULL
ct_cov_weights = NULL
max_gd_steps = 5000
learning_rate = 1
max_diff = 1-1e-6
intercept_col = NULL
t1 = Sys.time()
test = run_model(y = y,X = X,lambda = lambda,family = family,beta_0 =beta_0,fix_coef = fix_coef,
offset = offset,min_deconv =min_deconv,min_freq = min_freq,CT = CT, weights = weights,ct_cov_weights = ct_cov_weights,
max_gd_steps = max_gd_steps,learning_rate = learning_rate,max_diff = max_diff,intercept_col = intercept_col)
t1 = Sys.time()
test = spotglm:::run_model(y = y,X = X,lambda = lambda,family = family,beta_0 =beta_0,fix_coef = fix_coef,
offset = offset,min_deconv =min_deconv,min_freq = min_freq,CT = CT, weights = weights,ct_cov_weights = ct_cov_weights,
max_gd_steps = max_gd_steps,learning_rate = learning_rate,max_diff = max_diff,intercept_col = intercept_col)
print(Sys.time() - t1)
#Step 0: Pre-processing
if(is.null(weights)){
weights = rep(1,length(y))
}else if(length(weights)!= length(y)){
stop("Weights must be same length as observations")
}
if(is.null(ct_cov_weights)){
ct_cov_weights = rep(1,ncol(lambda))
}else if(length(ct_cov_weights)!= ncol(lambda)){
stop("Weights must be same length as number of columns of lambda")
}
#weight lambda by cov weights and normalize
if(is.null(ct_cov_weights) == F){
if(length(ct_cov_weights) != ncol(lambda)){
stop("Cell type covariate weights must be the same length as #col lambda")
}
lambda = sweep(lambda,2,ct_cov_weights,"*")
lambda = sweep(lambda,1,rowSums(lambda),"/")
lambda[is.na(lambda)] = 1/ncol(lambda)
}
#get family
if(family == "spot gaussian"){
model_family = "spot_gaussian"
sc_family = "gaussian"
}else if(family == "spot poisson"){
model_family = "spot_poisson"
sc_family = "poisson"
}else if(family == "spot negative binomial"){
model_family = "spot_negative_binomial"
sc_family = "poisson"
}else if(family == "spot binomial"){
model_family = "spot_binomial"
sc_family = "binomial"
}else{
stop("Family must be one of spot gaussian, spot poisson, spot negative binomial, or spot binomial")
}
if(is.null(fix_coef)){
fix_coef = matrix(FALSE,ncol(X),ncol(lambda))
}else if( (nrow(fix_coef)!= ncol(X)) |(ncol(fix_coef)!= ncol(lambda))){
stop("Fixed coefficients matrix must be of dimension ncol(X) by ncol(lambda)")
}
#Step 1: get initial beta
if(is.null(beta_0)){
beta_0 = matrix(0,ncol(X),ncol(lambda))
}else if( (nrow(beta_0)!= ncol(X)) |(ncol(beta_0)!= ncol(lambda))){
stop("Initial beta matrix must be of dimension ncol(X) by ncol(lambda)")
}
if(initialization == "intercept"){
initial_run= spotglm:::initialize_beta_intercept(y = y, X = X, lambda = lambda,beta = beta_0,
family = sc_family,offset = offset,
weights = weights,fix_coef = fix_coef,CT = CT,min_freq = min_freq,intercept_ind = intercept_col)
beta_0 = initial_run$beta_0
fix_coef = initial_run$fix_coef
}else if(initialization == "full"){
initial_run = spotglm:::initialize_beta_full(y = y, X = X, lambda = lambda,beta = beta_0,
family = sc_family,offset = offset,
weights = weights,fix_coef = fix_coef,CT = CT,min_freq = min_freq,intercept_ind = intercept_col)
beta_0 = initial_run$beta_0
fix_coef = initial_run$fix_coef
}else{
print("No initialization chosen. Must be one of intercept or full.")
}
beta_0
table(apply(lambda,1,function(x){which.max(x)}))
data = sparrow::read_visiumHD()
bad_cells = which(Matrix::rowSums(data$counts) < 50)
data$coords = data$coords[-bad_cells,]
data$deconv = data$deconv[-bad_cells,]
data$niche = data$niche[-bad_cells,]
data$counts = data$counts[-bad_cells,]
library(spotglm)
j=1
t1 = Sys.time()
y = data$counts[,j]
X = data$niche
lambda = data$deconv
family = "spot poisson"
initialization = "full"
beta_0 = NULL
fix_coef = NULL
offset = log(Matrix::rowSums(data$counts))
min_deconv = 0.1
min_freq = 50
CT = NULL
weights = NULL
ct_cov_weights = NULL
max_gd_steps = 5000
learning_rate = 1
max_diff = 1-1e-6
intercept_col = NULL
test = spotglm:::run_model(y = y,X = X,lambda = lambda,family = family,beta_0 =beta_0,fix_coef = fix_coef,
offset = offset,min_deconv =min_deconv,min_freq = min_freq,CT = CT, weights = weights,ct_cov_weights = ct_cov_weights,
max_gd_steps = max_gd_steps,learning_rate = learning_rate,max_diff = max_diff,intercept_col = intercept_col)
print(Sys.time() - t1)
test$niter
test$time
test$beta_est
## Step 0: Loading Data and Pre-processing
data = sparrow::read_visiumHD()
data$deconv[data$deconv < 0.1] = 0
data$deconv = t(apply(data$deconv,1,function(x){x/sum(x)}))
data$niche[data$niche < 0.1] = 0
data$niche = t(apply(data$niche,1,function(x){x/sum(x)}))
#remove spots with too few UMIs
bad_spots = which(rowSums(data$counts) < 20)
data$coords = data$coords[-bad_spots,]
data$niche = data$niche[-bad_spots,]
data$deconv = data$deconv[-bad_spots,]
data$counts = data$counts[-bad_spots,]
#make niche matrix has reference column
data$niche = data$niche[,-9]
data$niche = cbind(1,data$niche)
colnames(data$niche)[1] = "intercept"
freq = apply(data$niche,2,function(x){sum(x)})
bad_niche = which(freq<500)
if(length(bad_niche)> 0){
data$niche = data$niche[,-bad_niche]
}
library(spotglm)
library(sparrow)
colSums(data$niche)
sim_data = sparrow::simulate_data(n = 100000, nct = 9,effect_scale = 1/4, intercept_scale = 4,library_size = 5000, spot_ct = 2, p = 5, num_null = 2, prob_ct = NULL)
family = "spot poisson"
initialization = "intercept"
beta_0 = NULL
fix_coef = NULL
offset = rep(log(5000),length(sim_data$y))
min_deconv = 0.1
min_freq = 50
CT = NULL
weights = NULL
ct_cov_weights = NULL
n_epochs = 100
batch_size = 500
learning_rate = 1
max_diff = 1-1e-6
intercept_col = 1
y = sim_data$y
X = sim_data$X
lambda = sim_data$lambda
t1 = Sys.time()
sim_test = run_model(y = sim_data$y,X = sim_data$X,lambda = sim_data$lambda,family = "spot poisson",beta_0 =beta_0,fix_coef = fix_coef,
offset = offset,min_deconv =min_deconv,min_freq = min_freq,CT = CT, weights = weights,ct_cov_weights = ct_cov_weights,
n_epochs = n_epochs,batch_size= batch_size,learning_rate = learning_rate,max_diff = max_diff,intercept_col = c(1),initialization = initialization)
print(Sys.time() - t1)
plot(sim_data$beta[-1,],sim_test$beta_est[-1,])
abline(a = 0, b = 1, col = "red")
rm(list = ls())
gc()
library(sparrow)
library(spotglm)
library(parallel)
library(doParallel)
setwd("/Users/kmason/Desktop/spotglm_benchmarks/visium_HD/deconvolution_output/analysis/materials")
analysis_skeleton = readRDS("analysis_skeleton.rds")
deconv_weighted = analysis_skeleton$deconv_weighted
counts = analysis_skeleton$counts
EN = analysis_skeleton$effective_niche
spot_size = analysis_skeleton$spot_size
best_genes = analysis_skeleton$best_genes
dim(counts)
library(spotglm)
library(ggplot2)
library(dplyr)
library(patchwork)
data = spotglm::read_spatial_long_read()
region = apply(data$regions,1,function(x){colnames(data$regions)[which(x == 1)]})
library(ggplot2)
df <- data.frame(
x = data$coords[, 1],
y = data$coords[, 2],
region = region
)
ggplot(df, aes(x = x, y = y, color = region)) +
geom_point(size = 2) +
coord_fixed() +
theme_minimal() +
labs(title = "Spots by Region", color = "Region")
#Step 1: Intercept Model
#get number of genes
ngenes = ncol(data$total_gene_expression)
#initialize intercept estimates
intercept_estimate = vector("list",ngenes)
names(intercept_estimate) = colnames(data$total_gene_expression)
#initialize list of important cell types for this gene
good_cell_type_list = vector("list",ngenes)
names(good_cell_type_list) = colnames(data$total_gene_expression)
#iterate over each gene
for(j in c(1:ngenes)){
intercept_estimate[[j]]=spotglm::run_model(y = data$total_gene_expression[,j],
X = matrix(1,nrow(data$total_gene_expression),1),
lambda = data$deconv,
offset = log(data$library_size),
initialization = T,
family = "spot poisson")
#get T statistics for intercepts
T_statistics = intercept_estimate[[j]]$beta_est
T_statistics = T_statistics/intercept_estimate[[j]]$stand_err_mat
#get "good" cell types: Those that have sufficient expression of the gene
good_ct = which(T_statistics < -1.96 & intercept_estimate[[j]]$beta_est > -11)
#reweight deconvolution vector to reflect difference in expression
deconv_weighted = 0*data$deconv
for(k in c(1:nrow(data$deconv))){
deconv_weighted[k,good_ct]=data$deconv[k,good_ct]*exp(intercept_estimate[[j]]$beta_est[,good_ct])
}
#normalize to sum to one
deconv_weighted = deconv_weighted/rowSums(deconv_weighted)
#remove those cells that have small weights
deconv_weighted[deconv_weighted < 0.2] = 0
#re-normalize
deconv_weighted = deconv_weighted/rowSums(deconv_weighted)
#get cell type frequencies
ct_freq = apply(deconv_weighted,2,function(x){sum(x > 0,na.rm = TRUE)})
#remove cell types that don't appear more than 50 times
important_ct = which(ct_freq > 50)
#get intersection,i.e cell types with sufficient expression and sample size
good_cell_type_list[[j]] = important_ct
}
### Step 2: SpotGLM to Perform Isoform Differential Expression (~1 minute)
#Step 2: Fit spot binomial model
isoform_DE = vector("list",ngenes)
names(isoform_DE) = colnames(data$total_gene_expression)
for(j in c(1:ngenes)){
#get gene name
gene = names(isoform_DE)[j]
#get weights
weights = data$total_gene_expression[,gene]
#get covariate weights
ct_covariate_weights  = exp(intercept_estimate[[gene]]$beta_est)
#get good cell types for this gene
good_cell_types = good_cell_type_list[[j]]
if(length(good_cell_types) == 0){
next
}
#run model
isoform_DE[[j]] = spotglm::run_model(y = data$isoform_expression[[gene]][[1]],
X = data$regions,
lambda = data$deconv[,good_cell_types,drop = F],
family = "spot binomial",
weights = weights,
ct_cov_weights = ct_covariate_weights[good_cell_types],
initialization = T)
}
### Step 3: Downstream Analysis: Contrast Test to Identify Isoform Switching Across Regions
#Store all contrast tests
all_contrast_tests = list()
cell_types = colnames(data$deconv)
regions = colnames(data$regions)
nregion = length(regions)
counter = 1
#test over all cell types and region pairs
for(ct in cell_types){
for(j in c(1:nregion)){
for(k in c(j:nregion)){
if(j==k){
next
}
region_A = regions[j]
region_B = regions[k]
#compute pvalues
pvals = suppressWarnings(spotglm::compute_contrast_significance(input_list = isoform_DE,
cell_type = ct,
effect_names = c(region_A,region_B),
beta_name = "beta_est",
covariance_name = "vcov",
sided = 2))
contrast_tests = data.frame(gene = pvals$name, cell_type = ct,
region_A = region_A, region_B = region_B,
pval = pvals$pval)
#add results to list
all_contrast_tests[[counter]] = contrast_tests
counter = counter + 1
}
}
}
combined_contrast_tests <- dplyr::bind_rows(all_contrast_tests)%>%
dplyr::filter(!is.na(pval))
#get significant switches
combined_contrast_tests$qval = p.adjust(combined_contrast_tests$pval,method = "BH")
significant_isoform_switches = combined_contrast_tests%>%filter(qval < 0.1)
### Results of Contrast Test as a Table
head(significant_isoform_switches,10)
### Example Gene: Ap3s1
gene <- "Ap3s1"
# Isoform ratio
isoform_vals <- data$isoform_expression[[gene]][[1]]
gene_total <- data$total_gene_expression[, gene]
ratio <- isoform_vals / gene_total
ratio[!is.finite(ratio)] <- NA
# Region labels
region <- apply(data$regions, 1, function(x) {
colnames(data$regions)[which(x == 1)]
})
# Binary group
region_group <- ifelse(region == "regionGranule Cell Layer (GCL+RMS)", "Granule Layer", "Other")
# Combined dataframe
df <- data.frame(
x = data$coords[,1],
y = data$coords[,2],
ratio = ratio,
region = region_group
) %>% filter(!is.na(ratio))
# === Plot 1: Violin + boxplot ===
p1 <- ggplot(df, aes(x = region, y = ratio, fill = region)) +
geom_violin(trim = FALSE, alpha = 0.6) +
geom_boxplot(width = 0.2, outlier.shape = NA) +
theme_minimal() +
labs(
title = paste(gene, "Isoform/Gene Ratio"),
x = "", y = "Ratio"
) +
scale_fill_manual(values = c("Granule Layer" = "tomato", "Other" = "skyblue")) +
theme(legend.position = "none")
# === Plot 2: Spatial plot - Granule Layer only ===
p2 <- df %>%
filter(region == "Granule Layer") %>%
ggplot(aes(x = x, y = y, color = ratio)) +
geom_point(size = 2) +
scale_color_viridis_c(na.value = "grey90") +
coord_fixed() +
theme_minimal() +
labs(title = "Granule Layer", x = NULL, y = NULL, color = "Ratio")
# === Plot 3: Spatial plot - Other regions ===
p3 <- df %>%
filter(region == "Other") %>%
ggplot(aes(x = x, y = y, color = ratio)) +
geom_point(size = 2) +
scale_color_viridis_c(na.value = "grey90") +
coord_fixed() +
theme_minimal() +
labs(title = "Other Regions", x = NULL, y = NULL, color = "Ratio")
p1
p2 + p3
View(significant_isoform_switches)
setwd("/Users/kmason/Desktop/Folders/research_projects/spatial/spotglm")
devtools::document()
#test over all cell types and region pairs
for(ct in cell_types){
for(j in c(1:nregion)){
for(k in c(j:nregion)){
if(j==k){
next
}
region_A = regions[j]
region_B = regions[k]
#compute pvalues
pvals = suppressWarnings(spotglm::compute_contrast_significance(input_list = isoform_DE,
cell_type = ct,
effect_names = c(region_A,region_B),
beta_name = "beta_est",
covariance_name = "vcov",
sided = 2))
contrast_tests = data.frame(gene = pvals$name, cell_type = ct,
region_A = region_A, region_B = region_B,test_statistic = pvals$test_statistic,
pval = pvals$pval)
#add results to list
all_contrast_tests[[counter]] = contrast_tests
counter = counter + 1
}
}
}
combined_contrast_tests <- dplyr::bind_rows(all_contrast_tests)%>%
dplyr::filter(!is.na(pval))
#get significant switches
combined_contrast_tests$qval = p.adjust(combined_contrast_tests$pval,method = "BH")
significant_isoform_switches = combined_contrast_tests%>%filter(qval < 0.1)
View(significant_isoform_switches)
View(pvals)
#compute pvalues
pvals = suppressWarnings(spotglm::compute_contrast_significance(input_list = isoform_DE,
cell_type = ct,
effect_names = c(region_A,region_B),
beta_name = "beta_est",
covariance_name = "vcov",
sided = 2))
View(pvals)
input_list = isoform_DE
cell_type = ct
effect_names = c(region_A,region_B)
beta_name = "beta_est"
covariance_name = "vcov"
sided = 2
if(is.null(names(input_list))){
names(input_list) = paste0("Test_",c(1:length(input_list)))
}
#Step 1: Compute pvalues
pvals = compute_contrast(input_list = input_list,cell_type = cell_type,effect_names = effect_names,beta_name = beta_name,
covariance_name = covariance_name,sided = sided,
direction = direction)
input_list = isoform_DE
cell_type = ct
effect_names = c(region_A,region_B)
beta_name = "beta_est"
covariance_name = "vcov"
sided = 2
direction = "pos"
if(is.null(names(input_list))){
names(input_list) = paste0("Test_",c(1:length(input_list)))
}
#Step 1: Compute pvalues
pvals = compute_contrast(input_list = input_list,cell_type = cell_type,effect_names = effect_names,beta_name = beta_name,
covariance_name = covariance_name,sided = sided,
direction = direction)
isoform_DE$Tex264$beta_est
ct
ct = "N"
if(is.null(names(input_list))){
names(input_list) = paste0("Test_",c(1:length(input_list)))
}
#Step 1: Compute pvalues
pvals = compute_contrast(input_list = input_list,cell_type = cell_type,effect_names = effect_names,beta_name = beta_name,
covariance_name = covariance_name,sided = sided,
direction = direction)
cell_type
cell_type = ct
if(is.null(names(input_list))){
names(input_list) = paste0("Test_",c(1:length(input_list)))
}
#Step 1: Compute pvalues
pvals = compute_contrast(input_list = input_list,cell_type = cell_type,effect_names = effect_names,beta_name = beta_name,
covariance_name = covariance_name,sided = sided,
direction = direction)
View(pvals)
#Step 2: Compute qvalues
qvals = compute_qvals(pval_list = pvals$pvals)
View(qvals)
#return matrix of results
result_mat <- do.call(rbind, lapply(seq_along(pvals$pvals), function(i) {
data.frame(
name = names(pvals$pvals)[i],
cell_type = cell_type,
effect_1 = effect_names[1],
effect_2 = effect_names[2],
sided = sided,
direction = direction,
test_statistic = pvals$test_statistics[[i]],
pval = pvals$pvals[[i]],
qval = qvals[[i]],
stringsAsFactors = FALSE
)
}))
View(result_mat)
View(combined_contrast_tests)
View(result_mat)
pvals$test_statistic
#Store all contrast tests
all_contrast_tests = list()
cell_types = colnames(data$deconv)
regions = colnames(data$regions)
nregion = length(regions)
counter = 1
#test over all cell types and region pairs
for(ct in cell_types){
for(j in c(1:nregion)){
for(k in c(j:nregion)){
if(j==k){
next
}
region_A = regions[j]
region_B = regions[k]
#compute pvalues
pvals = suppressWarnings(spotglm::compute_contrast_significance(input_list = isoform_DE,
cell_type = ct,
effect_names = c(region_A,region_B),
beta_name = "beta_est",
covariance_name = "vcov",
sided = 2))
contrast_tests = data.frame(gene = pvals$name, cell_type = ct,
region_A = region_A, region_B = region_B,test_statistic = pvals$test_statistic,
pval = pvals$pval)
#add results to list
all_contrast_tests[[counter]] = contrast_tests
counter = counter + 1
}
}
}
combined_contrast_tests <- dplyr::bind_rows(all_contrast_tests)%>%
dplyr::filter(!is.na(pval))
#get significant switches
combined_contrast_tests$qval = p.adjust(combined_contrast_tests$pval,method = "BH")
significant_isoform_switches = combined_contrast_tests%>%filter(qval < 0.1)
View(combined_contrast_tests)
View(all_contrast_tests)
View(combined_contrast_tests)
