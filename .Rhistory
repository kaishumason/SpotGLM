shapes = c(1.1,1.1),nsim = 5000,half_effect = 1.908652e-03,extra_time_effect = 1.850556e-03){
#change in stats
diff_offense = player_skill_B[1] - player_skill_A[1]
diff_defense = player_skill_B[2] - player_skill_A[2]
diff_fatigue = time/11
#get change in goal rate
team_rate_A_post = team_rate_A + diff_offense * beta[["offense"]] - diff_fatigue * beta[["fatigue"]]
team_rate_B_post = team_rate_B + diff_defense * beta[["opp_defense"]] + diff_fatigue * beta[["fatigue"]]
#print(team_rate_A_post)
#print(team_rate_B_post)
#get half and extra time
half = (time >= 50) + 1
extra_time = as.numeric((time > 45 & time < 50) | (time > 95 & time < 100))
win_before = simulate_games(r1 = team_rate_A,r2 = team_rate_B,half = half, extra_time = extra_time,
scores_initial = score,rhos = rhos,time_start = time,nsim = nsim,shapes = shapes,
half_effect = half_effect, extra_time_effect = extra_time_effect,seed = 1)
win_after = simulate_games(r1 = team_rate_A_post,r2 = team_rate_B_post,half = half, extra_time = extra_time,
scores_initial = score,rhos = rhos,time_start = time,nsim = nsim,shapes = shapes,
half_effect = half_effect, extra_time_effect = extra_time_effect,seed = 1)
win_before_df = data.frame(P_win = win_before[1],P_lose = win_before[2],P_tie = win_before[3])
win_after_df = data.frame(P_win = win_after[1],P_lose = win_after[2],P_tie = win_after[3])
win_after[1] = predict(gam_win,win_after_df)
win_before[1] = predict(gam_win,win_before_df)
#win_after[2] = predict(gam_lose,win_after_df)
#win_before[2] = predict(gam_lose,win_before_df)
win_after[3] = predict(gam_tie,win_after_df)
win_before[3] = predict(gam_tie,win_before_df)
diff = win_after[1] - win_before[1] + 0.5*(win_after[3] - win_before[3])
W_after = win_after[1] + 0.5*(win_after[3])
W_before = win_before[1] +  0.5*(win_before[3])
print(W_after/W_before*100)
return(W_after/W_before*100)
}
s = 0.16
win_change(player_skill_A = exp(s*c(80,78)),player_skill_B = exp(s*c(78,78)),
team_rate_A = 0.015, team_rate_B = 0.015, beta = mean_beta,gam_win = gam_win,gam_tie = gam_tie,
score = c(1,0),rhos = rho, time = 80,nsim = 10000)
min_time = function(player_skill_A, player_skill_B,team_rate_A, team_rate_B,
beta,score,rhos,gam_win,gam_tie,
shapes = c(1.1,1.1),nsim = 5000,half_effect = 1.908652e-03,extra_time_effect = 1.850556e-03,min_diff = 0,acc = 1){
min_time = 0
max_time = 100
while(max_time - min_time > acc){
M = 0.5*(min_time + max_time)
print(paste0("Time:",M))
diff = win_change(player_skill_A = player_skill_A, player_skill_B = player_skill_B,team_rate_A = team_rate_A, team_rate_B = team_rate_B,
beta = beta,gam_win = gam_win,gam_tie = gam_tie,score = score,rhos = rhos,time = M,nsim = nsim)
if(diff > min_diff){
max_time = M
}else{
min_time = M
}
}
return(max_time)
}
min_time(player_skill_A = exp(sigma*c(90,80)),player_skill_B = exp(sigma*c(86,80)),
team_rate_A = 0.015, team_rate_B = 0.015, beta = mean_beta,gam_win = gam_win,gam_tie = gam_tie,
score = c(0,0),rhos = rho,nsim = 5000,min_diff = -0)
off = seq(70,100,by = 5)
off_times = matrix(NA,length(off),5)
for(j in c(1:length(off))){
for(k in c(1:5)){
print(c(j,k))
off_times[j,k] = min_time(player_skill_A = exp(sigma*c(off[j],80)),player_skill_B = exp(sigma*c(off[j] - k,80)),
team_rate_A = 0.015, team_rate_B = 0.015, beta = mean_beta,gam_win = gam_win,gam_tie = gam_tie,
score = c(0,0),rhos = rho,nsim = 10000,min_diff = 0.99)
}
}
min_time(player_skill_A = exp(sigma*c(90,80)),player_skill_B = exp(sigma*c(86,80)),
team_rate_A = 0.015, team_rate_B = 0.015, beta = mean_beta,gam_win = gam_win,gam_tie = gam_tie,
score = c(0,0),rhos = rho,nsim = 5000,min_diff = 0.99)
#read in functions to simulate games
source("/Users/kmason/Desktop/xg_paper/EPL-Simulations/junk/game_code.R")
truth = read.csv("/Users/kmason/Desktop/xg_paper/EPL-Simulations/observed_results.csv")
vegas = read.csv("/Users/kmason/Desktop/xg_paper/EPL-Simulations/vegas_results.csv")
win_prob = readRDS("/Users/kmason/Desktop/xg_paper/EPL-Simulations/win_prob.rds")
data_gamble = readRDS("/Users/kmason/Desktop/xg_paper/EPL-Simulations/games.rds")
outputs = readRDS("/Users/kmason/Desktop/xg_paper/EPL-Simulations/final_outputs.rds")
#extract stuff from outputs
mean_beta = outputs$mean_beta
rho = outputs$rhos
sigma = outputs$sigma
gam_win = outputs$gam_win
gam_lose = outputs$gam_lose
gam_tie = outputs$gam_tie
#get
win_change = function(player_skill_A, player_skill_B,team_rate_A, team_rate_B,
beta,score,rhos,time,gam_win,gam_tie,
shapes = c(1.1,1.1),nsim = 5000,half_effect = 1.908652e-03,extra_time_effect = 1.850556e-03){
#change in stats
diff_offense = player_skill_B[1] - player_skill_A[1]
diff_defense = player_skill_B[2] - player_skill_A[2]
diff_fatigue = time/11
#get change in goal rate
team_rate_A_post = team_rate_A + diff_offense * beta[["offense"]] - diff_fatigue * beta[["fatigue"]]
team_rate_B_post = team_rate_B + diff_defense * beta[["opp_defense"]] + diff_fatigue * beta[["fatigue"]]
#print(team_rate_A_post)
#print(team_rate_B_post)
#get half and extra time
half = (time >= 50) + 1
extra_time = as.numeric((time > 45 & time < 50) | (time > 95 & time < 100))
win_before = simulate_games(r1 = team_rate_A,r2 = team_rate_B,half = half, extra_time = extra_time,
scores_initial = score,rhos = rhos,time_start = time,nsim = nsim,shapes = shapes,
half_effect = half_effect, extra_time_effect = extra_time_effect,seed = 1)
win_after = simulate_games(r1 = team_rate_A_post,r2 = team_rate_B_post,half = half, extra_time = extra_time,
scores_initial = score,rhos = rhos,time_start = time,nsim = nsim,shapes = shapes,
half_effect = half_effect, extra_time_effect = extra_time_effect,seed = 1)
win_before_df = data.frame(P_win = win_before[1],P_lose = win_before[2],P_tie = win_before[3])
win_after_df = data.frame(P_win = win_after[1],P_lose = win_after[2],P_tie = win_after[3])
win_after[1] = predict(gam_win,win_after_df)
win_before[1] = predict(gam_win,win_before_df)
#win_after[2] = predict(gam_lose,win_after_df)
#win_before[2] = predict(gam_lose,win_before_df)
win_after[3] = predict(gam_tie,win_after_df)
win_before[3] = predict(gam_tie,win_before_df)
diff = win_after[1] - win_before[1] + 0.5*(win_after[3] - win_before[3])
W_after = win_after[1] + 0.5*(win_after[3])
W_before = win_before[1] +  0.5*(win_before[3])
print(W_after/W_before*100)
return(W_after/W_before*100)
}
s = 0.16
win_change(player_skill_A = exp(s*c(80,78)),player_skill_B = exp(s*c(78,78)),
team_rate_A = 0.015, team_rate_B = 0.015, beta = mean_beta,gam_win = gam_win,gam_tie = gam_tie,
score = c(1,0),rhos = rho, time = 80,nsim = 10000)
min_time = function(player_skill_A, player_skill_B,team_rate_A, team_rate_B,
beta,score,rhos,gam_win,gam_tie,
shapes = c(1.1,1.1),nsim = 5000,half_effect = 1.908652e-03,extra_time_effect = 1.850556e-03,min_diff = 99,acc = 1){
min_time = 0
max_time = 100
while(max_time - min_time > acc){
M = 0.5*(min_time + max_time)
print(paste0("Time:",M))
diff = win_change(player_skill_A = player_skill_A, player_skill_B = player_skill_B,team_rate_A = team_rate_A, team_rate_B = team_rate_B,
beta = beta,gam_win = gam_win,gam_tie = gam_tie,score = score,rhos = rhos,time = M,nsim = nsim)
if(diff > min_diff){
max_time = M
}else{
min_time = M
}
}
return(max_time)
}
min_time(player_skill_A = exp(sigma*c(90,80)),player_skill_B = exp(sigma*c(86,80)),
team_rate_A = 0.015, team_rate_B = 0.015, beta = mean_beta,gam_win = gam_win,gam_tie = gam_tie,
score = c(0,0),rhos = rho,nsim = 5000,min_diff = 99)
off = seq(70,100,by = 5)
off_times = matrix(NA,length(off),5)
for(j in c(1:length(off))){
for(k in c(1:5)){
print(c(j,k))
off_times[j,k] = min_time(player_skill_A = exp(sigma*c(off[j],80)),player_skill_B = exp(sigma*c(off[j] - k,80)),
team_rate_A = 0.015, team_rate_B = 0.015, beta = mean_beta,gam_win = gam_win,gam_tie = gam_tie,
score = c(0,0),rhos = rho,nsim = 10000,min_diff = 99)
}
}
def = seq(70,100,by = 5)
def_times = matrix(NA,length(off),5)
for(j in c(1:length(off))){
for(k in c(1:5)){
print(c(j,k))
def_times[j,k] = min_time(player_skill_A = exp(sigma*c(80,def[j])),player_skill_B = exp(sigma*c(80,def[j] - k)),
team_rate_A = 0.015, team_rate_B = 0.015, beta = mean_beta,gam_win = gam_win,gam_tie = gam_tie,
score = c(0,0),rhos = rho,nsim = 10000,min_diff = 99)
}
}
def_times
off_times
saveRDS(off_times,"off_times_tied.rds")
saveRDS(def_times,"def_times_tied.rds")
off = seq(70,100,by = 5)
off_times = matrix(NA,length(off),5)
for(j in c(1:length(off))){
for(k in c(1:5)){
print(c(j,k))
off_times[j,k] = min_time(player_skill_A = exp(sigma*c(off[j],80)),player_skill_B = exp(sigma*c(off[j] - k,80)),
team_rate_A = 0.015, team_rate_B = 0.015, beta = mean_beta,gam_win = gam_win,gam_tie = gam_tie,
score = c(1,0),rhos = rho,nsim = 10000,min_diff = 99)
}
}
saveRDS(off_times,"off_times_up_1.rds")
def = seq(70,100,by = 5)
def_times = matrix(NA,length(off),5)
for(j in c(1:length(off))){
for(k in c(1:5)){
print(c(j,k))
def_times[j,k] = min_time(player_skill_A = exp(sigma*c(80,def[j])),player_skill_B = exp(sigma*c(80,def[j] - k)),
team_rate_A = 0.015, team_rate_B = 0.015, beta = mean_beta,gam_win = gam_win,gam_tie = gam_tie,
score = c(1,0),rhos = rho,nsim = 10000,min_diff = 99)
}
}
saveRDS(def_times,"def_times_up_1.rds")
off = seq(70,100,by = 5)
off_times = matrix(NA,length(off),5)
for(j in c(1:length(off))){
for(k in c(1:5)){
print(c(j,k))
off_times[j,k] = min_time(player_skill_A = exp(sigma*c(off[j],80)),player_skill_B = exp(sigma*c(off[j] - k,80)),
team_rate_A = 0.015, team_rate_B = 0.015, beta = mean_beta,gam_win = gam_win,gam_tie = gam_tie,
score = c(0,1),rhos = rho,nsim = 10000,min_diff = 99)
}
}
saveRDS(off_times,"off_times_down_1.rds")
def = seq(70,100,by = 5)
def_times = matrix(NA,length(off),5)
for(j in c(1:length(off))){
for(k in c(1:5)){
print(c(j,k))
def_times[j,k] = min_time(player_skill_A = exp(sigma*c(80,def[j])),player_skill_B = exp(sigma*c(80,def[j] - k)),
team_rate_A = 0.015, team_rate_B = 0.015, beta = mean_beta,gam_win = gam_win,gam_tie = gam_tie,
score = c(0,1),rhos = rho,nsim = 10000,min_diff = 99)
}
}
saveRDS(def_times,"def_times_down_1.rds")
library(dplyr)
library(ggplot2)
library(tidyr)
library(mgcv)
library(MASS)
# Read in data
data = read.csv("/Users/kmason/Desktop/xg_paper/EPL-Simulations/main_data.csv")
players = read.csv("/Users/kmason/Desktop/xg_paper/EPL-Simulations/transformed_data.csv")
players = players[,-1]  # Remove the first column (index column)
# Convert categorical variables to factors
data$groups = factor(data$groups)
data$half = as.factor(data$half)
data$score_differential = as.factor(data$score_differential)
# Compute expected goals (xG) per unit time
data = data %>% mutate(xg_rate = xg / period_length)
# Remove rows where period_length is zero
no_time = which(data$period_length == 0)
data = data[-no_time,]
players = players[-no_time,]
# Split data into training (70%) and testing (30%)
train = sample(nrow(data), floor(nrow(data) * 0.7))
test = rep(0, nrow(data))
test[train] = 1
data = data %>% mutate(test = (test == 1))
# Compute fatigue metrics for offensive and defensive players
fatigue_offense = players[,which(substr(colnames(players),1,7) == "fatigue")]
fatigue_defense = players[,which(substr(colnames(players),1,7) == "opp_fat")]
data$fatigue = rowMeans(fatigue_offense) - rowMeans(fatigue_defense)
# Optimize sigma for the model
nsigma = 100
sigmas = seq(-1/100, 0.3, length.out = nsigma)
Loss = rep(0, nsigma)
for (j in c(1:nsigma)){
print(j)
sigma = sigmas[j]
# Transform player data using exponential function
exp_data = exp(players * sigma)
offense = rowSums(exp_data[,1:10])
opp_defense = rowSums(exp_data[,31:40])
weak_link_def = apply(players[,31:40],1,min)
strong_link_def = apply(players[,31:40],1,max)
weak_link_off = apply(players[,1:10],1,min)
strong_link_off = apply(players[,1:10],1,max)
diff = offense / opp_defense
# Prepare data for modeling
data_model = data %>% mutate(offense = offense, opp_defense = opp_defense,
weak_link_off = weak_link_off, weak_link_def = weak_link_def,
strong_link_off = strong_link_off, strong_link_def = strong_link_def)
# Fit weighted least squares regression model
form = formula(xg_rate ~ offense + opp_defense + half + fatigue + diff +
extra_time + home + score_differential + weak_link_off + weak_link_def)
model = lm(form, data = data_model, weights = period_length, subset = train)
# Predict and calculate loss
data_model = data_model %>% mutate(E_xg = predict(model, data_model) * period_length) %>% filter(test == 1)
Loss[j] = sum((data_model$xg - data_model$E_xg)^2)
}
# Plot testing loss vs sigma
plot(sigmas, Loss, main = "Testing Loss vs Sigma")
print(min(Loss))
#make final covaraites
sigma = sigmas[which.min(Loss)]
exp_data = exp(players*sigma)
offense = rowSums(exp_data[,1:10])
opp_defense = rowSums(exp_data[,31:40])
weak_link_def = apply(players[,31:40],1,min)
strong_link_def = apply(players[,31:40],1,max)
weak_link_off = apply(players[,1:10],1,min)
strong_link_off = apply(players[,1:10],1,max)
diff = offense/opp_defense
#make data matrix
data_model = data%>%mutate(offense = offense, opp_defense = opp_defense,
weak_link_off = weak_link_off,weak_link_def = weak_link_def)
#specify model
form = formula(xg_rate ~ offense + opp_defense + half + fatigue + diff +
extra_time + home + score_differential + weak_link_def + weak_link_off)
#fit model
model = lm(form,data = data_model,weights = period_length)
#add results to data matrix
data_model = data_model %>% mutate(E_xg = predict(model,data_model) * period_length)%>%
mutate(E_xg_rate = predict(model,data_model))
#aggregate results over teams
aggregated_data = data_model %>%
group_by(groups) %>%
summarise(
aggregate_xg = sum(xg, na.rm = TRUE),
aggregate_E_xg = sum(E_xg, na.rm = TRUE)
)
# Generate scatter plot
ggplot(aggregated_data, aes(x = aggregate_E_xg, y = aggregate_xg)) +
geom_point() +
geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red") +
labs(
title = paste("Scatterplot of Aggregated E[xG] vs xG (sigma =", round(sigma, 3), ")"),
x = "Aggregated E[xG]",
y = "Aggregated xG"
) +
theme_minimal()
# Generate scatter plot
ggplot(aggregated_data, aes(x = aggregate_E_xg, y = aggregate_xg)) +
geom_point() +
geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red") +
labs(
title = paste("Scatterplot of Aggregated E[xG] vs xG"),
x = "Aggregated E[xG]",
y = "Aggregated xG"
) +
theme_minimal()
data = sparrow::read_visiumHD()
bad_cells = which(Matrix::rowSums(data$counts) < 200)
data$coords = data$coords[-bad_cells,]
data$deconv = data$deconv[-bad_cells,]
data$niche = data$niche[-bad_cells,]
data$counts = data$counts[-bad_cells,]
dim(data$counts)
y = data$counts[,1]
X = data$niche
lambda = data$deconv
family = "spot poisson"
initialization = "full"
beta_0 = NULL
fix_coef = NULL
offset = log(Matrix::rowSums(data$counts))
min_deconv = 0.1
min_freq = 50
CT = NULL
weights = NULL
ct_cov_weights = NULL
max_gd_steps = 5000
learning_rate = 1
max_diff = 1-1e-6
intercept_col = NULL
t1 = Sys.time()
test = run_model(y = y,X = X,lambda = lambda,family = family,beta_0 =beta_0,fix_coef = fix_coef,
offset = offset,min_deconv =min_deconv,min_freq = min_freq,CT = CT, weights = weights,ct_cov_weights = ct_cov_weights,
max_gd_steps = max_gd_steps,learning_rate = learning_rate,max_diff = max_diff,intercept_col = intercept_col)
t1 = Sys.time()
test = spotglm:::run_model(y = y,X = X,lambda = lambda,family = family,beta_0 =beta_0,fix_coef = fix_coef,
offset = offset,min_deconv =min_deconv,min_freq = min_freq,CT = CT, weights = weights,ct_cov_weights = ct_cov_weights,
max_gd_steps = max_gd_steps,learning_rate = learning_rate,max_diff = max_diff,intercept_col = intercept_col)
print(Sys.time() - t1)
#Step 0: Pre-processing
if(is.null(weights)){
weights = rep(1,length(y))
}else if(length(weights)!= length(y)){
stop("Weights must be same length as observations")
}
if(is.null(ct_cov_weights)){
ct_cov_weights = rep(1,ncol(lambda))
}else if(length(ct_cov_weights)!= ncol(lambda)){
stop("Weights must be same length as number of columns of lambda")
}
#weight lambda by cov weights and normalize
if(is.null(ct_cov_weights) == F){
if(length(ct_cov_weights) != ncol(lambda)){
stop("Cell type covariate weights must be the same length as #col lambda")
}
lambda = sweep(lambda,2,ct_cov_weights,"*")
lambda = sweep(lambda,1,rowSums(lambda),"/")
lambda[is.na(lambda)] = 1/ncol(lambda)
}
#get family
if(family == "spot gaussian"){
model_family = "spot_gaussian"
sc_family = "gaussian"
}else if(family == "spot poisson"){
model_family = "spot_poisson"
sc_family = "poisson"
}else if(family == "spot negative binomial"){
model_family = "spot_negative_binomial"
sc_family = "poisson"
}else if(family == "spot binomial"){
model_family = "spot_binomial"
sc_family = "binomial"
}else{
stop("Family must be one of spot gaussian, spot poisson, spot negative binomial, or spot binomial")
}
if(is.null(fix_coef)){
fix_coef = matrix(FALSE,ncol(X),ncol(lambda))
}else if( (nrow(fix_coef)!= ncol(X)) |(ncol(fix_coef)!= ncol(lambda))){
stop("Fixed coefficients matrix must be of dimension ncol(X) by ncol(lambda)")
}
#Step 1: get initial beta
if(is.null(beta_0)){
beta_0 = matrix(0,ncol(X),ncol(lambda))
}else if( (nrow(beta_0)!= ncol(X)) |(ncol(beta_0)!= ncol(lambda))){
stop("Initial beta matrix must be of dimension ncol(X) by ncol(lambda)")
}
if(initialization == "intercept"){
initial_run= spotglm:::initialize_beta_intercept(y = y, X = X, lambda = lambda,beta = beta_0,
family = sc_family,offset = offset,
weights = weights,fix_coef = fix_coef,CT = CT,min_freq = min_freq,intercept_ind = intercept_col)
beta_0 = initial_run$beta_0
fix_coef = initial_run$fix_coef
}else if(initialization == "full"){
initial_run = spotglm:::initialize_beta_full(y = y, X = X, lambda = lambda,beta = beta_0,
family = sc_family,offset = offset,
weights = weights,fix_coef = fix_coef,CT = CT,min_freq = min_freq,intercept_ind = intercept_col)
beta_0 = initial_run$beta_0
fix_coef = initial_run$fix_coef
}else{
print("No initialization chosen. Must be one of intercept or full.")
}
beta_0
table(apply(lambda,1,function(x){which.max(x)}))
data = sparrow::read_visiumHD()
bad_cells = which(Matrix::rowSums(data$counts) < 50)
data$coords = data$coords[-bad_cells,]
data$deconv = data$deconv[-bad_cells,]
data$niche = data$niche[-bad_cells,]
data$counts = data$counts[-bad_cells,]
library(spotglm)
j=1
t1 = Sys.time()
y = data$counts[,j]
X = data$niche
lambda = data$deconv
family = "spot poisson"
initialization = "full"
beta_0 = NULL
fix_coef = NULL
offset = log(Matrix::rowSums(data$counts))
min_deconv = 0.1
min_freq = 50
CT = NULL
weights = NULL
ct_cov_weights = NULL
max_gd_steps = 5000
learning_rate = 1
max_diff = 1-1e-6
intercept_col = NULL
test = spotglm:::run_model(y = y,X = X,lambda = lambda,family = family,beta_0 =beta_0,fix_coef = fix_coef,
offset = offset,min_deconv =min_deconv,min_freq = min_freq,CT = CT, weights = weights,ct_cov_weights = ct_cov_weights,
max_gd_steps = max_gd_steps,learning_rate = learning_rate,max_diff = max_diff,intercept_col = intercept_col)
print(Sys.time() - t1)
test$niter
test$time
test$beta_est
## Step 0: Loading Data and Pre-processing
data = sparrow::read_visiumHD()
data$deconv[data$deconv < 0.1] = 0
data$deconv = t(apply(data$deconv,1,function(x){x/sum(x)}))
data$niche[data$niche < 0.1] = 0
data$niche = t(apply(data$niche,1,function(x){x/sum(x)}))
#remove spots with too few UMIs
bad_spots = which(rowSums(data$counts) < 20)
data$coords = data$coords[-bad_spots,]
data$niche = data$niche[-bad_spots,]
data$deconv = data$deconv[-bad_spots,]
data$counts = data$counts[-bad_spots,]
#make niche matrix has reference column
data$niche = data$niche[,-9]
data$niche = cbind(1,data$niche)
colnames(data$niche)[1] = "intercept"
freq = apply(data$niche,2,function(x){sum(x)})
bad_niche = which(freq<500)
if(length(bad_niche)> 0){
data$niche = data$niche[,-bad_niche]
}
library(spotglm)
library(sparrow)
colSums(data$niche)
sim_data = sparrow::simulate_data(n = 100000, nct = 9,effect_scale = 1/4, intercept_scale = 4,library_size = 5000, spot_ct = 2, p = 5, num_null = 2, prob_ct = NULL)
family = "spot poisson"
initialization = "intercept"
beta_0 = NULL
fix_coef = NULL
offset = rep(log(5000),length(sim_data$y))
min_deconv = 0.1
min_freq = 50
CT = NULL
weights = NULL
ct_cov_weights = NULL
n_epochs = 100
batch_size = 500
learning_rate = 1
max_diff = 1-1e-6
intercept_col = 1
y = sim_data$y
X = sim_data$X
lambda = sim_data$lambda
t1 = Sys.time()
sim_test = run_model(y = sim_data$y,X = sim_data$X,lambda = sim_data$lambda,family = "spot poisson",beta_0 =beta_0,fix_coef = fix_coef,
offset = offset,min_deconv =min_deconv,min_freq = min_freq,CT = CT, weights = weights,ct_cov_weights = ct_cov_weights,
n_epochs = n_epochs,batch_size= batch_size,learning_rate = learning_rate,max_diff = max_diff,intercept_col = c(1),initialization = initialization)
print(Sys.time() - t1)
plot(sim_data$beta[-1,],sim_test$beta_est[-1,])
abline(a = 0, b = 1, col = "red")
setwd("/Users/kmason/Desktop/sparrow")
devtools::document()
devtools::install()
setwd("/Users/kmason/Desktop/Folders/research_projects/spatial/spotglm")
devtools::document()
devtools::install()
setwd("/Users/kmason/Desktop/sparrow")
devtools::document()
setwd("/Users/kmason/Desktop/Folders/research_projects/spatial/spotglm")
devtools::document()
devtools::install()
