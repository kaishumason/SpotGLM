D = Rfast::dista(xnew = as.matrix(cell_coord), x = ref_list$coord[candidate_cells,], type = "euclidean",trans = T)
#get matched cells
chosen = min(neighborhood_size,length(candidate_cells))
matches = candidate_cells[order(D,decreasing = F)[1:chosen]]
#do matching
#get spot data
spot = as.matrix(serial_list$data[,j])
#get P matrix in quadprog
cell_prof = ref_list$data[,matches]
P = t(cell_prof)%*%cell_prof
#get c in quadprog
c = as.vector(t(-2*t(spot)%*%cell_prof))
# Number of decision variables
n <- dim(P)[1]
# Create a Gurobi model
model <- list()
#specify model objective
model$Q = P
model$obj = c
model$vtype = rep("C",n)
#specify constraints
model$A = matrix(rep(1,2*n),nrow = 2)
model$rhs = c(10000,0)
model$sense = c("<",">")
#fit model
result <- gurobi(model,params = list(OutputFlag=0,TimeLimit = 2))
#get objective value and matches
score[k] = result$objval
neigh[[k]] = matches
weights[[k]] = result$x
}
#step 4: Get best match
#best_cell = which.min(score)
best_cells = order(score)[1:min(c(10,length(closest_cells)))]
#save results
ns = c()
ws = c()
for(cell in best_cells){
ns = c(ns,neigh[[cell]])
ws = c(ws,weights[[cell]])
}
cell_to_spot[[j]] = ns
cell_weight[[j]] = ws
}
t_end_all = Sys.time()
print(t_end_all-t_start_all)
return(list(cell_to_spot = cell_to_spot,cell_weight = cell_weight))
}
serial_match_test = function(serial_list,ref_list,query_NN,reference_KNN,log_print = TRUE){
#Step 2: Matching over each spot
t_start_all = Sys.time()
t_start = Sys.time()
#matches
cell_to_spot = list()
cell_weight = list()
#iterate over all spots
for(j in c(1:ncol(serial_list$data))){
#print every 100 iterations
if(j%%100 == 0 & log_print){
print(paste0("On iteration ", j))
t_end = Sys.time()
print(t_end-t_start)
t_start = Sys.time()
}
#step 1: get nearest cells by neighbors
closest_cells = query_NN[j,]
#n_close = length(closest_cells)
#filter out cells that are too close (i.e within half the nieghborhood distance)
#rem_cells = c()
#for(k in c(1:(n_close))){
#}
#remove cells that are too close
#if(length(rem_cells) > 0){
#closest_cells = closest_cells[-rem_cells]
#}
#step 3: match for each cell
#t1 = Sys.time()
neigh = list()
weights = list()
score = rep(NA,length(closest_cells))
#iteate over candidate cells
#get spot data
spot = as.matrix(serial_list$data[,j])
shit_time = 0
deconv_time = 0
for(k in c(1:length(closest_cells))){
#t3 = Sys.time()
#get cell
cell = closest_cells[k]
#get candidate cells
candidate_cells = reference_KNN[[cell]]
#print("that shit step")
#t2 = Sys.time()
#shit_time = shit_time + (t2-t3)
#print(t2-t3)
#get distances
matches = candidate_cells
#do matching
#t3 = Sys.time()
#get P matrix in quadprog
cell_prof = ref_list$data[,matches]
P = t(cell_prof)%*%cell_prof
#get c in quadprog
c = as.vector(t(-2*t(spot)%*%cell_prof))
# Number of decision variables
n <- dim(P)[1]
# Create a Gurobi model
model <- list()
#t2 = Sys.time()
#deconv_time = deconv_time + (t2-t3)
#print(t2-t3)
#t3 = Sys.time()
#specify model objective
model$Q = P
model$obj = c
model$vtype = rep("C",n)
#specify constraints
model$A = matrix(rep(1,2*n),nrow = 2)
model$rhs = c(10000,0)
model$sense = c("<",">")
#fit model
result <- gurobi(model,params = list(OutputFlag=0,TimeLimit = 2))
#get objective value and matches
score[k] = result$objval
neigh[[k]] = matches
weights[[k]] = result$x
#print("deconvolution step")
#t2 = Sys.time()
#deconv_time = deconv_time + (t2-t3)
#print(t2-t3)
}
#print("deconvolution")
#t2 = Sys.time()
#print(t2-t1)
#step 4: Get best match
#best_cell = which.min(score)
#print("Time to do that shit")
#print(shit_time)
#print("Time to deconv")
#print(deconv_time)
best_cells = order(score)[1:min(c(10,length(closest_cells)))]
#save results
ns = c()
ws = c()
for(cell in best_cells){
ns = c(ns,neigh[[cell]])
ws = c(ws,weights[[cell]])
}
cell_to_spot[[j]] = ns
cell_weight[[j]] = ws
}
t_end_all = Sys.time()
print(t_end_all-t_start_all)
return(list(cell_to_spot = cell_to_spot,cell_weight = cell_weight))
}
deconv = function(serial_match_result,CT_list){
#get all CT
all_ct = unique(CT_list)
NCT = length(all_ct)
#get number of spots
N = length(serial_match_result$cell_to_spot)
#initialize matrix
deconvolution = matrix(0,N,NCT)
colnames(deconvolution) = all_ct
#iterate over spots
for(j in c(1:N)){
#get cell specific weights
weights = serial_match_result$cell_weight[[j]]/sum(serial_match_result$cell_weight[[j]])
#get cell types
CT = CT_list[serial_match_result$cell_to_spot[[j]]]
#iterate over cell types
for(k in c(1:NCT)){
#get which indices have that cell type
inds = which(CT == all_ct[k])
#if ther are some of that cell type, add it to the deconvolution
if(length(inds) > 0){
deconvolution[j,k] = sum(weights[inds])
}
}
}
return(deconvolution)
}
neighborhood_deconvolution = function(query_list,reference_list,sigma,num_matches,neighborhood_size){
#first generate neighborhood embeddings
print("Getting neighborhood embeddings")
query_embed = neighborhood_embed_try(query_list$coord,query_list$data,sigma[1],neighborhood_size)$EN
reference_embed = neighborhood_embed_try(reference_list$coord,reference_list$data,sigma[2],neighborhood_size)
reference_KNN = reference_embed$KNN$nn.index
reference_embed = reference_embed$EN
#then match the embeddings to a common space
print("Performing batch correction")
embeds = neighborhood_match(query_embed,reference_embed,num_matches)
#save embeddings
query_embed = embeds$query_embed
reference_embed = embeds$reference_embed
#compute nearest neighbors
query_NN = embeds$query_KNN$nn.index
#update query list
query_list$embed = query_embed
query_list$data = t(query_list$data)
#update reference list, normalize each cell to have sum of gene expression be 100
reference_list$embed = reference_embed
reference_list$data = apply(reference_list$data,1,function(x){100*x/sum(x)})
#turn knn into list
reference_KNN <- split(reference_KNN, row(reference_KNN))
#perform deconvolution
print("Performing deconvolution")
serial_match_result = serial_match_test(query_list,reference_list,query_NN,reference_KNN)
#get deconvolution matrix
return(deconv(serial_match_result,reference_list$CT))
}
library(Seurat)
library(Matrix)
library(abind)
library(readxl)
library(dplyr)
library(stringr)
library(kableExtra)
library(knitr)
library(proxy)
library(nnls)
library(spatstat.utils)
library(harmony)
library(gurobi)
library(ggplot2)
#####Scale genes to weight them better so not dominated by one gene
#####Use batch(similar spots with similar expresseion levels in the same spatial neighborhood)
#quadratic programming and add penalty which effectively smooths
#####
#get data dir
dir = "/Users/kmason/Desktop/Folders/research_projects/SerialIntegration/data"
data.dir = paste0(dir,"/xenium")
data.dir.vis = paste0(dir,"/visium")
data.dir.sc = paste0(dir,"/scFFPE")
#get data dir
dir = "/Users/kmason/Desktop/Folders/research_projects/SerialIntegration/data"
data.dir = paste0(dir,"/xenium")
data.dir.vis = paste0(dir,"/visium")
data.dir.sc = paste0(dir,"/scFFPE")
X = readRDS(paste0(dir,"/Xenium_BC/xenium_data.rds"))
X_coord = read.csv("/Users/kmason/Desktop/spatial_data/xenium_coord.csv")
bad_cell = which(colSums(X) < 50)
X = X[,-bad_cell]
X_coord = X_coord[-bad_cell,]
Y = readRDS(paste0(dir,"/Xenium_BC/visium_data.rds"))
Y_coord = read.csv("/Users/kmason/Desktop/spatial_data/visium_coord.csv")
bad_spot = which(colSums(Y) < 100)
Y = Y[,-bad_spot]
Y_coord = Y_coord[-bad_spot,]
Y_orig = Y
#get path to cell types
path <- paste0("/Users/kmason/Desktop/Folders/research_projects/SerialIntegration/data/xenium_scffpe_visium_CT.xlsx")
#read cell types
sheetnames <- excel_sheets(path)
#make into a list
mylist <- lapply(excel_sheets(path), read_excel, path = path)
# name the dataframes
names(mylist) <- sheetnames
#get xenium cell types
xenium_CT = mylist$`Xenium R1 Fig1-5 (supervised)`
xenium_CT = xenium_CT[-bad_cell,]
#read in data
xenium.obj = readRDS("/Users/kmason/Desktop/spatial_data/Xenium_V1_FFPE_Human_Breast_IDC_outs/maxfuse/xenium_BC.rds")
bad_cells = which(colSums(xenium.obj@assays$Xenium$counts)  < 10)
xenium.obj = readRDS("/Users/kmason/Desktop/spatial_data/Xenium_V1_FFPE_Human_Breast_IDC_outs/maxfuse/xenium_BC_filtered.rds")
#desig = rep("good_cells",ncol(xenium.obj))
#desig[bad_cells] = "bad_cells"
#Idents(xenium.obj) = as.factor(desig)
#remove bad cells from xenium
#xenium.obj = subset(x = xenium.obj,idents = "good_cells")
#get coordiantes
coord = GetTissueCoordinates(xenium.obj)
#get counts matrix
Z_data = xenium.obj@assays$Xenium$counts
#get mapping between zells in Z and cells in X
mapping_X_Z = read.csv("/Users/kmason/Desktop/spatial_data/Xenium_V1_FFPE_Human_Breast_IDC_outs/maxfuse/xenium_scrnaseq.csv")
mapping_X_Z = mapping_X_Z[-bad_cells,]
#get cell types
mapping_X_Z[,1] = mapping_X_Z[,1] + 1
mapping_X_Z[,2] = mapping_X_Z[,2] + 1
CT_Z = as.matrix(xenium_CT[,2])[mapping_X_Z[,1]]
#gene matching
genes_common = rownames(Y)[which(rownames(Y)%in%rownames(Z_data))]
Z_data = Z_data[genes_common,]
Y = Y[genes_common,]
scale_X = (range(coord[,1])[2] - range(coord[,1])[1])/(range(Y_coord[,1])[2] - range(Y_coord[,1])[1])
scale_Y = (range(coord[,2])[2] - range(coord[,2])[1])/(range(Y_coord[,2])[2] - range(Y_coord[,2])[1])
Y_coord[,1] = Y_coord[,1]*scale_X
Y_coord[,2] = Y_coord[,2]*scale_Y
reference_list = list(data = t(Z_data),coord = coord[,1:2],CT = CT_Z)
query_list = list(data = t(Y),coord = Y_coord)
deconv_quad = neighborhood_deconvolution(query_list,reference_list,c(25,25),100,20)
visium_deconv = deconv_quad
ground_truth = ground_truth[,colnames(visium_deconv)]
#get ground truth
ground_truth = readRDS(paste0(dir,"/Xenium_BC/true_deconv.rds"))
ground_truth = t(ground_truth)
#remove bad spots
ground_truth = ground_truth[-bad_spot,]
ground_truth = ground_truth[,colnames(visium_deconv)]
#remove _ from colnames
colnames(visium_deconv) = gsub("_", " ", colnames(visium_deconv))
#remove _ from colnames
colnames(ground_truth) = gsub("_", " ", colnames(ground_truth))
#remove unlabled
unlabled = which(colnames(ground_truth)=="Unlabeled")
ground_truth = ground_truth[,-unlabled]
visium_deconv = visium_deconv[,-unlabled]
sqrt(mean((ground_truth - visium_deconv)^2,na.rm = T))
#get CARD
card_deconv = readRDS(paste0(dir,"/Xenium_BC/CARD_deconv.rds"))
card_deconv = card_deconv[,colnames(visium_deconv)]
saveRDS(visium_deconv,paste0(dir,"/Xenium_BC/quad_deconv.rds"))
deconv_rctd = readRDS(paste0(dir,"/Xenium_BC/rctd_deconv.rds"))
deconv_rctd = deconv_rctd[,colnames(ground_truth)]
spatial = as.data.frame(Y_coord)
colnames(spatial) = c("x","y")
index = colnames(visium_deconv)[2]
index2 = index
if(index == "DCIS 1"){
index2 = "DCIS 2"
}
if(index == "DCIS 2"){
index2 = "DCIS 1"
}
spatial$quad = visium_deconv[,index]
spatial$quad = pmin(spatial$quad,quantile(spatial$quad,0.99,na.rm = T))
spatial$rctd = deconv_rctd[,index2]
spatial$rctd = pmin(spatial$rctd,quantile(spatial$rctd,0.99,na.rm = T))
spatial$true = ground_truth[,index]
spatial$true = pmin(spatial$true,quantile(spatial$true,0.99,na.rm = T))
spatial$CARD = card_deconv[,index2]
spatial$CARD = pmin(spatial$CARD,quantile(spatial$true,0.99,na.rm = T))
ggplot(spatial, aes(x = x, y = y, color = quad)) +
geom_point() +
scale_color_gradient(low = "blue", high = "red")+  # Specify color gradient
ggtitle(paste0(index,": Quadratic Deconvolution"))
ggplot(spatial, aes(x = x, y = y, color = rctd)) +
geom_point() +
scale_color_gradient(low = "blue", high = "red")+  # Specify color gradient
ggtitle(paste0(index,": RCTD Deconvolution"))
ggplot(spatial, aes(x = x, y = y, color = CARD)) +
geom_point() +
scale_color_gradient(low = "blue", high = "red") + # Specify color gradient
ggtitle(paste0(index,": CARD Deconvolution"))
ggplot(spatial, aes(x = x, y = y, color = true)) +
geom_point() +
scale_color_gradient(low = "blue", high = "red") + # Specify color gradient
ggtitle(paste0(index,": True Deconvolution"))
print(index)
print(cor(spatial$quad,spatial$true,use='complete.obs'))
print(cor(spatial$rctd,spatial$true,use='complete.obs'))
print(cor(spatial$quad,spatial$CARD,use='complete.obs'))
print(index)
print(sum((spatial$quad-spatial$true)^2,na.rm=TRUE))
print(sum((spatial$rctd-spatial$true)^2,na.rm=TRUE))
print(sum((spatial$quad-spatial$CARD)^2,na.rm=TRUE))
sqrt(mean((ground_truth - visium_deconv)^2,na.rm = T))
sqrt(mean((ground_truth - card_deconv)^2,na.rm = T))
sqrt(mean((ground_truth - check)^2,na.rm = T))
sqrt(mean((ground_truth - visium_deconv)^2,na.rm = T))
sqrt(mean((ground_truth - card_deconv)^2,na.rm = T))
sqrt(mean((ground_truth - check)^2,na.rm = T))
check = card_deconv
check = check[,c(19,2:18,1)]
sqrt(mean((ground_truth - visium_deconv)^2,na.rm = T))
sqrt(mean((ground_truth - card_deconv)^2,na.rm = T))
sqrt(mean((ground_truth - check)^2,na.rm = T))
check_rctd = deconv_rctd
check_rctd = check_rctd[,c(19,2:18,1)]
sqrt(mean((ground_truth - deconv_rctd)^2,na.rm = T))
sqrt(mean((ground_truth - check_rctd)^2,na.rm = T))
deconv_rctd = readRDS(paste0(dir,"/Xenium_BC/rctd_deconv.rds"))
deconv_rctd = deconv_rctd[,colnames(ground_truth)]
sqrt(mean((ground_truth - deconv_rctd)^2,na.rm = T))
colnames(deconv_rctd)
check_rctd = check_rctd[,c(1:3,8,5:7,4,9:19)]
sqrt(mean((ground_truth - check_rctd)^2,na.rm = T))
scrnaseq = readRDS(paste0(dir,"/Xenium_BC/scffpe_data.rds"))
dim(scrnaseq)
scrnaseq = readRDS(paste0(dir,"/Xenium_BC/scffpe_data.rds"))
scrnaseq = t(scrnaseq)
write.csv(scrna_seq,"/Users/kmason/Desktop/spatial_data/Xenium_V1_FFPE_Human_Breast_IDC_outs/maxfuse/ref_scrnaseq_data.csv")
scrnaseq = readRDS(paste0(dir,"/Xenium_BC/scffpe_data.rds"))
scrnaseq = t(scrnaseq)
write.csv(scrnaseq,"/Users/kmason/Desktop/spatial_data/Xenium_V1_FFPE_Human_Breast_IDC_outs/maxfuse/ref_scrnaseq_data.csv")
library(Seurat)
library(Matrix)
library(abind)
library(readxl)
library(dplyr)
library(stringr)
library(kableExtra)
library(knitr)
library(proxy)
library(nnls)
library(spatstat.utils)
library(harmony)
library(gurobi)
library(ggplot2)
#####Scale genes to weight them better so not dominated by one gene
#####Use batch(similar spots with similar expresseion levels in the same spatial neighborhood)
#quadratic programming and add penalty which effectively smooths
#####
#get data dir
dir = "/Users/kmason/Desktop/Folders/research_projects/SerialIntegration/data"
data.dir = paste0(dir,"/xenium")
data.dir.vis = paste0(dir,"/visium")
data.dir.sc = paste0(dir,"/scFFPE")
#get data dir
dir = "/Users/kmason/Desktop/Folders/research_projects/SerialIntegration/data"
data.dir = paste0(dir,"/xenium")
data.dir.vis = paste0(dir,"/visium")
data.dir.sc = paste0(dir,"/scFFPE")
X = readRDS(paste0(dir,"/Xenium_BC/xenium_data.rds"))
X_coord = read.csv("/Users/kmason/Desktop/spatial_data/xenium_coord.csv")
bad_cell = which(colSums(X) < 50)
X = X[,-bad_cell]
X_coord = X_coord[-bad_cell,]
Y = readRDS(paste0(dir,"/Xenium_BC/visium_data.rds"))
Y_coord = read.csv("/Users/kmason/Desktop/spatial_data/visium_coord.csv")
bad_spot = which(colSums(Y) < 100)
Y = Y[,-bad_spot]
Y_coord = Y_coord[-bad_spot,]
Y_orig = Y
scrnaseq = readRDS(paste0(dir,"/Xenium_BC/scffpe_data.rds"))
scrnaseq = t(scrnaseq)
#get path to cell types
path <- paste0("/Users/kmason/Desktop/Folders/research_projects/SerialIntegration/data/xenium_scffpe_visium_CT.xlsx")
#read cell types
sheetnames <- excel_sheets(path)
#make into a list
mylist <- lapply(excel_sheets(path), read_excel, path = path)
# name the dataframes
names(mylist) <- sheetnames
#get xenium cell types
xenium_CT = mylist$`Xenium R1 Fig1-5 (supervised)`
xenium_CT = xenium_CT[-bad_cell,]
View(mylist)
dim(Y)
dim(scrnaseq)
sc_CT = mylist$`scFFPE-Seq`
View(sc_CT)
mapping_X_Z = read.csv("/Users/kmason/Desktop/spatial_data/Xenium_V1_FFPE_Human_Breast_IDC_outs/maxfuse/xenium_scrnaseq.csv")
View(mapping_X_Z)
max(mapping_X_Z[,1])
dim(scrnaseq)
library(Seurat)
library(Matrix)
library(abind)
library(readxl)
library(dplyr)
library(stringr)
library(kableExtra)
library(knitr)
library(proxy)
library(nnls)
library(spatstat.utils)
library(harmony)
library(gurobi)
library(ggplot2)
#####Scale genes to weight them better so not dominated by one gene
#####Use batch(similar spots with similar expresseion levels in the same spatial neighborhood)
#quadratic programming and add penalty which effectively smooths
#####
#get data dir
dir = "/Users/kmason/Desktop/Folders/research_projects/SerialIntegration/data"
data.dir = paste0(dir,"/xenium")
data.dir.vis = paste0(dir,"/visium")
data.dir.sc = paste0(dir,"/scFFPE")
#get data dir
dir = "/Users/kmason/Desktop/Folders/research_projects/SerialIntegration/data"
data.dir = paste0(dir,"/xenium")
data.dir.vis = paste0(dir,"/visium")
data.dir.sc = paste0(dir,"/scFFPE")
X = readRDS(paste0(dir,"/Xenium_BC/xenium_data.rds"))
X_coord = read.csv("/Users/kmason/Desktop/spatial_data/xenium_coord.csv")
bad_cell = which(colSums(X) < 50)
X = X[,-bad_cell]
X_coord = X_coord[-bad_cell,]
Y = readRDS(paste0(dir,"/Xenium_BC/visium_data.rds"))
Y_coord = read.csv("/Users/kmason/Desktop/spatial_data/visium_coord.csv")
bad_spot = which(colSums(Y) < 100)
Y = Y[,-bad_spot]
Y_coord = Y_coord[-bad_spot,]
Y_orig = Y
scrnaseq = readRDS(paste0(dir,"/Xenium_BC/scffpe_data.rds"))
dim(scrnaseq)
scrnaseq = t(scrnaseq)
write.csv(scrnaseq,"/Users/kmason/Desktop/spatial_data/Xenium_V1_FFPE_Human_Breast_IDC_outs/maxfuse/ref_scrnaseq_data.csv")
#get path to cell types
path <- paste0("/Users/kmason/Desktop/Folders/research_projects/SerialIntegration/data/xenium_scffpe_visium_CT.xlsx")
#read cell types
sheetnames <- excel_sheets(path)
#make into a list
mylist <- lapply(excel_sheets(path), read_excel, path = path)
# name the dataframes
names(mylist) <- sheetnames
#get xenium cell types
xenium_CT = mylist$`Xenium R1 Fig1-5 (supervised)`
xenium_CT = xenium_CT[-bad_cell,]
ffpe_CT = mylist$`scFFPE-Seq`
View(ffpe_CT)
scrnaseq = readRDS(paste0(dir,"/Xenium_BC/scffpe_data.rds"))
scrnaseq = t(scrnaseq)
scrnaseq = scrnaseq[ffpe_CT$Barcode,]
rownames(scrnaseq)
mean(ffpe_CT$Barcode %in% rownames(scrnaseq))
seen_cells = ffpe_CT$Barcode[which(ffpe_CT$Barcode %in% rownames(scrnaseq))]
scrnaseq = scrnaseq[seen_cells,]
dim(scrnaseq)
write.csv(scrnaseq,"/Users/kmason/Desktop/spatial_data/Xenium_V1_FFPE_Human_Breast_IDC_outs/maxfuse/ref_scrnaseq_data.csv")
