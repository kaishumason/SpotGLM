C[k] = log(cutoff,10)
if(is.infinite(C[k])){
C[k] = -15
}
}
}
# Load the ggplot2 library
library(ggplot2)
# Example data
data <- data.frame(
C = C,                # Replace with your actual 'C' values
recall = recall # Replace with your actual 'recall' values
)
# Create the plot
PLOT = ggplot(data, aes(x = C, y = recall)) +
geom_point() +  # Scatter points
geom_line() +   # Optional: Connect points with lines
scale_y_continuous(
limits = c(0, 1),            # Set y-axis limits
breaks = seq(0, 1, by = 0.1) # Add y-axis ticks
) +
theme_minimal() +  # Use a clean theme
labs(
x = "#Top Effects",          # Label for the x-axis
y = "Recall",     # Label for the y-axis
title = paste0("Recall vs #Top Effects: ",mode)
) +
theme(
panel.grid.major = element_line(color = "grey80"), # Add a grid
panel.grid.minor = element_blank()                 # Optional: Hide minor grids
)
print(PLOT)
#setwd("/Users/kmason/Desktop/Folders/research_projects/spatial/spatial_data/spotglm_data/visium_HD/deconvolution_output/analysis/results")
#results = list(C = C, recall = recall, NUM_CT = NUM_CT,DEN_CT = DEN_CT)
#saveRDS(results,paste0("results_",mode,".rds"))
}
setwd("/Users/kmason/Desktop/Folders/research_projects/spatial/spatial_data/spotglm_data/visium_HD/deconvolution_output/analysis/results")
modes = c("submodular","random","rasterized","geometric","submodular")
null_cov = readRDS("null_covariates.rds")
#good_cov = readRDS("good_covariates.rds")
modes = modes[c(2)]
for(mode in modes){
sc_res = readRDS("niche_DE_benchmark_no_intercept_test.rds")
query_res = readRDS(paste0("niche_DE_",mode,"_no_intercept_test.rds"))
ngene = length(sc_res)
contrast_test = function(beta,SE,COV,upper = T,null_cov = rep(FALSE,length(beta))){
pvals = matrix(NA,length(beta),length(beta))
for(j in c(1:length(beta))){
if(null_cov[j] == TRUE){
next
}
diff = beta[j] - beta
diff_SE = sqrt(SE[j]^2 + SE^2 - 2*COV[j,])
pvals[,j] = 2*(1-pnorm(abs(diff/diff_SE)))
}
if(upper){
pvals[upper.tri(pvals)] <- NA
}
diag(pvals) = NA
return(pvals)
}
c = 0
pvalue_query = c()
pvalue_test = c()
for(j in c(1:ngene)){
sc_result = sc_res[[j]]
query_result = query_res[[j]]
nCT = ncol(sc_result$beta)
nX = nrow(sc_result$beta)
for(k in c(1:nCT)){
R = ((k-1)*nX + 1):(k*nX)
p_test = contrast_test(sc_result$beta_est[,k],sc_result$stand_err_mat[,k],COV = sc_result$vcov[R,R],null_cov = null_cov[,k])
p_query = contrast_test(query_result$beta_est[,k],query_result$stand_err_mat[,k],COV = query_result$vcov[R,R],null_cov = null_cov[,k])
pvalue_query = c(pvalue_query,p_query)
pvalue_test = c(pvalue_test,p_test)
}
}
pvalue_query_adj = p.adjust(pvalue_query, method = "BH")
pvalue_test_adj = p.adjust(pvalue_test, method = "BH")
print(sum(pvalue_query_adj < 0.05,na.rm = T))
print(sum(pvalue_test_adj < 0.05,na.rm = T))
I = 1
counter = 1
pval_mat_test <- list()
pval_mat_query <- list()
for(ind in c(1:ngene)){
standard = sc_res[[ind]]$beta_est
query = query_res[[ind]]$beta_est
num_CT = ncol(query)
num_region = nrow(query)
pval_mat_query[[counter]] = array(0,dim = c(num_region,num_region,num_CT),
dimnames = list(rownames(query),rownames(query),colnames(query)))
pval_mat_test[[counter]] = array(0,dim = c(num_region,num_region,num_CT),
dimnames = list(rownames(query),rownames(query),colnames(query)))
for(j in c(1:num_CT)){
R = seq(I,I + num_region^2  - 1)
pval_mat_query[[counter]][,,j] = pvalue_query_adj[R]
pval_mat_test[[counter]][,,j] = pvalue_test_adj[R]
I = I + num_region^2
}
counter = counter + 1
}
CT_names = colnames(sc_res[[1]]$beta)
N = length(pvalue_test_adj[is.na(pvalue_test_adj)==F])
N = min(1000,sum(pvalue_test_adj[is.na(pvalue_test_adj)==F] <= 0.05))
N = sum(pvalue_test_adj[is.na(pvalue_test_adj)==F] <= 0.05)
set.seed(110)
Nind = 1000
Nindices = floor(seq(1,N,length.out = Nind))
order_pvals = sort(pvalue_test_adj[is.na(pvalue_test_adj)==F])
recall = rep(NA,Nind)
C = rep(NA,Nind)
recall_CT = matrix(NA,Nind,length(CT_names))
D_CT = matrix(NA,N,length(CT_names))
N_CT = matrix(NA,N,length(CT_names))
colnames(recall_CT) = CT_names
log_p = log10(pvalue_test_adj[is.na(pvalue_test_adj)==F])
log_p = log_p[is.infinite(log_p) == F]
min_log_p = min(log_p)
for(k in c(1:Nind)){
cutoff = max(1e-15,order_pvals[Nindices[k]])
NUM = 0
DEN = 0
rhos = rep(0,100)
NUM_CT = matrix(0,1,length(CT_names))
colnames(NUM_CT) = CT_names
DEN_CT = matrix(0,1,length(CT_names))
colnames(DEN_CT) = CT_names
for(ind in c(1:length(pval_mat_query))){
standard_p = pval_mat_test[[ind]]
query_p = pval_mat_query[[ind]]
standard_sig = (standard_p <= cutoff & is.na(query_p) == F)
dimnames(standard_sig) = dimnames(standard_p)
query_sig = (query_p <= 0.05)
dimnames(query_sig) = dimnames(query_p)
num_CT = dim(standard_sig)[3]
for(j in c(1:num_CT)){
name = dimnames(standard_sig)[[3]][j]
NUM_CT[,name] = NUM_CT[,name] + sum((standard_sig[,,j]) * query_sig[,,j],na.rm = T)
DEN_CT[,name] = DEN_CT[,name] + sum(standard_sig[,,j],na.rm = T)
}
recall_CT[k,] = NUM_CT/DEN_CT
D_CT[k,] = DEN_CT
N_CT[k,] = NUM_CT
NUM = NUM + sum(standard_sig * query_sig,na.rm = T)
DEN = DEN + sum(standard_sig,na.rm = T)
recall[k] = NUM/DEN
C[k] = log(cutoff,10)
if(is.infinite(C[k])){
C[k] = -15
}
}
}
# Load the ggplot2 library
library(ggplot2)
# Example data
data <- data.frame(
C = C,                # Replace with your actual 'C' values
recall = recall # Replace with your actual 'recall' values
)
# Create the plot
PLOT = ggplot(data, aes(x = C, y = recall)) +
geom_point() +  # Scatter points
geom_line() +   # Optional: Connect points with lines
scale_y_continuous(
limits = c(0, 1),            # Set y-axis limits
breaks = seq(0, 1, by = 0.1) # Add y-axis ticks
) +
theme_minimal() +  # Use a clean theme
labs(
x = "#Top Effects",          # Label for the x-axis
y = "Recall",     # Label for the y-axis
title = paste0("Recall vs #Top Effects: ",mode)
) +
theme(
panel.grid.major = element_line(color = "grey80"), # Add a grid
panel.grid.minor = element_blank()                 # Optional: Hide minor grids
)
print(PLOT)
#setwd("/Users/kmason/Desktop/Folders/research_projects/spatial/spatial_data/spotglm_data/visium_HD/deconvolution_output/analysis/results")
#results = list(C = C, recall = recall, NUM_CT = NUM_CT,DEN_CT = DEN_CT)
#saveRDS(results,paste0("results_",mode,".rds"))
}
9060/9433
setwd("/Users/kmason/Desktop/Folders/research_projects/spatial/spatial_data/spotglm_data/visium_HD/deconvolution_output/analysis/results")
modes = c("submodular","random","rasterized","geometric","submodular")
null_cov = readRDS("null_covariates.rds")
#good_cov = readRDS("good_covariates.rds")
modes = modes[c(5)]
for(mode in modes){
sc_res = readRDS("niche_DE_benchmark_no_intercept_test.rds")
query_res = readRDS(paste0("niche_DE_",mode,"_no_intercept_test.rds"))
ngene = length(sc_res)
contrast_test = function(beta,SE,COV,upper = T,null_cov = rep(FALSE,length(beta))){
pvals = matrix(NA,length(beta),length(beta))
for(j in c(1:length(beta))){
if(null_cov[j] == TRUE){
next
}
diff = beta[j] - beta
diff_SE = sqrt(SE[j]^2 + SE^2 - 2*COV[j,])
pvals[,j] = 2*(1-pnorm(abs(diff/diff_SE)))
}
if(upper){
pvals[upper.tri(pvals)] <- NA
}
diag(pvals) = NA
return(pvals)
}
c = 0
pvalue_query = c()
pvalue_test = c()
for(j in c(1:ngene)){
sc_result = sc_res[[j]]
query_result = query_res[[j]]
nCT = ncol(sc_result$beta)
nX = nrow(sc_result$beta)
for(k in c(1:nCT)){
R = ((k-1)*nX + 1):(k*nX)
p_test = contrast_test(sc_result$beta_est[,k],sc_result$stand_err_mat[,k],COV = sc_result$vcov[R,R],null_cov = null_cov[,k])
p_query = contrast_test(query_result$beta_est[,k],query_result$stand_err_mat[,k],COV = query_result$vcov[R,R],null_cov = null_cov[,k])
pvalue_query = c(pvalue_query,p_query)
pvalue_test = c(pvalue_test,p_test)
}
}
pvalue_query_adj = p.adjust(pvalue_query, method = "BH")
pvalue_test_adj = p.adjust(pvalue_test, method = "BH")
print(sum(pvalue_query_adj < 0.05,na.rm = T))
print(sum(pvalue_test_adj < 0.05,na.rm = T))
I = 1
counter = 1
pval_mat_test <- list()
pval_mat_query <- list()
for(ind in c(1:ngene)){
standard = sc_res[[ind]]$beta_est
query = query_res[[ind]]$beta_est
num_CT = ncol(query)
num_region = nrow(query)
pval_mat_query[[counter]] = array(0,dim = c(num_region,num_region,num_CT),
dimnames = list(rownames(query),rownames(query),colnames(query)))
pval_mat_test[[counter]] = array(0,dim = c(num_region,num_region,num_CT),
dimnames = list(rownames(query),rownames(query),colnames(query)))
for(j in c(1:num_CT)){
R = seq(I,I + num_region^2  - 1)
pval_mat_query[[counter]][,,j] = pvalue_query_adj[R]
pval_mat_test[[counter]][,,j] = pvalue_test_adj[R]
I = I + num_region^2
}
counter = counter + 1
}
CT_names = colnames(sc_res[[1]]$beta)
N = length(pvalue_test_adj[is.na(pvalue_test_adj)==F])
N = min(1000,sum(pvalue_test_adj[is.na(pvalue_test_adj)==F] <= 0.05))
N = sum(pvalue_test_adj[is.na(pvalue_test_adj)==F] <= 0.05)
set.seed(110)
Nind = 1000
Nindices = floor(seq(1,N,length.out = Nind))
order_pvals = sort(pvalue_test_adj[is.na(pvalue_test_adj)==F])
recall = rep(NA,Nind)
C = rep(NA,Nind)
recall_CT = matrix(NA,Nind,length(CT_names))
D_CT = matrix(NA,N,length(CT_names))
N_CT = matrix(NA,N,length(CT_names))
colnames(recall_CT) = CT_names
log_p = log10(pvalue_test_adj[is.na(pvalue_test_adj)==F])
log_p = log_p[is.infinite(log_p) == F]
min_log_p = min(log_p)
for(k in c(1:Nind)){
cutoff = max(1e-15,order_pvals[Nindices[k]])
NUM = 0
DEN = 0
rhos = rep(0,100)
NUM_CT = matrix(0,1,length(CT_names))
colnames(NUM_CT) = CT_names
DEN_CT = matrix(0,1,length(CT_names))
colnames(DEN_CT) = CT_names
for(ind in c(1:length(pval_mat_query))){
standard_p = pval_mat_test[[ind]]
query_p = pval_mat_query[[ind]]
standard_sig = (standard_p <= cutoff & is.na(query_p) == F)
dimnames(standard_sig) = dimnames(standard_p)
query_sig = (query_p <= 0.05)
dimnames(query_sig) = dimnames(query_p)
num_CT = dim(standard_sig)[3]
for(j in c(1:num_CT)){
name = dimnames(standard_sig)[[3]][j]
NUM_CT[,name] = NUM_CT[,name] + sum((standard_sig[,,j]) * query_sig[,,j],na.rm = T)
DEN_CT[,name] = DEN_CT[,name] + sum(standard_sig[,,j],na.rm = T)
}
recall_CT[k,] = NUM_CT/DEN_CT
D_CT[k,] = DEN_CT
N_CT[k,] = NUM_CT
NUM = NUM + sum(standard_sig * query_sig,na.rm = T)
DEN = DEN + sum(standard_sig,na.rm = T)
recall[k] = NUM/DEN
C[k] = log(cutoff,10)
if(is.infinite(C[k])){
C[k] = -15
}
}
}
# Load the ggplot2 library
library(ggplot2)
# Example data
data <- data.frame(
C = C,                # Replace with your actual 'C' values
recall = recall # Replace with your actual 'recall' values
)
# Create the plot
PLOT = ggplot(data, aes(x = C, y = recall)) +
geom_point() +  # Scatter points
geom_line() +   # Optional: Connect points with lines
scale_y_continuous(
limits = c(0, 1),            # Set y-axis limits
breaks = seq(0, 1, by = 0.1) # Add y-axis ticks
) +
theme_minimal() +  # Use a clean theme
labs(
x = "#Top Effects",          # Label for the x-axis
y = "Recall",     # Label for the y-axis
title = paste0("Recall vs #Top Effects: ",mode)
) +
theme(
panel.grid.major = element_line(color = "grey80"), # Add a grid
panel.grid.minor = element_blank()                 # Optional: Hide minor grids
)
print(PLOT)
#setwd("/Users/kmason/Desktop/Folders/research_projects/spatial/spatial_data/spotglm_data/visium_HD/deconvolution_output/analysis/results")
#results = list(C = C, recall = recall, NUM_CT = NUM_CT,DEN_CT = DEN_CT)
#saveRDS(results,paste0("results_",mode,".rds"))
}
query_res[[5]]$niter
query_res[[5]]$beta_est
query_res[[5]]$vcov[1:9,1:9]
sqrt(query_res[[5]]$vcov[1:9,1:9])
setwd("/Users/kmason/Desktop/Folders/research_projects/spatial/spatial_data/spotglm_data/visium_HD/deconvolution_output/analysis/results")
modes = c("submodular","random","rasterized","geometric","submodular")
null_cov = readRDS("null_covariates.rds")
#good_cov = readRDS("good_covariates.rds")
modes = modes[c(5)]
for(mode in modes){
sc_res = readRDS("niche_DE_benchmark_no_intercept.rds")
query_res = readRDS(paste0("niche_DE_",mode,"_no_intercept.rds"))
ngene = length(sc_res)
contrast_test = function(beta,SE,COV,upper = T,null_cov = rep(FALSE,length(beta))){
pvals = matrix(NA,length(beta),length(beta))
for(j in c(1:length(beta))){
if(null_cov[j] == TRUE){
next
}
diff = beta[j] - beta
diff_SE = sqrt(SE[j]^2 + SE^2 - 2*COV[j,])
pvals[,j] = 2*(1-pnorm(abs(diff/diff_SE)))
}
if(upper){
pvals[upper.tri(pvals)] <- NA
}
diag(pvals) = NA
return(pvals)
}
c = 0
pvalue_query = c()
pvalue_test = c()
for(j in c(1:ngene)){
sc_result = sc_res[[j]]
query_result = query_res[[j]]
nCT = ncol(sc_result$beta)
nX = nrow(sc_result$beta)
for(k in c(1:nCT)){
R = ((k-1)*nX + 1):(k*nX)
p_test = contrast_test(sc_result$beta_est[,k],sc_result$stand_err_mat[,k],COV = sc_result$vcov[R,R],null_cov = null_cov[,k])
p_query = contrast_test(query_result$beta_est[,k],query_result$stand_err_mat[,k],COV = query_result$vcov[R,R],null_cov = null_cov[,k])
pvalue_query = c(pvalue_query,p_query)
pvalue_test = c(pvalue_test,p_test)
}
}
pvalue_query_adj = p.adjust(pvalue_query, method = "BH")
pvalue_test_adj = p.adjust(pvalue_test, method = "BH")
print(sum(pvalue_query_adj < 0.05,na.rm = T))
print(sum(pvalue_test_adj < 0.05,na.rm = T))
I = 1
counter = 1
pval_mat_test <- list()
pval_mat_query <- list()
for(ind in c(1:ngene)){
standard = sc_res[[ind]]$beta_est
query = query_res[[ind]]$beta_est
num_CT = ncol(query)
num_region = nrow(query)
pval_mat_query[[counter]] = array(0,dim = c(num_region,num_region,num_CT),
dimnames = list(rownames(query),rownames(query),colnames(query)))
pval_mat_test[[counter]] = array(0,dim = c(num_region,num_region,num_CT),
dimnames = list(rownames(query),rownames(query),colnames(query)))
for(j in c(1:num_CT)){
R = seq(I,I + num_region^2  - 1)
pval_mat_query[[counter]][,,j] = pvalue_query_adj[R]
pval_mat_test[[counter]][,,j] = pvalue_test_adj[R]
I = I + num_region^2
}
counter = counter + 1
}
CT_names = colnames(sc_res[[1]]$beta)
N = length(pvalue_test_adj[is.na(pvalue_test_adj)==F])
N = min(1000,sum(pvalue_test_adj[is.na(pvalue_test_adj)==F] <= 0.05))
N = sum(pvalue_test_adj[is.na(pvalue_test_adj)==F] <= 0.05)
set.seed(110)
Nind = 1000
Nindices = floor(seq(1,N,length.out = Nind))
order_pvals = sort(pvalue_test_adj[is.na(pvalue_test_adj)==F])
recall = rep(NA,Nind)
C = rep(NA,Nind)
recall_CT = matrix(NA,Nind,length(CT_names))
D_CT = matrix(NA,N,length(CT_names))
N_CT = matrix(NA,N,length(CT_names))
colnames(recall_CT) = CT_names
log_p = log10(pvalue_test_adj[is.na(pvalue_test_adj)==F])
log_p = log_p[is.infinite(log_p) == F]
min_log_p = min(log_p)
for(k in c(1:Nind)){
cutoff = max(1e-15,order_pvals[Nindices[k]])
NUM = 0
DEN = 0
rhos = rep(0,100)
NUM_CT = matrix(0,1,length(CT_names))
colnames(NUM_CT) = CT_names
DEN_CT = matrix(0,1,length(CT_names))
colnames(DEN_CT) = CT_names
for(ind in c(1:length(pval_mat_query))){
standard_p = pval_mat_test[[ind]]
query_p = pval_mat_query[[ind]]
standard_sig = (standard_p <= cutoff & is.na(query_p) == F)
dimnames(standard_sig) = dimnames(standard_p)
query_sig = (query_p <= 0.05)
dimnames(query_sig) = dimnames(query_p)
num_CT = dim(standard_sig)[3]
for(j in c(1:num_CT)){
name = dimnames(standard_sig)[[3]][j]
NUM_CT[,name] = NUM_CT[,name] + sum((standard_sig[,,j]) * query_sig[,,j],na.rm = T)
DEN_CT[,name] = DEN_CT[,name] + sum(standard_sig[,,j],na.rm = T)
}
recall_CT[k,] = NUM_CT/DEN_CT
D_CT[k,] = DEN_CT
N_CT[k,] = NUM_CT
NUM = NUM + sum(standard_sig * query_sig,na.rm = T)
DEN = DEN + sum(standard_sig,na.rm = T)
recall[k] = NUM/DEN
C[k] = log(cutoff,10)
if(is.infinite(C[k])){
C[k] = -15
}
}
}
# Load the ggplot2 library
library(ggplot2)
# Example data
data <- data.frame(
C = C,                # Replace with your actual 'C' values
recall = recall # Replace with your actual 'recall' values
)
# Create the plot
PLOT = ggplot(data, aes(x = C, y = recall)) +
geom_point() +  # Scatter points
geom_line() +   # Optional: Connect points with lines
scale_y_continuous(
limits = c(0, 1),            # Set y-axis limits
breaks = seq(0, 1, by = 0.1) # Add y-axis ticks
) +
theme_minimal() +  # Use a clean theme
labs(
x = "#Top Effects",          # Label for the x-axis
y = "Recall",     # Label for the y-axis
title = paste0("Recall vs #Top Effects: ",mode)
) +
theme(
panel.grid.major = element_line(color = "grey80"), # Add a grid
panel.grid.minor = element_blank()                 # Optional: Hide minor grids
)
print(PLOT)
#setwd("/Users/kmason/Desktop/Folders/research_projects/spatial/spatial_data/spotglm_data/visium_HD/deconvolution_output/analysis/results")
#results = list(C = C, recall = recall, NUM_CT = NUM_CT,DEN_CT = DEN_CT)
#saveRDS(results,paste0("results_",mode,".rds"))
}
rm(list = ls())
gc()
library(sparrow)
library(spotglm)
library(parallel)
library(doParallel)
setwd("/Users/kmason/Desktop/Folders/research_projects/spatial/spatial_data/spotglm_data/visium_HD/deconvolution_output/analysis/materials")
analysis_skeleton = readRDS("analysis_skeleton.rds")
deconv_weighted = analysis_skeleton$deconv_weighted
counts = analysis_skeleton$counts
EN = analysis_skeleton$effective_niche
spot_size = analysis_skeleton$spot_size
best_genes = analysis_skeleton$best_genes
check = spotglm::run_model(y = counts[,"IFI30"],X = EN, lambda = deconv_weighted,
family = "spot negative binomial",
offset = log(spot_size),learning_rate = 10,min_reads_per_1000 = 0.01)
check$beta_est
check = spotglm::run_model(y = counts[,"MMP12"],X = EN, lambda = deconv_weighted,
family = "spot negative binomial",
offset = log(spot_size),learning_rate = 10,min_reads_per_1000 = 0.01)
check$fixed_coef
check$beta_est
setwd("/Users/kmason/Desktop/Folders/research_projects/spatial/spotglm")
devtools::document()
check = spotglm::run_model(y = counts[,"MMP12"],X = EN, lambda = deconv_weighted,
family = "spot negative binomial",
offset = log(spot_size),learning_rate = 10,min_reads_per_1000 = 0.01)
check$time
check$beta_est
check$stand_err_mat
