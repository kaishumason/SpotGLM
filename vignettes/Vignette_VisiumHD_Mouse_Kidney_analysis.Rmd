---
title: "Visium HD Workflow - Kidney"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Visium_analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

We must load the following packages
```
library(spotglm)
library(ggplot2)
library(patchwork)
library(dplyr)
library(arrow)
library(Seurat)
library(spacexr) 
library(tidyverse)
```
# Overview
This vignette demonstrates a full analysis workflow using SpotGLM for cell type-specific differential expression analysis on a Visium HD data set.  We will also demonstrate how [https://kaishumason.github.io/SPARROW/](SPARROW) can be used for power-preserving data selection, to speed up the analysis.  

We will use the publicly available Visium HD mouse kidney dataset, which can be downloaded form 10X Genomics:
(https://www.10xgenomics.com/datasets/visium-hd-cytassist-gene-expression-libraries-of-mouse-kidney). 


We need to first perform deconvolution on each spot to get the cell type proportions. For spatial niches, we will use spatial domains detected through histological image analysis of the same-slide H&E image, as described in the paper.  We have included the scripts for these processing steps here. Since this preprocessing is time consuming, we have also included the processed data files for you to load, to start the spotGLM analysis.  

# Preprocess Data (Optional)

1. We will use RCTD (Cable, D.M., et al.) as an example for celltype deconvolution, but users can use any other deconvolution method to get the celltype proportion matrix. Deconvolution starts from the raw data matrix and takes a couple of hours. This step can be skipped, but users can use the script below to get the deconvolution results. 

```
localdir <- "mouse_kidney_data_input/data/binned_outputs/square_008um"
output_dir <- "mouse_kidney_data_input/preprocessed_data/"
dir.create(output_dir, showWarnings = F)

reference <- readRDS( "mouse_kidney_data_input/RCTD_reference_data/Mouse_kidney_RCTD_reference.rds")
counts<-Read10X_h5(file.path(localdir, "filtered_feature_bc_matrix.h5"))
coords<-read_parquet(file.path(localdir, "spatial/tissue_positions.parquet"), as_data_frame = TRUE)
coords <- as.data.frame(coords)
rownames(coords)<-coords$barcode
coords <- coords[coords$barcode %in% colnames(counts),]
coords<-coords[,3:4]
nUMI <- colSums(counts)

puck <- SpatialRNA(coords, counts, nUMI)
barcodes <- colnames(puck@counts)

myRCTD <- create.RCTD(puck, reference, max_cores = 12)
myRCTD <- run.RCTD(myRCTD, doublet_mode = 'doublet')
saveRDS(myRCTD,file=file.path(output_dir,"Deconvolution_HD.rds"))

######## Prepare spotGLM input data ########

deconv_df <- data.frame()
cell_types = unique(reference@cell_types)
cell_types = droplevels(cell_types)
types = unique(cell_types)
coord <-  myRCTD@spatialRNA@coords
deconv_est = matrix(0,nrow(coord),length(types))
colnames(deconv_est) = types
rownames(deconv_est) = rownames(myRCTD@spatialRNA@coords)

for(j in c(1:nrow(myRCTD@results$results_df))){
  fills = match(unlist(myRCTD@results$results_df[j,c("first_type", "second_type")]), types)
  deconv_est[j,fills] = myRCTD@results$weights_doublet[j,]
}

deconv_est <- as.data.frame(deconv_est)
deconv_df <- rbind(deconv_df, deconv_est)
saveRDS(deconv_df , file.path(output_dir, "deconv_matrix.rds"))

######## Write coordinates output ########
coords_all<-read_parquet(file.path(localdir, "spatial/tissue_positions.parquet"),as_data_frame = TRUE)
coords_all <- as.data.frame(coords_all)
rownames(coords_all)<-coords_all$barcode
coord_df <- coords_all[coords_all$barcode %in% rownames(deconv_df),]
coord_df <- coord_df[rownames(deconv_df),]
coord_df <- coord_df %>% select(-barcode)
head(coord_df)
saveRDS(coord_df , file.path(output_dir, "coords.rds"))

### Write count matrix ####
data <- Load10X_Spatial(data.dir = localdir)
count <- data@assays$Spatial$counts
count <- count[, rownames(deconv_df)]
saveRDS(count, file.path(output_dir, "count_matrix.rds"))

```

2. Spatial niches are defined using kidney anatomical regions. We identified spatial domains and manually annotated kidney anatomical regions from histological image features using iSTAR (Zhang, D. et al.). This file is directly provided for spotGLM analysis. Each spot is assigned with a dummy variable of kidney anatomical region.


# Load Data

We first load the data and prepare for spotGLM.

<details>
  <summary>Input</summary>
  
+ `deconv`: The deconvolution of each spot. Of dimension number of spots by cell types
+ `EN`: The spatial niche vector (in this case, mouse kidney regions) for each spot. Of dimension number of spots by kidney regions
+ `coords`: Coordinate matrix. Of dimension number of spots by 2
+ `counts`: The counts matrix for spot-by-gene matrix
</details>

```
data_dir <- "mouse_kidney_data_input/preprocessed_data/"
localdir <- "mouse_kidney_data_input/data/binned_outputs/square_008um"
deconv = readRDS(file.path(data_dir,"deconv_matrix.rds"))
EN = readRDS(file.path(data_dir,"EN_covariate_matrix.rds"))
coords = readRDS(file.path(data_dir, "coords.rds"))[,2:5]
counts = t(readRDS(file.path(data_dir,"count_matrix.rds")))

coords = coord_df[rownames(EN), ]
counts = counts[rownames(EN), ]
deconv = deconv[rownames(EN), ]
```

# Preprocess data
The spotGLM model runs at gene-specific manner. For the purpose of this tutorial, we show spotGLM on a selected list of genes. To run spotGLM efficiently, we recommend filter lowly expressed genes and perform SPARROW and spotGLM on genes only with enough expression.

```
selected_genelist <- readRDS( "test_data/genelist.rds")

# Remove rare cell types
deconv[deconv < 0.1] = 0
deconv = t(apply(deconv,1,function(x){x/sum(x)}))

# Get spot library sizes
spot_size = rowSums(counts)

# Get niche-DE covariates
CT_weights = rep(1,ncol(deconv))
deconv_weighted = t(apply(deconv,1,function(x){x*CT_weights}))
deconv_weighted = t(apply(deconv,1,function(x){x/sum(x)}))
original_CT = colnames(deconv)

data = list()
data$niche <- EN
data$deconv <- deconv_weighted
data$counts <- counts
```

# Perform SPARROW for submodular data selection
SPARROW (Submodular Power Adaptive data Reduction for Representative dOWnstream analysis) is a method that selects a subsample of size $K$ from a large scale dataset. The subsample is chosen such that it maximizes the power of a downstream analysis (e.g. regression) by minimizing the trace of $(X^TX)^{-1}$ which corresponds to the sum of the square of the standard errors of a standard linear regression. 

In this analysis, we use sparrow to select 10,000 spots with 18 cell types and 7 spatial niches. Each spot contains at most 2 cell types. 

```
cutoff = -6.5
data$library_size <- rowSums(counts)

expanded_X = sparrow::expand_covariate_matrix(X = data$niche, lambda = data$deconv,
                                              family = "negative binomial",lib_size = rowSums(counts),
                                              min_reads_per_1000 = 1000*exp(cutoff))

# Remove covariates with too many zero entries
freq <- apply(expanded_X, 2, function(x) sum(x > 0) )
bad_cov <- which(freq < 30)
expanded_X <- expanded_X[, -bad_cov]

target_standard_errors = sparrow::compute_target_standard_error(X = expanded_X,
                                                                min_effect = 0.05,target_power_approx = 0.99)

selected_indices = sparrow::data_selection(X = t(expanded_X),
                                           max_data_size = 10000,
                                           min_standard_error = target_standard_errors,
                                           log = TRUE,period = 5000)
selected_indices = selected_indices[is.na(selected_indices) == F]
print(paste0("#Cells Subsampled: ", length(selected_indices)))

deconv_weighted = deconv_weighted[selected_indices,]
counts = counts[selected_indices,]
coords = coords[selected_indices,]
spot_size = spot_size[selected_indices]
EN = EN[selected_indices,]

```

# Perform SpotGLM 
We now fit our spotGLM model. Let $X$ be the the covariate matrix where the $i$th row of X, $X_i$ corresponds to the $T$ dimensional effective niche vector described above. For a spot $s$, its gene expression is modeled as the sum of the cells that make up the sot and thus can be modeled as 

$$Y_{s,g} \sim Pois(\mathbb{E}[Y_{s,g}|X_{s}])$$
$$\mathbb{E}[Y_{s,g}|X_{i}] = \log(L_s) + \sum_{t} \pi_{s,t}\exp(X_s\beta^{t}_g) $$
Here $L_s$ is the library size of spot $s$ and $\pi_{s,t}$ is the deconvolution estimate for cell type $t$ in spot $s$. This model can be fit using a spotGLM. To do this, we use the `run_model()` function. In this tutorial, we test the model for ~230 genes and 10,000 spots. This process takes ~9 minutes.

```
X <- EN
lambda <- deconv_weighted
offset = log(spot_size)

num_genes = ncol(data$counts)
res = vector("list",num_genes)

t1 = Sys.time()

for(j in c(1:num_genes)){
  if(j%%500 == 0){
    print(j)
    print(Sys.time() - t1)
  }
  res[[j]] = spotglm::run_model(y = counts[,j], X = X, lambda = lambda,
                             family = "spot negative binomial", offset = offset,
                             batch_size = 250, learning_rate = 0.1)
}
names(res) = colnames(data$counts)

t2 = Sys.time()

```

# Downstream Analysis: Determining Niche Differential Marker Genes
We perform a contrast test to see if a gene is niche-marker gene. A niche marker gene for a cell type $t$ is one in which 
$$\beta^{t}_{n_1,g} \neq \beta^{t}_{n_2,g}$$
that is that we can differentiate whether cell type $t$ is near a niche enriched by niche1 $n_1$ or niche $n_2$ by looking at its gene expression for gene $g$. We can do this using the `compute_contrast_significance()` function. Here we are finding niche marker genes in Endothelial cells when near Papilla region vs Cortex region. We set side = 1 and direction = "pos" so that the genes correspond to those that are upregulated in Endothelial cells in Papilla region versus Cortex region.

```
contrast_test_1 <- c("Endothelial cells", ".data_Papilla" , ".data_Cortex")
index <- contrast_test_1[1]
niche1 <- contrast_test_1[2]
niche2 <- contrast_test_1[3]

print(paste0("Index celltype is ", index, ", niche 1: ", niche1, "; niche 2: ", niche2))
sig_genes = compute_contrast_significance(input_list = res,
                                          cell_type = index,
                                          effect_names = c(niche1, niche2),
                                          beta_name = "beta_estimate",covariance_name = "vcov",
                                          sided = 1,direction = "pos")
sig_genes = sig_genes%>%dplyr::filter(!is.na(pval))

```

# Data Visualization

We could visualize the set of genes upregulated in cell type $t$ (e.g. Endothelial cells) in region 1 $n_1$ versus region 2 $n_2$, (e.g. Papilla region versus Cortex region) through QQ plot.

```
library(ggplot2)
library(ggrepel)

sig_genes_df <- sig_genes[order(sig_genes$test_statistic, decreasing = TRUE), ]
sig_genes_df$gene <- rownames(sig_genes_df)

qq <- qqnorm(sig_genes_df$test_statistic, plot.it = FALSE)
sig_genes_df$theoretical <- qq$x  # theoretical quantiles
sig_genes_df$sample <- qq$y       # sample quantiles
mean(qq$x, na.rm=TRUE)
var(qq$x, na.rm=TRUE)
# Compute the slope and intercept for the QQ line
q1_sample <- quantile(sig_genes_df$test_statistic, 0.25, na.rm=TRUE)
q3_sample <- quantile(sig_genes_df$test_statistic, 0.75, na.rm=TRUE)
q1_theor  <- qnorm(0.25)
q3_theor  <- qnorm(0.75)
slope     <- (q3_sample - q1_sample) / (q3_theor - q1_theor)
intercept <- q1_sample - slope * q1_theor

# Select the top genes by highest t_test_stat
top_n <- 35
top_df <- sig_genes_df[order(sig_genes_df$test_statistic, decreasing = TRUE)[1:top_n], ]
# Create the QQ plot using ggplot2 with ggrepel for labeled boxes
p <- ggplot(sig_genes_df, aes(x = theoretical, y = sample)) +
  geom_point() +
  geom_abline(intercept = intercept, slope = slope, color = "red", size = 1) +
  geom_label_repel(data = top_df, aes(label = gene),
                   box.padding = 0.35, point.padding = 0.5, # size = 10, 
                   segment.color = "grey50", max.overlaps = 50) +
  labs(x = "Theoretical Quantiles", 
       y = "Sample Quantiles", 
       title = paste0(index, ": ", str_replace(niche1, ".data_", ""), " vs.", str_replace(niche2, ".data_", ""))) +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", hjust = 0.5))
print(p)

```



