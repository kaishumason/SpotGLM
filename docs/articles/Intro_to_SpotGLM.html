<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Intro to SpotGLM • spotglm</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Intro to SpotGLM">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">


    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">spotglm</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">0.1.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles

    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/Intro_to_SpotGLM.html">Intro to SpotGLM</a>
    </li>
    <li>
      <a href="../articles/Spatial_ATAC_analysis.html">Spatial ATAC Analysis</a>
    </li>
    <li>
      <a href="../articles/Spatial_Long_Read_analysis.html">Spatial Long-Read Analysis</a>
    </li>
    <li>
      <a href="../articles/Visium_analysis.html">Visium Analysis</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->



      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Intro to SpotGLM</h1>
            
      

      <div class="hidden name"><code>Intro_to_SpotGLM.Rmd</code></div>

    </div>

    
    
<p>We first load all required packages</p>
<pre><code><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va">spotglm</span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va">sparrow</span><span class="op">)</span></span></code></pre>
<div class="section level2">
<h2 id="step-1-simulating-data">Step 1: Simulating Data<a class="anchor" aria-label="anchor" href="#step-1-simulating-data"></a>
</h2>
<p>We use the simulate data function in sparrow to simulate 100,000
spots with 8 cell types. Each spot contains at most 2 cell types. We
simulate data according to the model
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mi>i</mi></msub><mo>∼</mo><mi>P</mi><mi>o</mi><mi>i</mi><mi>s</mi><mrow><mo stretchy="true" form="prefix">(</mo><munderover><mo>∑</mo><mrow><mi>t</mi><mo>=</mo><mn>1</mn></mrow><mi>T</mi></munderover><msub><mi>λ</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><msup><mi>β</mi><mi>t</mi></msup><mo>+</mo><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1000</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">Y_i \sim Pois(\sum_{t=1}^{T}\lambda_{i,t}\exp(X_i\beta^t + \log(1000)))</annotation></semantics></math>
Here
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>i</mi></msub><annotation encoding="application/x-tex">Y_i</annotation></semantics></math>
is the response (e.g. gene expression) for spot
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>i</mi></msub><annotation encoding="application/x-tex">X_i</annotation></semantics></math>
is the covariate vector for spot
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>,<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
denotes a cell type,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">\lambda_{i,t}</annotation></semantics></math>
is the deconvolution estimate for cell type
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
in spot
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>β</mi><mi>t</mi></msup><annotation encoding="application/x-tex">\beta^t</annotation></semantics></math>
is the effect vector for cell type
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>.
Note that each cell type gets a different effect vector. Also note that
the columns of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
are bounded between 0 and 1. Bounding all columns between some interval
is recommended to prevent scaling issues and to make interpretation
easier.</p>
<pre><code><span><span class="va">data</span> <span class="op">=</span> <span class="fu">sparrow</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/sparrow/man/simulate_data.html" class="external-link">simulate_data</a></span><span class="op">(</span>n <span class="op">=</span> <span class="fl">1e5</span>, nct <span class="op">=</span> <span class="fl">8</span>,effect_scale <span class="op">=</span> <span class="fl">1</span><span class="op">/</span><span class="fl">5</span>,</span>
<span>                              intercept_scale <span class="op">=</span> <span class="fl">4</span>,</span>
<span>                              library_size <span class="op">=</span> <span class="fl">1000</span>, spot_ct <span class="op">=</span> <span class="fl">2</span>,</span>
<span>                              p <span class="op">=</span> <span class="fl">8</span>,num_null <span class="op">=</span> <span class="fl">2</span>,prob_ct <span class="op">=</span> <span class="cn">NULL</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">X</span><span class="op">)</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span><span class="st">"effect_"</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">X</span><span class="op">)</span><span class="op">)</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">X</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">=</span> <span class="st">"intercept"</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">lambda</span><span class="op">)</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span><span class="st">"cell_type_"</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">lambda</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span></span></code></pre>
</div>
<div class="section level2">
<h2 id="step-2-formulating-a-spotglm">Step 2: Formulating a SpotGLM<a class="anchor" aria-label="anchor" href="#step-2-formulating-a-spotglm"></a>
</h2>
<p>SpotGLM is a method for fitting model of the form</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mi>s</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>X</mi><mi>s</mi></msub><mo>∼</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">Y_s|X_s \sim G</annotation></semantics></math><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>Y</mi><mi>s</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>X</mi><mi>s</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><munder><mo>∑</mo><mi>t</mi></munder><msub><mi>λ</mi><mrow><mi>s</mi><mo>,</mo><mi>t</mi></mrow></msub><msup><mi>F</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>s</mi></msub><msup><mi>β</mi><mi>t</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbb{E}[Y_{s}|X_{s}] = \sum_{t}\lambda_{s,t}F^{-1}(X_{s}\beta^t)</annotation></semantics></math>
Here
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
index a cell type and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mrow><mi>s</mi><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">\lambda_{s,t}</annotation></semantics></math>
is the weighting for cell type
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
in spot
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>β</mi><mi>t</mi></msup><annotation encoding="application/x-tex">\beta^t</annotation></semantics></math>
is the weight vector for cell type
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>s</mi></msub><annotation encoding="application/x-tex">X_s</annotation></semantics></math>
is the covariate vector for spot
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>.
In general,to specify a spotGLM one needs to first specify single cell
level models, that is models that would be used if the data were of
single cell resolution. Then they relate the response of a spot
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>
to that of the cell types that belong to the spot.<br>
For example, consider a single cell level generalized linear model where
for a cell
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>Y</mi><mi>i</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>X</mi><mi>i</mi></msub><msup><mi>β</mi><mrow><mi>C</mi><mi>T</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msup></mrow><annotation encoding="application/x-tex">F(\mathbb{E}[Y_{i}|X_{i}]) = X_i\beta^{CT(i)}</annotation></semantics></math>
Here
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>T</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">CT(i)</annotation></semantics></math>
is the cell type identity of cell
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>.
Common formulations of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>
include
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">F(x) = x</annotation></semantics></math>
(ordinary least squares),
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">F(x) = \log(x)</annotation></semantics></math>
(poisson or negative binomial regression), or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mtext mathvariant="normal">logit</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">F(x) = \text{logit}(x)</annotation></semantics></math>
(logistic regression). For now let us assume that we are using a poisson
or negative binomial model as is common in spatial transcriptomic data.
In this case we have</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>Y</mi><mi>i</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>X</mi><mi>i</mi></msub><msup><mi>β</mi><mrow><mi>C</mi><mi>T</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msup></mrow><annotation encoding="application/x-tex">\log(\mathbb{E}[Y_{i}|X_{i}]) = \log(L_i) + X_i\beta^{CT(i)}</annotation></semantics></math>
Where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mi>i</mi></msub><annotation encoding="application/x-tex">L_i</annotation></semantics></math>
is the library size of cell
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>.</p>
<p><br>
Now we need to relate a spot’s response to the responses of the cells
that lay in the spot. Accounting for the library size of spot
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mi>s</mi></msub><annotation encoding="application/x-tex">L_s</annotation></semantics></math>,
we can model the response of spot
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>
to be the weighted average of the cells that belong to the spot. Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mi>t</mi></msub><annotation encoding="application/x-tex">L_t</annotation></semantics></math>
be the expected library size of a cell of type
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>.
Then<br><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mi>s</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>X</mi><mi>s</mi></msub><mo>∼</mo><mi>P</mi><mi>o</mi><mi>i</mi><mi>s</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>Y</mi><mi>i</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>X</mi><mi>s</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">Y_{s}|X_{s} \sim Pois(\mathbb{E}[Y_{i}|X_{s}])</annotation></semantics></math><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>Y</mi><mi>s</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>X</mi><mi>s</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><munder><mo>∑</mo><mrow><mi>i</mi><mo>:</mo><mi>i</mi><mo>∈</mo><mi>s</mi></mrow></munder><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>Y</mi><mi>i</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>X</mi><mi>s</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><munder><mo>∑</mo><mi>t</mi></munder><msub><mi>n</mi><mrow><mi>s</mi><mo>,</mo><mi>t</mi></mrow></msub><msub><mi>L</mi><mi>t</mi></msub><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>s</mi></msub><msup><mi>β</mi><mi>t</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>≈</mo><msub><mi>L</mi><mi>s</mi></msub><munder><mo>∑</mo><mi>t</mi></munder><msub><mi>π</mi><mrow><mi>s</mi><mo>,</mo><mi>t</mi></mrow></msub><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>s</mi></msub><msup><mi>β</mi><mi>t</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munder><mo>∑</mo><mi>t</mi></munder><msub><mi>π</mi><mrow><mi>s</mi><mo>,</mo><mi>t</mi></mrow></msub><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>s</mi></msub><msup><mi>β</mi><mi>t</mi></msup><mo>+</mo><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>L</mi><mi>s</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbb{E}[Y_{s}|X_{s}] = \sum_{i:i\in s}\mathbb{E}[Y_{i}|X_{s}] = \sum_{t}n_{s,t}L_t\exp(X_s\beta^{t}) \approx L_s\sum_{t}\pi_{s,t}\exp(X_s\beta^t) = \sum_{t}\pi_{s,t}\exp(X_s\beta^t + \log(L_s))</annotation></semantics></math></p>
<p>here
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mi>s</mi></msub><annotation encoding="application/x-tex">L_s</annotation></semantics></math>
is the library size for spot
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>π</mi><mrow><mi>s</mi><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">\pi_{s,t}</annotation></semantics></math>
can be thought of as the deconvolution amount of cell type
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
in spot
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>.
This form matches the spotGLM form and thus we can use the spotGLM
package to fit this model.<br></p>
</div>
<div class="section level2">
<h2 id="fitting-spotglm">Fitting SpotGLM<a class="anchor" aria-label="anchor" href="#fitting-spotglm"></a>
</h2>
We fit a spotGLM using the <code><a href="../reference/run_model.html">run_model()</a></code> function. This
function takes several arguments, although most are pre-specified. The
main arguments are as follows
<details><summary>
Arguments
</summary><ul>
<li>
<code>y</code>: A vector of observed response values (e.g., gene
expression or spatial counts).<br>
</li>
<li>
<code>X</code>: A design matrix of covariates or predictors.<br>
</li>
<li>
<code>family</code>: A description of the error distribution and
link function to be used in the model (e.g., <code>"spot poisson"</code>
or <code>"spot binomial"</code>).</li>
<li>
<code>offset</code>: For poisson/negative binomial models: An
optional numeric vector to be used as an offset in the model (useful for
normalization or exposure adjustment).Generally this is set to be the
log of the library size for each spot.</li>
<li>
<code>initialization</code> : What type of initialization to use.
“intercept” only fits the intercept for each cell type, setting other
parameters equal to 0 to start. Full, fits one value for all parameters
for each cell type. If neither are preferable, provide a custom
initialization in the <code>beta_0</code> argument and set
<code>initialization</code> to “none</li>
<li>
<code>intercept_col</code> = 1: If <code>initialization</code> =
“intercept”, which column in <code>X</code> corresponds to the
intercept. -<code>min_reads_per_1000</code>: During initialization, if
family is “spot poisson” or “spot negative binomial” and expected reads
per 1000 for a cell type is less than this value, parameters will not be
fit for this cell types.</li>
<li>
<code>learning_rate</code>: The learning rate used for gradient
descent. It is advised to pick a large value since the learning rate
changes dynamically throughout fitting. Default value is 1.</li>
<li>
<code>n_epochs</code>: The number of epochs to use in fitting.
Default value 50. -<code>batch_size</code>: Batch size to use in
mini-batch gradient descent. Default value 128 -<code>max_diff</code>:
Stopping criterion: If change in likelihood between epochs is less than
max diff, terminate fitting. Default value 1-1e-6</li>
</ul></details><p>The <code><a href="../reference/run_model.html">run_model()</a></code> function returns a list with the
following elements:</p>
<details><summary>
Output
</summary><ul>
<li>
<code>beta_est</code>: Estimated regression coefficients. Of
dimension #Columns of X by #Cell Types</li>
<li>
<code>stand_err_mat</code>: Standard error matrix for beta
coefficients</li>
<li>
<code>time</code>: Time elapsed to fit model. Not including
initialization</li>
<li>
<code>disp</code>: The dispersion parameter (for negative binomial
or gaussian models)</li>
<li>
<code>converged</code>: Logical flag indicating whether the
optimization algorithm converged</li>
<li>
<code>likelihood</code>: The log-likelihood of the fitted model</li>
<li>
<code>vcov</code>: The variance covariance matrix of the beta
coefficients</li>
<li>
<code>niter</code>: Number of epochs used</li>
<li>
<code>fixed coef</code>: Which coefficients has insufficient sample
size or expression to be fit</li>
</ul></details><p>In the case where a spot binomial model is ran, an additional weight
argument must be specified. The weight argument in a standard logistic
regression corresponds to the number of trials for each response
variable. The same interpretation is used for the spot binomial model.
Additionally, if one knows wants to set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mrow><mi>s</mi><mo>,</mo></mrow></msub><mo>=</mo><msub><mi>C</mi><mrow><mi>s</mi><mo>,</mo></mrow></msub><mo>*</mo><msub><mi>W</mi><mrow><mi>T</mi><mo>×</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\lambda_{s,} = C_{s,}*W_{T \times 1}</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
is a vector of length equal to the number of cell types
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>,
then one can set the <code>lambda</code> argument equal to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
and set the <code>ct_cov_weights</code> argument equal to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>.
In this case, spotGLM will normalize each row of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
to sum to 1. This can be useful for fitting many models serially, where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mrow><mi>s</mi><mo>,</mo></mrow></msub><mo>=</mo><msub><mi>C</mi><mrow><mi>s</mi><mo>,</mo></mrow></msub><mo>*</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">\lambda_{s,} = C_{s,}*W</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mrow><mi>s</mi><mo>,</mo></mrow></msub><annotation encoding="application/x-tex">C_{s,}</annotation></semantics></math>
does not change on each iteration (e.g. deconvolution estimates) but
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
does (e.g. the weighting depends on the relative gene expression across
cell types).<br></p>
<p>If a linear spotGLM, known as a “spot gaussian” model is fit, one can
simply use the <code>spot_lm</code> function. The <code>spot_lm</code>
function is a direct analog of the standard lm function in R and take
the following arguments.</p>
<details><summary>
Arguments
</summary><ul>
<li>
<code>y</code>: A vector of observed response values (e.g., gene
expression or spatial counts).<br>
</li>
<li>
<code>X</code>: A design matrix of covariates or predictors.<br>
</li>
<li>
<code>lambda</code>: The deconvolution matrix.</li>
<li>
<code>fix_coef</code>: A matrix of dimension</li>
</ul></details>
The <code>spot_lm</code> function returns a list with the following
elements:
<details><summary>
Output
</summary><ul>
<li>
<code>beta</code>: Estimated regression coefficients. Of dimension
#Columns of X by #Cell Types</li>
<li>
<code>stand_err_mat</code>: Standard error matrix.</li>
<li>
<code>sigma.sq</code>: Residual variance estimate.</li>
<li>
<code>vcov</code>: The Variance-covariance matrix of the beta
coefficients</li>
</ul></details><pre><code><span><span class="va">model</span> <span class="op">=</span> <span class="fu">spotglm</span><span class="fu">::</span><span class="fu"><a href="../reference/run_model.html">run_model</a></span><span class="op">(</span>y <span class="op">=</span> <span class="va">data</span><span class="op">$</span><span class="va">y</span>,X <span class="op">=</span> <span class="va">data</span><span class="op">$</span><span class="va">X</span>,lambda <span class="op">=</span> <span class="va">data</span><span class="op">$</span><span class="va">lambda</span>,</span>
<span>                           family <span class="op">=</span> <span class="st">"spot poisson"</span>,offset<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">1000</span><span class="op">)</span>,</span>
<span>                          <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">y</span><span class="op">)</span><span class="op">)</span>,n_epochs <span class="op">=</span> <span class="fl">100</span>,batch_size<span class="op">=</span> <span class="fl">500</span>,</span>
<span>                          learning_rate <span class="op">=</span> <span class="fl">1</span>,max_diff <span class="op">=</span> <span class="fl">1</span><span class="op">-</span><span class="fl">1e-6</span>,</span>
<span>                          initialization <span class="op">=</span> <span class="st">"intercept"</span>,intercept_col <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span></span></code></pre>
<p>Finally, we recommend scaling features to be in the range [0,1] or
[-1,1] if possible.</p>
</div>
<div class="section level2">
<h2 id="downstream-analyses">Downstream Analyses<a class="anchor" aria-label="anchor" href="#downstream-analyses"></a>
</h2>
<div class="section level3">
<h3 id="plotting-results">Plotting Results<a class="anchor" aria-label="anchor" href="#plotting-results"></a>
</h3>
<pre><code><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">beta</span><span class="op">[</span><span class="op">-</span><span class="fl">1</span>,<span class="op">]</span>,<span class="va">model</span><span class="op">$</span><span class="va">beta_est</span><span class="op">[</span><span class="op">-</span><span class="fl">1</span>,<span class="op">]</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>a<span class="op">=</span><span class="fl">0</span>,b<span class="op">=</span><span class="fl">1</span>,col <span class="op">=</span> <span class="st">"red"</span><span class="op">)</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="interpretting-outputs">Interpretting Outputs<a class="anchor" aria-label="anchor" href="#interpretting-outputs"></a>
</h3>
<p>The beta estimates can be found via <code>beta_est</code> index. We
see that the column names correspond to cell types and the row names
correspond to the effect names. To find the estimated effect vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>β</mi><mi>t</mi></msup><annotation encoding="application/x-tex">\beta^t</annotation></semantics></math>,
one simply needs to look at the relevant column of the matrix.</p>
<pre><code><span><span class="va">model</span><span class="op">$</span><span class="va">beta_est</span></span></code></pre>
<p>The standard error matrix gives the corresponding standard errors of
each estimated coefficient and can be found in the
<code>stand_err_mat</code> index. it has the same structure as the
coefficient matrix.</p>
<pre><code><span><span class="va">model</span><span class="op">$</span><span class="va">stand_err_mat</span></span></code></pre>
<p>The <code>vcov</code> index gives us the variance covariance matrix
of the beta coefficients. It is of dimension
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>T</mi><mo>×</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>×</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>T</mi><mo>×</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(T\times p)\times(T \times p)</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
is the number of cell types and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>
is the number of features. The columns correspond to the coefficients
traversing column wise throughout the coefficient matrix. Therefore, the
first 9 columns of the variance-covariance matrix correspond to the the
first column of the coefficient matrix.</p>
<pre><code><span><span class="va">model</span><span class="op">$</span><span class="va">vcov</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">9</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">9</span><span class="op">]</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="assessing-significance">Assessing Significance<a class="anchor" aria-label="anchor" href="#assessing-significance"></a>
</h3>
<p>One can compute pvalues and qvalues for testing significance via the
<code>compute_significance</code> function. This function takes the
following arguments:</p>
<details><summary>
Arguments
</summary><ul>
<li>
<code>input_list</code>: A list of spotglm outputs. Each element of
the list should contain a list that holds the beta estimates and
standard errors.</li>
<li>
<code>cell_type</code>: The cell type of interest</li>
<li>
<code>effect_names</code>: The effects we wish to assess
significance for in the cell type of interest.</li>
<li>
<code>beta_name</code>: Where the beta coefficient estimate matrix
is held in the each element of the input list. Default is
<code>beta_est</code>
</li>
<li>
<code>standard_error_name</code>: Where the beta coefficient
estimate matrix is held in the each element of the input list. Default
is <code>std_error_mat</code>
</li>
<li>
<code>sided</code>: Should we test for a one sided (1) or two-sided
(2) difference in effects? Default value is 2</li>
<li>
<code>direction</code>: If one sided, should we test for positive
effects(effect &gt; 0) or negative?</li>
</ul></details><p>The output is a matrix with 7 columns; the name of the response, the
cell type,the effect, the sidedness of the test, the direction of the
test,the pvalue, and the qvalue. The qvalue is designed to be used in
scenarios where one is testing across many responses (e.g. genes) and is
interested in assessing significance for a cell type specific effect
across all responses.Because the input must be a list of lists, for this
example we use list(model) as an argument. Note that if the input list
has no names, the names are replaced with the prefix “Test”. For easy
interpretation of results it is suggested that one name the list.</p>
<pre><code><span><span class="fu">spotglm</span><span class="fu">::</span><span class="fu"><a href="../reference/compute_significance.html">compute_significance</a></span><span class="op">(</span>input_list <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">model</span><span class="op">)</span>,</span>
<span>                              cell_type <span class="op">=</span> <span class="st">"cell_type_1"</span>,</span>
<span>                              <span class="st">"effect_name"</span> <span class="op">=</span> <span class="st">"effect_1"</span>,sided <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="contrasts">Contrasts<a class="anchor" aria-label="anchor" href="#contrasts"></a>
</h3>
<p>Another downstream analysis one can use is a contrast test. This test
whether
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>β</mi><mi>j</mi><mi>t</mi></msubsup><mo>=</mo><msubsup><mi>β</mi><mi>k</mi><mi>t</mi></msubsup></mrow><annotation encoding="application/x-tex">\beta^{t}_j = \beta^{t}_k</annotation></semantics></math>
for some cell type
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
and effects
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>.
One can compute pvalues and qvalues for testing significance via the
<code>compute_contrast_significance</code> function. This function takes
the following arguments: This function takes the following arguments</p>
<details><summary>
Arguments
</summary><ul>
<li>
<code>input_list</code>: A list of spotglm outputs. Each element of
the list should contain a list that holds the beta estimates and the
variance-covariance matrix.</li>
<li>
<code>cell_type</code>: The cell type of interest</li>
<li>
<code>effect_names</code>: A vector of length two that lists the
effects we wish to compare in the cell type of interest.</li>
<li>
<code>beta_name</code>: Where the beta coefficient estimate matrix
is held in the each element of the input list</li>
<li>
<code>covariance_name</code>: Where the variance-covariance matrix
for beta coefficient estimate matrix is held in the each element of the
input list. Default is <code>vcov</code>
</li>
<li>
<code>sided</code>: Should we test for a one sided (1) or two-sided
(2) difference in effects? Default is 2.</li>
<li>
<code>direction</code>: If one sided, should we test for positive
effects(effect 1 &gt; effect 2) or negative?</li>
</ul></details><p>The output is a matrix with 8 columns; the name of the response, the
cell type,the effects, the sidedness of the test, the direction of the
test,the pvalue, and the qvalue.</p>
<pre><code><span><span class="fu">spotglm</span><span class="fu">::</span><span class="fu"><a href="../reference/compute_contrast_significance.html">compute_contrast_significance</a></span><span class="op">(</span>input_list <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">model</span><span class="op">)</span>,</span>
<span>                                       cell_type <span class="op">=</span> <span class="st">"cell_type_1"</span>,</span>
<span>                                       <span class="st">"effect_name"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"effect_1"</span>,<span class="st">"effect_2"</span><span class="op">)</span>,</span>
<span>                                       sided <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

      </div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Kaishu Mason.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

      </footer>
</div>






  </body>
</html>
