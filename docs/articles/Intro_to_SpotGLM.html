<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Intro to SpotGLM • spotGLM</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Intro to SpotGLM">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">spotGLM</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/Intro_to_SpotGLM.html">Intro to SpotGLM</a></li>
    <li><a class="dropdown-item" href="../articles/Spatial_ATAC_analysis.html">Spatial ATAC Analysis</a></li>
    <li><a class="dropdown-item" href="../articles/Spatial_Long_Read_analysis.html">Spatial Long-Read Isoform Analysis</a></li>
    <li><a class="dropdown-item" href="../articles/Vignette_VisiumHD_Mouse_Kidney_analysis.html">Visium HD Workflow - SpotGLM w/ SPARROW</a></li>
    <li><a class="dropdown-item" href="../articles/Visium_analysis.html">Visium Niche DE Analysis</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="nav-link" href="https://github.com/kaishumason/spotGLM/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Intro to SpotGLM</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/kaishumason/spotGLM/blob/HEAD/vignettes/Intro_to_SpotGLM.Rmd"><code>vignettes/Intro_to_SpotGLM.Rmd</code></a></small>
      <div class="d-none name"><code>Intro_to_SpotGLM.Rmd</code></div>
    </div>

    
    
<p>In this tutorial, we will use a simulated data set to illustrate how
SpotGLM works. We use simulations as it is more straightforward to
illustrate the probabilistic modeling framework underlying SpotGLM, and
allows us to directly compare trade-offs in terms of power and
specificity.</p>
<p><em>Let’s get started!</em></p>
<p>First, load all required packages:</p>
<pre><code><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va">spotglm</span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/kaishumason/SPARROW" class="external-link">sparrow</a></span><span class="op">)</span></span></code></pre>
<p>the package <a href="https://kaishumason.github.io/SPARROW/" class="external-link">sparrow</a> allows for
fast and scalable computation, as detailed in our paper.</p>
<div class="section level2">
<h2 id="step-1-simulate-the-data">Step 1: Simulate the data<a class="anchor" aria-label="anchor" href="#step-1-simulate-the-data"></a>
</h2>
<p>We use the simulate data function in sparrow to generate a virtual
spatial transcriptomic data with <strong>100,000 spots</strong>. We
assume that their are <strong>8 cell types</strong>, and that each spot
straddles at most 2 cell types. We simulate data according to the
model:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mi>i</mi></msub><mo>∼</mo><mi>P</mi><mi>o</mi><mi>i</mi><mi>s</mi><mrow><mo stretchy="true" form="prefix">(</mo><munderover><mo>∑</mo><mrow><mi>t</mi><mo>=</mo><mn>1</mn></mrow><mi>T</mi></munderover><msub><mi>λ</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><msup><mi>β</mi><mi>t</mi></msup><mo>+</mo><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1000</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">Y_i \sim Pois(\sum_{t=1}^{T}\lambda_{i,t}\exp(X_i\beta^t + \log(1000)))</annotation></semantics></math>
Here
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>i</mi></msub><annotation encoding="application/x-tex">Y_i</annotation></semantics></math>
is the response (e.g. gene expression) for spot
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>i</mi></msub><annotation encoding="application/x-tex">X_i</annotation></semantics></math>
is the covariate vector for spot
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>,<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
indexes across the cell types,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">\lambda_{i,t}</annotation></semantics></math>
is the deconvolution estimate for cell type
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
in spot
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>β</mi><mi>t</mi></msup><annotation encoding="application/x-tex">\beta^t</annotation></semantics></math>
is the effect vector for cell type
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>.
Note that each cell type gets a different effect vector. Also note that
the columns of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
are bounded between 0 and 1. Bounding all columns between some interval
is recommended to prevent scaling issues and to make interpretation
easier.</p>
<pre><code><span><span class="va">data</span> <span class="op">=</span> <span class="fu">sparrow</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/sparrow/man/simulate_data.html" class="external-link">simulate_data</a></span><span class="op">(</span>n <span class="op">=</span> <span class="fl">1e5</span>, nct <span class="op">=</span> <span class="fl">8</span>,family <span class="op">=</span> <span class="st">"poisson"</span>,</span>
<span>                              effect_range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span>,</span>
<span>                              min_effect <span class="op">=</span> <span class="fl">0.05</span>,</span>
<span>                              intercept_range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">6</span>,<span class="op">-</span><span class="fl">4</span><span class="op">)</span>,</span>
<span>                              library_size <span class="op">=</span> <span class="fl">1000</span>, spot_ct <span class="op">=</span> <span class="fl">2</span>,</span>
<span>                              p <span class="op">=</span> <span class="fl">8</span>,num_null <span class="op">=</span> <span class="fl">2</span>,prob_ct <span class="op">=</span> <span class="cn">NULL</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">X</span><span class="op">)</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span><span class="st">"effect_"</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">X</span><span class="op">)</span><span class="op">)</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">X</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">=</span> <span class="st">"intercept"</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">lambda</span><span class="op">)</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span><span class="st">"cell_type_"</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">lambda</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre>
</div>
<div class="section level2">
<h2 id="step-2-formulating-a-spotglm">Step 2: Formulating a SpotGLM<a class="anchor" aria-label="anchor" href="#step-2-formulating-a-spotglm"></a>
</h2>
<p>SpotGLM is a method for fitting model of the form</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mi>s</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>X</mi><mi>s</mi></msub><mo>∼</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">Y_s|X_s \sim G</annotation></semantics></math>
where</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>Y</mi><mi>s</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>X</mi><mi>s</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><munder><mo>∑</mo><mi>t</mi></munder><msub><mi>λ</mi><mrow><mi>s</mi><mo>,</mo><mi>t</mi></mrow></msub><msup><mi>F</mi><mrow><mi>−</mi><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>s</mi></msub><msup><mi>β</mi><mi>t</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbb{E}[Y_{s}|X_{s}] = \sum_{t}\lambda_{s,t}F^{-1}(X_{s}\beta^t)</annotation></semantics></math>
Here
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
index a cell type and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mrow><mi>s</mi><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">\lambda_{s,t}</annotation></semantics></math>
is the weighting for cell type
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
in spot
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>β</mi><mi>t</mi></msup><annotation encoding="application/x-tex">\beta^t</annotation></semantics></math>
is the weight vector for cell type
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>s</mi></msub><annotation encoding="application/x-tex">X_s</annotation></semantics></math>
is the covariate vector for spot
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>.
In general,to specify a spotGLM one needs to first specify single cell
level models, that is models that would be used if the data were of
single cell resolution. Then they relate the response of a spot
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>
to that of the cell types that belong to the spot.</p>
<p>For example, consider a single cell level generalized linear model
where for a cell
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>Y</mi><mi>i</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>X</mi><mi>i</mi></msub><msup><mi>β</mi><mrow><mi>C</mi><mi>T</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msup></mrow><annotation encoding="application/x-tex">F(\mathbb{E}[Y_{i}|X_{i}]) = X_i\beta^{CT(i)}</annotation></semantics></math>
Here
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>T</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">CT(i)</annotation></semantics></math>
is the cell type identity of cell
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>.
Common formulations of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>
include
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">F(x) = x</annotation></semantics></math>
(ordinary least squares),
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">F(x) = \log(x)</annotation></semantics></math>
(poisson or negative binomial regression), or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mtext mathvariant="normal">logit</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">F(x) = \text{logit}(x)</annotation></semantics></math>
(logistic regression). For now let us assume that we are using a poisson
or negative binomial model as is common in spatial transcriptomic data.
In this case we have</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>Y</mi><mi>i</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>X</mi><mi>i</mi></msub><msup><mi>β</mi><mrow><mi>C</mi><mi>T</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msup></mrow><annotation encoding="application/x-tex">\log(\mathbb{E}[Y_{i}|X_{i}]) = \log(L_i) + X_i\beta^{CT(i)}</annotation></semantics></math>
Where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mi>i</mi></msub><annotation encoding="application/x-tex">L_i</annotation></semantics></math>
is the library size of cell
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>.</p>
<p>Now we need to relate a spot’s response to the responses of the cells
that lay in the spot. Accounting for the library size of spot
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mi>s</mi></msub><annotation encoding="application/x-tex">L_s</annotation></semantics></math>,
we can model the response of spot
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>
to be the weighted average of the cells that belong to the spot. Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mi>t</mi></msub><annotation encoding="application/x-tex">L_t</annotation></semantics></math>
be the expected library size of a cell of type
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>.
Then<br><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mi>s</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>X</mi><mi>s</mi></msub><mo>∼</mo><mi>P</mi><mi>o</mi><mi>i</mi><mi>s</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>Y</mi><mi>i</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>X</mi><mi>s</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">Y_{s}|X_{s} \sim Pois(\mathbb{E}[Y_{i}|X_{s}])</annotation></semantics></math>
where</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>Y</mi><mi>s</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>X</mi><mi>s</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><munder><mo>∑</mo><mrow><mi>i</mi><mo>:</mo><mi>i</mi><mo>∈</mo><mi>s</mi></mrow></munder><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>Y</mi><mi>i</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>X</mi><mi>s</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><munder><mo>∑</mo><mi>t</mi></munder><msub><mi>n</mi><mrow><mi>s</mi><mo>,</mo><mi>t</mi></mrow></msub><msub><mi>L</mi><mi>t</mi></msub><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>s</mi></msub><msup><mi>β</mi><mi>t</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mo>≈</mo><msub><mi>L</mi><mi>s</mi></msub><munder><mo>∑</mo><mi>t</mi></munder><msub><mi>π</mi><mrow><mi>s</mi><mo>,</mo><mi>t</mi></mrow></msub><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>s</mi></msub><msup><mi>β</mi><mi>t</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><munder><mo>∑</mo><mi>t</mi></munder><msub><mi>π</mi><mrow><mi>s</mi><mo>,</mo><mi>t</mi></mrow></msub><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>s</mi></msub><msup><mi>β</mi><mi>t</mi></msup><mo>+</mo><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>L</mi><mi>s</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align} \mathbb{E}[Y_{s}|X_{s}] = \sum_{i:i\in s}\mathbb{E}[Y_{i}|X_{s}] &amp;= \sum_{t}n_{s,t}L_t\exp(X_s\beta^{t})\\ &amp;\approx L_s\sum_{t}\pi_{s,t}\exp(X_s\beta^t)\\ &amp;= \sum_{t}\pi_{s,t}\exp(X_s\beta^t + \log(L_s)).
\end{align}</annotation></semantics></math></p>
<p>Here,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mi>s</mi></msub><annotation encoding="application/x-tex">L_s</annotation></semantics></math>
is the library size for spot
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>π</mi><mrow><mi>s</mi><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">\pi_{s,t}</annotation></semantics></math>
can be thought of as the deconvolution amount of cell type
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
in spot
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>.
This form matches the spotGLM form and thus we can use the spotGLM
package to fit this model.</p>
</div>
<div class="section level2">
<h2 id="fitting-spotglm">Fitting SpotGLM<a class="anchor" aria-label="anchor" href="#fitting-spotglm"></a>
</h2>
We fit a spotGLM using the <code><a href="../reference/run_model.html">run_model()</a></code> function. This
function takes several arguments, although most are pre-specified. The
main arguments are as follows
<details><summary>
Arguments
</summary><ul>
<li>
<code>y</code>: A vector of observed response values (e.g., gene
expression or spatial counts).<br>
</li>
<li>
<code>X</code>: A design matrix of covariates or predictors.<br>
</li>
<li>
<code>family</code>: A description of the error distribution and
link function to be used in the model (e.g., <code>"spot poisson"</code>
or <code>"spot binomial"</code>).</li>
<li>
<code>offset</code>: For poisson/negative binomial models: An
optional numeric vector to be used as an offset in the model (useful for
normalization or exposure adjustment).Generally this is set to be the
log of the library size for each spot.</li>
<li>
<code>initialization</code> : Boolean if initialization via single
cell approximation should be performed. Default TRUE.</li>
<li>
<code>learning_rate</code>: The learning rate used for gradient
descent. It is advised to pick a large value since the learning rate
changes dynamically throughout fitting. Default value is 1.</li>
<li>
<code>n_epochs</code>: The number of epochs to use in fitting.
Default value 50. -<code>batch_size</code>: Batch size to use in
mini-batch gradient descent. Default value 128 -<code>max_diff</code>:
Stopping criterion: If change in likelihood between epochs is less than
max diff, terminate fitting. Default value 1-1e-6</li>
</ul></details><p>The <code><a href="../reference/run_model.html">run_model()</a></code> function returns a list with the
following elements:</p>
<details><summary>
Output
</summary><ul>
<li>
<code>beta_estimate</code>: Estimated regression coefficients. Of
dimension #Columns of X by #Cell Types</li>
<li>
<code>standard_error_matrix</code>: Standard error matrix for beta
coefficients</li>
<li>
<code>time</code>: Time elapsed to fit model. Not including
initialization</li>
<li>
<code>disp</code>: The dispersion parameter (for negative binomial
or gaussian models)</li>
<li>
<code>converged</code>: Logical flag indicating whether the
optimization algorithm converged</li>
<li>
<code>likelihood</code>: The log-likelihood of the fitted model</li>
<li>
<code>vcov</code>: The variance covariance matrix of the beta
coefficients</li>
<li>
<code>niter</code>: Number of epochs used</li>
<li>
<code>fixed coef</code>: Which coefficients has insufficient sample
size or expression to be fit</li>
</ul></details><p>In the case where a spot binomial model is ran, an additional weight
argument must be specified. The weight argument in a standard logistic
regression corresponds to the number of trials for each response
variable. The same interpretation is used for the spot binomial model.
Additionally, if one knows wants to set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mrow><mi>s</mi><mo>,</mo></mrow></msub><mo>=</mo><msub><mi>C</mi><mrow><mi>s</mi><mo>,</mo></mrow></msub><mo>*</mo><msub><mi>W</mi><mrow><mi>T</mi><mo>×</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\lambda_{s,} = C_{s,}*W_{T \times 1}</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
is a vector of length equal to the number of cell types
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>,
then one can set the <code>lambda</code> argument equal to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
and set the <code>ct_cov_weights</code> argument equal to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>.
In this case, spotGLM will normalize each row of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
to sum to 1. This can be useful for fitting many models serially, where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mrow><mi>s</mi><mo>,</mo></mrow></msub><mo>=</mo><msub><mi>C</mi><mrow><mi>s</mi><mo>,</mo></mrow></msub><mo>*</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">\lambda_{s,} = C_{s,}*W</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mrow><mi>s</mi><mo>,</mo></mrow></msub><annotation encoding="application/x-tex">C_{s,}</annotation></semantics></math>
does not change on each iteration (e.g. deconvolution estimates) but
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
does (e.g. the weighting depends on the relative gene expression across
cell types).<br></p>
<p>If a linear spotGLM, known as a “spot gaussian” model is fit, one can
simply use the <code>spot_lm</code> function. The <code>spot_lm</code>
function is a direct analog of the standard lm function in R and take
the following arguments.</p>
<details><summary>
Arguments
</summary><ul>
<li>
<code>y</code>: A vector of observed response values (e.g., gene
expression or spatial counts).<br>
</li>
<li>
<code>X</code>: A design matrix of covariates or predictors.<br>
</li>
<li>
<code>lambda</code>: The deconvolution matrix.</li>
<li>
<code>fix_coef</code>: A matrix of dimension</li>
</ul></details>
The <code>spot_lm</code> function returns a list with the following
elements:
<details><summary>
Output
</summary><ul>
<li>
<code>beta</code>: Estimated regression coefficients. Of dimension
#Columns of X by #Cell Types</li>
<li>
<code>standard_error_matrix</code>: Standard error matrix.</li>
<li>
<code>sigma.sq</code>: Residual variance estimate.</li>
<li>
<code>vcov</code>: The Variance-covariance matrix of the beta
coefficients</li>
</ul></details><pre><code><span><span class="va">model</span> <span class="op">=</span> <span class="fu">spotglm</span><span class="fu">::</span><span class="fu">run_model</span><span class="op">(</span>y <span class="op">=</span> <span class="va">data</span><span class="op">$</span><span class="va">y</span>,X <span class="op">=</span> <span class="va">data</span><span class="op">$</span><span class="va">X</span>,lambda <span class="op">=</span> <span class="va">data</span><span class="op">$</span><span class="va">lambda</span>,</span>
<span>                           family <span class="op">=</span> <span class="st">"spot poisson"</span>,offset<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">1000</span><span class="op">)</span>,</span>
<span>                          <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">y</span><span class="op">)</span><span class="op">)</span>,n_epochs <span class="op">=</span> <span class="fl">100</span>,batch_size<span class="op">=</span> <span class="fl">500</span>,</span>
<span>                          learning_rate <span class="op">=</span> <span class="fl">1</span>,max_diff <span class="op">=</span> <span class="fl">1</span><span class="op">-</span><span class="fl">1e-6</span>,</span>
<span>                          initialization <span class="op">=</span> <span class="cn">T</span><span class="op">)</span></span></code></pre>
<p>Finally, we recommend scaling features to be in the range [0,1] or
[-1,1] if possible.</p>
</div>
<div class="section level2">
<h2 id="downstream-analyses">Downstream Analyses<a class="anchor" aria-label="anchor" href="#downstream-analyses"></a>
</h2>
<div class="section level3">
<h3 id="plotting-results">Plotting Results<a class="anchor" aria-label="anchor" href="#plotting-results"></a>
</h3>
<pre><code><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">beta</span><span class="op">[</span><span class="op">-</span><span class="fl">1</span>,<span class="op">]</span>,<span class="va">model</span><span class="op">$</span><span class="va">beta_estimate</span><span class="op">[</span><span class="op">-</span><span class="fl">1</span>,<span class="op">]</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>a<span class="op">=</span><span class="fl">0</span>,b<span class="op">=</span><span class="fl">1</span>,col <span class="op">=</span> <span class="st">"red"</span><span class="op">)</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="interpreting-outputs">Interpreting Outputs<a class="anchor" aria-label="anchor" href="#interpreting-outputs"></a>
</h3>
<p>The beta estimates can be found via <code>beta_estimate</code> index.
We see that the column names correspond to cell types and the row names
correspond to the effect names. To find the estimated effect vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>β</mi><mi>t</mi></msup><annotation encoding="application/x-tex">\beta^t</annotation></semantics></math>,
one simply needs to look at the relevant column of the matrix.</p>
<pre><code><span><span class="va">model</span><span class="op">$</span><span class="va">beta_estimate</span></span></code></pre>
<p>The standard error matrix gives the corresponding standard errors of
each estimated coefficient and can be found in the
<code>standard_error_matrix</code> index. it has the same structure as
the coefficient matrix.</p>
<pre><code><span><span class="va">model</span><span class="op">$</span><span class="va">standard_error_matrix</span></span></code></pre>
<p>The <code>vcov</code> index gives us the variance covariance matrix
of the beta coefficients. It is of dimension
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>T</mi><mo>×</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>×</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>T</mi><mo>×</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(T\times p)\times(T \times p)</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
is the number of cell types and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>
is the number of features. The columns correspond to the coefficients
traversing column wise throughout the coefficient matrix. Therefore, the
first 9 columns of the variance-covariance matrix correspond to the the
first column of the coefficient matrix.</p>
<pre><code><span><span class="va">model</span><span class="op">$</span><span class="va">vcov</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">9</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">9</span><span class="op">]</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="assessing-significance">Assessing Significance<a class="anchor" aria-label="anchor" href="#assessing-significance"></a>
</h3>
<p>One can compute pvalues and qvalues for testing significance via the
<code>compute_significance</code> function. This function takes the
following arguments:</p>
<details><summary>
Arguments
</summary><ul>
<li>
<code>input_list</code>: A list of spotglm outputs. Each element of
the list should contain a list that holds the beta estimates and
standard errors.</li>
<li>
<code>cell_type</code>: The cell type of interest</li>
<li>
<code>effect_names</code>: The effects we wish to assess
significance for in the cell type of interest.</li>
<li>
<code>beta_name</code>: Where the beta coefficient estimate matrix
is held in the each element of the input list. Default is
<code>beta_estimate</code>
</li>
<li>
<code>standard_error_name</code>: Where the beta coefficient
estimate matrix is held in the each element of the input list. Default
is <code>std_error_mat</code>
</li>
<li>
<code>sided</code>: Should we test for a one sided (1) or two-sided
(2) difference in effects? Default value is 2</li>
<li>
<code>direction</code>: If one sided, should we test for positive
effects(effect &gt; 0) or negative?</li>
</ul></details><p>The output is a matrix with 8 columns; the name of the response, the
cell type,the effect, the sidedness of the test, the direction of the
test,the test statistic,the pvalue, and the qvalue. The qvalue is
designed to be used in scenarios where one is testing across many
responses (e.g. genes) and is interested in assessing significance for a
cell type specific effect across all responses.Because the input must be
a list of lists, for this example we use list(model) as an argument.
Note that if the input list has no names, the names are replaced with
the prefix “Test”. For easy interpretation of results it is suggested
that one name the list.</p>
<pre><code><span><span class="fu">spotglm</span><span class="fu">::</span><span class="fu">compute_significance</span><span class="op">(</span>input_list <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">model</span><span class="op">)</span>,</span>
<span>                              cell_type <span class="op">=</span> <span class="st">"cell_type_1"</span>,</span>
<span>                              <span class="st">"effect_name"</span> <span class="op">=</span> <span class="st">"effect_1"</span>,sided <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="contrasts">Contrasts<a class="anchor" aria-label="anchor" href="#contrasts"></a>
</h3>
<p>Another downstream analysis one can use is a contrast test. This test
whether
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>β</mi><mi>j</mi><mi>t</mi></msubsup><mo>=</mo><msubsup><mi>β</mi><mi>k</mi><mi>t</mi></msubsup></mrow><annotation encoding="application/x-tex">\beta^{t}_j = \beta^{t}_k</annotation></semantics></math>
for some cell type
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
and effects
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>.
One can compute pvalues and qvalues for testing significance via the
<code>compute_contrast_significance</code> function. This function takes
the following arguments:</p>
<details><summary>
Arguments
</summary><ul>
<li>
<code>input_list</code>: A list of spotglm outputs. Each element of
the list should contain a list that holds the beta estimates and the
variance-covariance matrix.</li>
<li>
<code>cell_type</code>: The cell type of interest</li>
<li>
<code>effect_names</code>: A vector of length two that lists the
effects we wish to compare in the cell type of interest.</li>
<li>
<code>beta_name</code>: Where the beta coefficient estimate matrix
is held in the each element of the input list</li>
<li>
<code>covariance_name</code>: Where the variance-covariance matrix
for beta coefficient estimate matrix is held in the each element of the
input list. Default is <code>vcov</code>
</li>
<li>
<code>sided</code>: Should we test for a one sided (1) or two-sided
(2) difference in effects? Default is 2.</li>
<li>
<code>direction</code>: If one sided, should we test for positive
effects(effect 1 &gt; effect 2) or negative?</li>
</ul></details><p>The output is a matrix with 9 columns; the name of the response, the
cell type,the effects, the sidedness of the test, the direction of the
test,the test statistic, the pvalue, and the qvalue.</p>
<pre><code><span><span class="fu">spotglm</span><span class="fu">::</span><span class="fu">compute_contrast_significance</span><span class="op">(</span>input_list <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">model</span><span class="op">)</span>,</span>
<span>                                       cell_type <span class="op">=</span> <span class="st">"cell_type_1"</span>,</span>
<span>                                       <span class="st">"effect_name"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"effect_1"</span>,<span class="st">"effect_2"</span><span class="op">)</span>,</span>
<span>                                       sided <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Kaishu Mason, Yijia Jiang, Nancy R. Zhang.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
