[{"path":"https://github.com/kaishumason/spotGLM/articles/Intro_to_SpotGLM.html","id":"step-1-simulate-the-data","dir":"Articles","previous_headings":"","what":"Step 1: Simulate the data","title":"Intro to SpotGLM","text":"use simulate data function sparrow generate virtual spatial transcriptomic data 100,000 spots. assume 8 cell types, spot straddles 2 cell types. simulate data according model: Yi‚àºPois(‚àët=1TŒªi,texp(XiŒ≤t+log(1000)))Y_i \\sim Pois(\\sum_{t=1}^{T}\\lambda_{,t}\\exp(X_i\\beta^t + \\log(1000))) YiY_i response (e.g.¬†gene expression) spot ii, XiX_i covariate vector spot ii,tt indexes across cell types, Œªi,t\\lambda_{,t} deconvolution estimate cell type tt spot ii, Œ≤t\\beta^t effect vector cell type tt. Note cell type gets different effect vector. Also note columns XX bounded 0 1. Bounding columns interval recommended prevent scaling issues make interpretation easier.","code":"data = sparrow::simulate_data(n = 1e5, nct = 8,family = \"poisson\",                               effect_range = c(-2,2),                               min_effect = 0.05,                               intercept_range = c(-6,-4),                               library_size = 1000, spot_ct = 2,                               p = 8,num_null = 2,prob_ct = NULL)  colnames(data$X) = paste0(\"effect_\",c(1:ncol(data$X))-1) colnames(data$X)[1] = \"intercept\"  colnames(data$lambda) = paste0(\"cell_type_\",c(1:ncol(data$lambda)))"},{"path":"https://github.com/kaishumason/spotGLM/articles/Intro_to_SpotGLM.html","id":"step-2-formulating-a-spotglm","dir":"Articles","previous_headings":"","what":"Step 2: Formulating a SpotGLM","title":"Intro to SpotGLM","text":"SpotGLM method fitting model form Ys|Xs‚àºGY_s|X_s \\sim G ùîº[Ys|Xs]=‚àëtŒªs,tF‚àí1(XsŒ≤t)\\mathbb{E}[Y_{s}|X_{s}] = \\sum_{t}\\lambda_{s,t}F^{-1}(X_{s}\\beta^t) tt index cell type Œªs,t\\lambda_{s,t} weighting cell type tt spot ss. Œ≤t\\beta^t weight vector cell type tt XsX_s covariate vector spot ss. general,specify spotGLM one needs first specify single cell level models, models used data single cell resolution. relate response spot ss cell types belong spot. example, consider single cell level generalized linear model cell iiF(ùîº[Yi|Xi])=XiŒ≤CT()F(\\mathbb{E}[Y_{}|X_{}]) = X_i\\beta^{CT()} CT()CT() cell type identity cell ii. Common formulations FF include F(x)=xF(x) = x (ordinary least squares), F(x)=log(x)F(x) = \\log(x) (poisson negative binomial regression), F(x)=logit(x)F(x) = \\text{logit}(x) (logistic regression). now let us assume using poisson negative binomial model common spatial transcriptomic data. case log(ùîº[Yi|Xi])=log(Li)+XiŒ≤CT()\\log(\\mathbb{E}[Y_{}|X_{}]) = \\log(L_i) + X_i\\beta^{CT()} LiL_i library size cell ii. Now need relate spot‚Äôs response responses cells lay spot. Accounting library size spot ss, LsL_s, can model response spot ss weighted average cells belong spot. Let LtL_t expected library size cell type tt. ThenYs|Xs‚àºPois(ùîº[Yi|Xs])Y_{s}|X_{s} \\sim Pois(\\mathbb{E}[Y_{}|X_{s}]) ùîº[Ys|Xs]=‚àë:‚ààsùîº[Yi|Xs]=‚àëtns,tLtexp(XsŒ≤t)‚âàLs‚àëtœÄs,texp(XsŒ≤t)=‚àëtœÄs,texp(XsŒ≤t+log(Ls)).\\begin{align} \\mathbb{E}[Y_{s}|X_{s}] = \\sum_{:\\s}\\mathbb{E}[Y_{}|X_{s}] &= \\sum_{t}n_{s,t}L_t\\exp(X_s\\beta^{t})\\\\ &\\approx L_s\\sum_{t}\\pi_{s,t}\\exp(X_s\\beta^t)\\\\ &= \\sum_{t}\\pi_{s,t}\\exp(X_s\\beta^t + \\log(L_s)). \\end{align} , LsL_s library size spot ss, œÄs,t\\pi_{s,t} can thought deconvolution amount cell type tt spot ss. form matches spotGLM form thus can use spotGLM package fit model.","code":""},{"path":"https://github.com/kaishumason/spotGLM/articles/Intro_to_SpotGLM.html","id":"fitting-spotglm","dir":"Articles","previous_headings":"","what":"Fitting SpotGLM","title":"Intro to SpotGLM","text":"y: vector observed response values (e.g., gene expression spatial counts). X: design matrix covariates predictors. family: description error distribution link function used model (e.g., \"spot poisson\" \"spot binomial\"). offset: poisson/negative binomial models: optional numeric vector used offset model (useful normalization exposure adjustment).Generally set log library size spot. initialization : Boolean initialization via single cell approximation performed. Default TRUE. learning_rate: learning rate used gradient descent. advised pick large value since learning rate changes dynamically throughout fitting. Default value 1. n_epochs: number epochs use fitting. Default value 50. -batch_size: Batch size use mini-batch gradient descent. Default value 128 -max_diff: Stopping criterion: change likelihood epochs less max diff, terminate fitting. Default value 1-1e-6 run_model() function returns list following elements: beta_estimate: Estimated regression coefficients. dimension #Columns X #Cell Types standard_error_matrix: Standard error matrix beta coefficients time: Time elapsed fit model. including initialization disp: dispersion parameter (negative binomial gaussian models) converged: Logical flag indicating whether optimization algorithm converged likelihood: log-likelihood fitted model vcov: variance covariance matrix beta coefficients niter: Number epochs used fixed coef: coefficients insufficient sample size expression fit case spot binomial model ran, additional weight argument must specified. weight argument standard logistic regression corresponds number trials response variable. interpretation used spot binomial model. Additionally, one knows wants set Œªs,=Cs,*WT√ó1\\lambda_{s,} = C_{s,}*W_{T \\times 1} WW vector length equal number cell types TT, one can set lambda argument equal CC set ct_cov_weights argument equal WW. case, spotGLM normalize row Œª\\lambda sum 1. can useful fitting many models serially, Œªs,=Cs,*W\\lambda_{s,} = C_{s,}*W Cs,C_{s,} change iteration (e.g.¬†deconvolution estimates) WW (e.g.¬†weighting depends relative gene expression across cell types). linear spotGLM, known ‚Äúspot gaussian‚Äù model fit, one can simply use spot_lm function. spot_lm function direct analog standard lm function R take following arguments. y: vector observed response values (e.g., gene expression spatial counts). X: design matrix covariates predictors. lambda: deconvolution matrix. fix_coef: matrix dimension beta: Estimated regression coefficients. dimension #Columns X #Cell Types standard_error_matrix: Standard error matrix. sigma.sq: Residual variance estimate. vcov: Variance-covariance matrix beta coefficients Finally, recommend scaling features range [0,1] [-1,1] possible.","code":"model = spotglm::run_model(y = data$y,X = data$X,lambda = data$lambda,                            family = \"spot poisson\",offset=rep(log(1000),                           length(data$y)),n_epochs = 100,batch_size= 500,                           learning_rate = 1,max_diff = 1-1e-6,                           initialization = T)"},{"path":[]},{"path":"https://github.com/kaishumason/spotGLM/articles/Intro_to_SpotGLM.html","id":"plotting-results","dir":"Articles","previous_headings":"Downstream Analyses","what":"Plotting Results","title":"Intro to SpotGLM","text":"","code":"plot(data$beta[-1,],model$beta_estimate[-1,]) abline(a=0,b=1,col = \"red\")"},{"path":"https://github.com/kaishumason/spotGLM/articles/Intro_to_SpotGLM.html","id":"interpreting-outputs","dir":"Articles","previous_headings":"Downstream Analyses","what":"Interpreting Outputs","title":"Intro to SpotGLM","text":"beta estimates can found via beta_estimate index. see column names correspond cell types row names correspond effect names. find estimated effect vector Œ≤t\\beta^t, one simply needs look relevant column matrix. standard error matrix gives corresponding standard errors estimated coefficient can found standard_error_matrix index. structure coefficient matrix. vcov index gives us variance covariance matrix beta coefficients. dimension (T√óp)√ó(T√óp)(T\\times p)\\times(T \\times p) TT number cell types pp number features. columns correspond coefficients traversing column wise throughout coefficient matrix. Therefore, first 9 columns variance-covariance matrix correspond first column coefficient matrix.","code":"model$beta_estimate model$standard_error_matrix model$vcov[1:9,1:9]"},{"path":"https://github.com/kaishumason/spotGLM/articles/Intro_to_SpotGLM.html","id":"assessing-significance","dir":"Articles","previous_headings":"Downstream Analyses","what":"Assessing Significance","title":"Intro to SpotGLM","text":"One can compute pvalues qvalues testing significance via compute_significance function. function takes following arguments: input_list: list spotglm outputs. element list contain list holds beta estimates standard errors. cell_type: cell type interest effect_names: effects wish assess significance cell type interest. beta_name: beta coefficient estimate matrix held element input list. Default beta_estimate standard_error_name: beta coefficient estimate matrix held element input list. Default std_error_mat sided: test one sided (1) two-sided (2) difference effects? Default value 2 direction: one sided, test positive effects(effect > 0) negative? output matrix 8 columns; name response, cell type,effect, sidedness test, direction test,test statistic,pvalue, qvalue. qvalue designed used scenarios one testing across many responses (e.g.¬†genes) interested assessing significance cell type specific effect across responses.input must list lists, example use list(model) argument. Note input list names, names replaced prefix ‚ÄúTest‚Äù. easy interpretation results suggested one name list.","code":"spotglm::compute_significance(input_list = list(model),                               cell_type = \"cell_type_1\",                               \"effect_name\" = \"effect_1\",sided = 2)"},{"path":"https://github.com/kaishumason/spotGLM/articles/Intro_to_SpotGLM.html","id":"contrasts","dir":"Articles","previous_headings":"Downstream Analyses","what":"Contrasts","title":"Intro to SpotGLM","text":"Another downstream analysis one can use contrast test. test whether Œ≤jt=Œ≤kt\\beta^{t}_j = \\beta^{t}_k cell type tt effects jj kk. One can compute pvalues qvalues testing significance via compute_contrast_significance function. function takes following arguments: input_list: list spotglm outputs. element list contain list holds beta estimates variance-covariance matrix. cell_type: cell type interest effect_names: vector length two lists effects wish compare cell type interest. beta_name: beta coefficient estimate matrix held element input list covariance_name: variance-covariance matrix beta coefficient estimate matrix held element input list. Default vcov sided: test one sided (1) two-sided (2) difference effects? Default 2. direction: one sided, test positive effects(effect 1 > effect 2) negative? output matrix 9 columns; name response, cell type,effects, sidedness test, direction test,test statistic, pvalue, qvalue.","code":"spotglm::compute_contrast_significance(input_list = list(model),                                        cell_type = \"cell_type_1\",                                        \"effect_name\" = c(\"effect_1\",\"effect_2\"),                                        sided = 2)"},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_ATAC_analysis.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Spatial ATAC Analysis","text":"vignette go typical analysis using spotGLM spatial ATAC dataset. dataset comes p22 mouse brain spatial epigenome-transcriptome co-profiling study Di Zhang et al.¬†2023. dataset, 13 major cell types, among focus oligodendrocytes. study also identified 14 distinct regions, among focus comparing cortex (C0) corpus callosum (C3). called peaks used ChromVAR compute transcription factor activity scores aggregating reads overlap motif signatures. tutorial, focus identify changes transcription factor motif accessibility across two brain regions cell type specific manner.","code":""},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_ATAC_analysis.html","id":"setup-and-data-loading","dir":"Articles","previous_headings":"","what":"Setup and data loading","title":"Spatial ATAC Analysis","text":"start loading following packages. processed brain spatial ATAC data stored public github repository. read data read_spatial_mouse_brain_atac_data() function. function returns following coords: Coordinate matrix. dimension 9215 2 regions: one hot encoded region matrix spot. dimension 9215 14 deconv: deconvolution spot. dimension 9215 9 motif_scores: motif score spot. matrix dimension 9215 746.","code":"library(spotGLM) library(ggplot2) # for plotting library(scales) # for finetuning the appearance of ggplots  library(dplyr) # for manipulating data tables library(patchwork) # for qqplots side-by-side library(ggrepel) # for labeling points in qqplot data = spotGLM::read_example_spatial_mouse_brain_atac_data()"},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_ATAC_analysis.html","id":"plot-of-spatial-regions","dir":"Articles","previous_headings":"","what":"Plot of Spatial Regions","title":"Spatial ATAC Analysis","text":"First, let‚Äôs get feel data plotting map spatial regions.","code":"#number of regions region = apply(data$regions,1,function(x){which(x == 1)}) n_regions <- length(unique(region))  # Create a data frame for plotting plot_df <- data.frame(   x = data$coords[, 1],   y = data$coords[, 2],   region = factor(region)  # convert to factor for discrete coloring )  p1=ggplot(plot_df, aes(x = x, y = y, color = region)) +   geom_point(size = 2) +   scale_color_manual(values = hue_pal()(n_regions)) +   labs(title = \"Spots Colored by Region\", color = \"Region\") +   theme_minimal()  ggsave(\"brain_atac_region_map.png\", plot=p1, width=8, height=8, dpi=300)"},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_ATAC_analysis.html","id":"distribution-of-motif-scores","dir":"Articles","previous_headings":"","what":"Distribution of motif scores","title":"Spatial ATAC Analysis","text":"Unlike case gene expression isoform expression tutorials, distribution motif scores approximately normal, can see randomly picking visualizing histograms:","code":"png(\"brain_atac_motif_score_distributions.png\", height=8, width=8, res=300, units=\"in\") par(mfrow=c(3,3)) for(i in sample(ncol(data$motif_scores), 9)){   hist(data$motif_scores[,i], xlab=\"Motif Scores\", main=colnames(data$motif_scores)[i], col=\"pink\") } dev.off()"},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_ATAC_analysis.html","id":"details-on-statistical-model","dir":"Articles","previous_headings":"","what":"Details on statistical model","title":"Spatial ATAC Analysis","text":", found motif scores approximately normally shaped distributions, use normal error model. First suppose single cell data. Let Yi,mY_{,m} motif score cell ii motif mm. model Yi,mY_{,m} follows Yi,m‚àºùí©(Œ≤m,riCT()+Œ≤m,0CT(),œÉm2).Y_{,m} \\sim \\mathcal{N}(\\beta^{CT()}_{m,r_i} + \\beta^{CT()}_{m,0},\\sigma_m^2). CT()CT() represents cell type cell ii rir_i represents region cell ii resides . Œ≤m,riCT()\\beta^{CT()}_{m,r_i} represents expected motif score cell type CT()CT() region rir_i, Œ≤m,0CT()\\beta^{CT()}_{m,0} intercept term. spot-level data, let Ys,mY_{s,m} score motif mm spot ss. assume spot-level score weighted average motif scores cells reside , .e Ys,m‚àºùí©(‚àëtœÄs,t(Œ≤m,rst+Œ≤m,0t),œÉm2)Y_{s,m} \\sim \\mathcal{N}( \\sum_{t}\\pi_{s,t}(\\beta^{t}_{m,r_s} + \\beta^{t}_{m,0}),\\sigma_m^2) weight cell type tt, œÄs,t\\pi_{s,t}, deconvolution estimate contribution cell type tt spot ss. test differences motif accessibility regions cell type specific manner, compute p-value null hypothesis H0:Œ≤m,rt=Œ≤m,r‚Ä≤t.H_0: \\beta^{t}_{m,r} = \\beta^{t}_{m,r'}.","code":""},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_ATAC_analysis.html","id":"fitting-spotglm-model-across-all-cell-types-and-regions-2-minutes","dir":"Articles","previous_headings":"","what":"Fitting spotGLM model across all cell types and regions (~2 minutes)","title":"Spatial ATAC Analysis","text":"Since using normal noise model , effectively fitting linear model. Thus, can use spot_lm function within spotGLM (lm standards linear model). code fits model motif, effectively computing Œ≤\\beta parameters motif, cell type, region. results stored res, can used downstream test hypotheses interest. time consuming part analysis, taking roughly 2 minutes.","code":"num_motifs = ncol(data$motif_scores) res = vector(\"list\",num_motifs)  t1 = Sys.time() for(j in c(1:num_motifs)){   if(j%%100 == 0){     cat(\"Fitting model for motif \",j,\" out of \", num_motifs,\"\\n\")     print(Sys.time() - t1)   }   res[[j]] = spot_lm(y = data$motif_scores[,j],X = data$regions,                      lambda = data$deconv) } names(res) = colnames(data$motif_scores)"},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_ATAC_analysis.html","id":"oligodendrocyte-differential-motif-accessibility","dir":"Articles","previous_headings":"","what":"Oligodendrocyte Differential Motif Accessibility","title":"Spatial ATAC Analysis","text":"now focus oligodendrocytes corpus callosum vs cortex region use compute_contrast_significance() function test hypothesis, motif, whether accessibility differs oligodendrocytes two regions.","code":"sig_genes = compute_contrast_significance(input_list = res,                                     cell_type = \"Oligodendrocytes\",                                     effect_names = c(\"regionC3\",\"regionC0\"),                                     beta_name = \"beta_estimate\",covariance_name = \"vcov\",                                     sided = 1,direction = \"pos\")  sig_genes = sig_genes%>%filter(!is.na(pval))"},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_ATAC_analysis.html","id":"visualize-test-significance-via-qqplot","dir":"Articles","previous_headings":"Oligodendrocyte Differential Motif Accessibility","what":"Visualize test significance via QQplot","title":"Spatial ATAC Analysis","text":"code draws qq-plot motif test-statistics, labeling top motifs. see Sox transcription factors rank top.","code":"sig_genes_df <- sig_genes[order(sig_genes$test_statistic, decreasing = TRUE), ] sig_genes_df$gene <- rownames(sig_genes_df)  qq <- qqnorm(sig_genes_df$test_statistic, plot.it = FALSE) sig_genes_df$theoretical <- qq$x  # theoretical quantiles sig_genes_df$sample <- qq$y       # sample quantiles # Compute the slope and intercept for the QQ line q1_sample <- quantile(sig_genes_df$test_statistic, 0.25, na.rm=TRUE) q3_sample <- quantile(sig_genes_df$test_statistic, 0.75, na.rm=TRUE) q1_theor  <- qnorm(0.25) q3_theor  <- qnorm(0.75) slope     <- (q3_sample - q1_sample) / (q3_theor - q1_theor) intercept <- q1_sample - slope * q1_theor  # Select the top genes by highest t_test_stat top_n <- 5 top_df <- sig_genes_df[order(sig_genes_df$test_statistic, decreasing = TRUE)[1:top_n], ] # Create the QQ plot using ggplot2 with ggrepel for labeled boxes p <- ggplot(sig_genes_df, aes(x = theoretical, y = sample)) +   geom_point() +   geom_abline(intercept = intercept, slope = slope, color = \"red\", size = 1) +   geom_label_repel(data = top_df, aes(label = gene),                    box.padding = 0.35, point.padding = 0.5, # size = 10,                     segment.color = \"grey50\", max.overlaps = 50) +   labs(x = \"Theoretical Quantiles\",         y = \"Sample Quantiles\",         title = \"Oligodendrocytes: Cortex vs Corpus Callosum\") +   theme_minimal() +   theme(plot.title = element_text(face = \"bold\", hjust = 0.5))  ggsave(\"brain_atac_qqplot.png\", plot=p, width=8, height=8, dpi=300)"},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_ATAC_analysis.html","id":"example-motif-sox4","dir":"Articles","previous_headings":"","what":"Example Motif: SOX4","title":"Spatial ATAC Analysis","text":"now focus one example motif, Sox4, shows differential motif accessibility oligodendrocytes corpus callosum cortex. Let‚Äôs visualize distribution motif space, compare distribution oligodendrocytes. make visual contrast easier see, plot spots lying regionC3 (Corpus Callosum) regionC0 (Cortex): need truncate motif scores outliers don‚Äôt drive color axis:    see oligodendrocytes present high concentrations corpus callosum, also present throughout cortex. spotGLM estimation, able attribute increase Sox4 expression corpus callosum increased expression gene oligodendrocytes region.","code":"motif <- \"SOX4\" region_filter <- data$regions[, \"regionC3\"] == 1 | data$regions[, \"regionC0\"] == 1 # Region labels region_label <- ifelse(data$regions[region_filter, \"regionC3\"] == 1, \"Corpus Callosum\", \"Cortex\") # Motif score with truncation Sox_score <- data$motif_scores[region_filter, motif] Sox_score <- pmin(Sox_score, quantile(Sox_score, 0.99, na.rm = TRUE)) Sox_score <- pmax(Sox_score, quantile(Sox_score, 0.01, na.rm = TRUE)) # Oligodendrocyte proportion oligo_score <- data$deconv[region_filter, \"Oligodendrocytes\"]  # Create plotting data frame plot_df <- data.frame(   x = data$coords[region_filter, 1],   y = data$coords[region_filter, 2],   Sox = Sox_score,   region = region_label,   oligodendrocytes = oligo_score )  # === Plot 1: SOX10 Motif Scores === p1 <- ggplot(plot_df, aes(x = x, y = y, color = Sox)) +   geom_point(size = 2) +   scale_color_viridis_c() +   labs(title = paste0(motif, \" Motif Scores\"), color = motif) +   coord_fixed() +   theme_minimal() ggsave(\"brain_atac_sox4_motif_map.png\", plot=p1, width=8, height=8, dpi=300) # === Plot 2: Region membership === p2 <- ggplot(plot_df, aes(x = x, y = y, color = region)) +   geom_point(size = 2) +   scale_color_manual(values = c(\"Cortex\" = \"#1f78b4\", \"Corpus Callosum\" = \"#33a02c\")) +   labs(title = \"Region Membership\", color = \"Region\") +   coord_fixed() +   theme_minimal() ggsave(\"brain_atac_cortex_corpuscallosum_map.png\", plot=p2, width=8, height=8, dpi=300) # === Plot 3: Oligodendrocyte proportion === p3 <- ggplot(plot_df, aes(x = x, y = y, color = oligodendrocytes)) +   geom_point(size = 2) +   scale_color_viridis_c() +   labs(title = \"Oligodendrocyte Deconvolution Proportion\", color = \"Oligos\") +   coord_fixed() +   theme_minimal()  ggsave(\"brain_atac_oligodendrocyte_map.png\", plot=p3, width=8, height=8, dpi=300)"},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_Long_Read_analysis.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Spatial Long-Read Isoform Analysis","text":"vignette demonstrates full workflow using SpotGLM cell type-specific spatial isoform analysis Visium Oxford Nanopore long read data set. dataset comes study mouse olfactory bulb. data set, 11 major cell types, spread across 5 distinct anatomical layers olfactory bulb. goal identify genes show evidence isoform switching cell type specific manner across spatial layers.","code":""},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_Long_Read_analysis.html","id":"read-in-the-data","dir":"Articles","previous_headings":"Overview","what":"Read in the data","title":"Spatial Long-Read Isoform Analysis","text":"First, load following packages needed plotting data table manipulation: Next, read olfactory bulb data read_spatial_olfactory_bulb_long_read_data() function. function reads public repository data stored, returns list following fields: coords: Coordinate matrix. dimension 918 2 niche: one hot encoded region matrix spot. dimension 918 5 deconv: deconvolution spot. dimension 918 11 library size: library size spot. vector length 918 total_gene_expression: gene, vector spot gene expression. matrix dimension 918 643 isoform expression: list element corresponding gene. isoform expression[[gene]] list length two contains spot level expression top two isoforms gene. deconvolved cell type proportions sometimes cell types contributing small amounts spot denoise setting proportions 0.","code":"library(spotGLM) library(ggplot2) # for plotting library(dplyr) # for manipulating data tables library(patchwork) # for qqplots side-by-side data = spotGLM::read_example_spatial_olfactory_bulb_long_read_data() data$deconv[data$deconv < 0.05] = 0 data$deconv = t(apply(data$deconv,1,function(x){x/sum(x)}))"},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_Long_Read_analysis.html","id":"initial-data-visualization","dir":"Articles","previous_headings":"Overview","what":"Initial data visualization","title":"Spatial Long-Read Isoform Analysis","text":"First let‚Äôs get feel data plotting spatial maps regions:  Also, let‚Äôs see cell types distributed across regions. Let‚Äôs try Neurons (‚ÄúN‚Äù), common cell type.  Now, let‚Äôs plot isoform proportions specific gene, Ap3s1, know (spoiler alert!) spatially-variable isoform expression. normalize isoform-level expression total get relative expression: Plot spatial map isoform relative expression:  look carefully, can see isoform-1 gene seems depleted outer-layer, olfactory nerve layer. change obvious visually, significant? gene switch isoform 2 outer-layer? , spatial patterns isoform usage can simply attributed cell type composition changes, cell type-specific isoform switching, switch isoform usage within cell type. goal spotGLM analysis assess significance spatial variations dissect happening cell type level.","code":"region = apply(data$regions,1,function(x){colnames(data$regions)[which(x == 1)]})  df <- data.frame(   x = data$coords[, 1],   y = data$coords[, 2],   region = region )  p1=ggplot(df, aes(x = x, y = y, color = region)) +   geom_point(size = 2) +   coord_fixed() +   theme_minimal() +   labs(title = \"Spots by Region\", color = \"Region\")  ggsave(\"olfactory_region_map.png\", plot=p1, width=8, height=4, dpi=300) df=cbind(df, data$deconv) p1=ggplot(df, aes(x = x, y = y, color = N)) +   geom_point(size = 2) +   coord_fixed() +   theme_minimal() +   labs(title = \"\", color = \"Neuron\")  ggsave(\"olfactory_Neuron_spatial.png\", plot=p1, width=8, height=4, dpi=300) Ap3s1_isoform1=data$isoform_expression$Ap3s1[[1]] Ap3s1_isoform2=data$isoform_expression$Ap3s1[[2]] Ap3s1_isoform1 = Ap3s1_isoform1/(Ap3s1_isoform1+Ap3s1_isoform2) Ap3s1_isoform2 = Ap3s1_isoform2/(Ap3s1_isoform1+Ap3s1_isoform2) df=cbind(df, Ap3s1_isoform1, Ap3s1_isoform2) p1=ggplot(df, aes(x = x, y = y, color = Ap3s1_isoform1)) +   geom_point(size = 2) +   coord_fixed() +   theme_minimal() +   labs(title = \"\", color = \"Ap3s1_isoform1\")  ggsave(\"olfactory_Ap3s1_spatial_allregions.png\", plot=p1, width=8, height=4, dpi=300)"},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_Long_Read_analysis.html","id":"model-overview","dir":"Articles","previous_headings":"Overview","what":"Model Overview","title":"Spatial Long-Read Isoform Analysis","text":"simplicity, restricting analysis genes exactly two isoforms whose summed expression comprise least 20% isoforms expressed gene. limit genes total expression across spots greater 50 UMIs. genes low expression, wouldn‚Äôt power detect isoform switching, inflate number tests adjust end. total, 643 genes passed two criteria. Next, gene, identified cell types gene sufficient expression. gene highly expressed given cell type, pointless try detect isoform switching cell type. gene gg defined adequately expressed within cell type tt total proportion transcripts mapping gene gg cell type tt greater 1/60000. proportion can estimated fitting spotGLM gene, regressing total expression cell type proportions spot. model follows: Ys,g‚àºPois(exp(log(Ls)+‚àëtœÄs,texp(Œ≤0,gt)))Y_{s,g} \\sim Pois(\\exp(\\log(L_s) + \\sum_{t} \\pi_{s,t}\\exp(\\beta_{0,g}^t))) model, LsL_s library size spot ss,œÄs,t\\pi_{s,t} deconvolution estimate cell type tt spot ss, Œ≤0,gt\\beta_{0,g}^t intercept estimate cell type tt. identify cell type-specific isoform switching, fit ths spotGLM model: Ys,g‚àºBin(ns,g,ps,g),Y_{s,g} \\sim Bin(n_{s,g},p_{s,g}), Ys,gY_{s,g} count isoform 11 gene gg spot ss, ns,gn_{s,g} total expression gene gg spot ss, ps,g=‚àëtws,g,tLogit‚àí1(XsŒ≤t,g),ws,g,t=œÄs,tŒºg,t‚àët‚Ä≤œÄs,t‚Ä≤Œºg,t‚Ä≤.p_{s,g} = \\sum_{t}w_{s,g,t}\\text{Logit}^{-1}(X_s\\beta_{t,g}), \\quad w_{s,g,t}=\\frac{\\pi_{s,t}\\mu_{g,t}}{\\sum_{t'}\\pi_{s,t'}\\mu_{g,t'}}. formula, œÄs,t\\pi_{s,t} deconvolution proportion cell type tt spot ss Œºs,g,t\\mu_{s,g,t} expected expression gene gg cell type tt spot ss estimated spotGLM regression Ys,gY_{s,g} cell type proportions. Thus, analysis requires fitting spotGLM two times, get estimated total expression gene originating cell type spot, get isoform-specific expressions. , show estimation done code.","code":""},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_Long_Read_analysis.html","id":"step-1-estimate-the-cell-type-specific-total-expression-of-each-gene-in-each-spot-1-minute","dir":"Articles","previous_headings":"Overview","what":"Step 1: Estimate the cell type-specific total expression of each gene in each spot (~1 minute)","title":"Spatial Long-Read Isoform Analysis","text":"first use `spotGLM::run_model`` cell type-specific estimation total expression gene spot. function run separately gene, thus can parallelized across genes large data sets. function call, response yy set total count gene gg spot, covariates XX just vector 1‚Äôs (intercept, since step looking differential expression across regions). Œª\\lambda deconvolved cell type proportions spot. offset set library size spot. initialization set TRUE since want initialize parameters. family ‚Äúspot poisson‚Äù since fitting poisson model.","code":"#get number of genes  ngenes = ncol(data$total_gene_expression)  #initialize estimates intercept_estimate = vector(\"list\",ngenes) names(intercept_estimate) = colnames(data$total_gene_expression) #iterate over each gene  for(j in c(1:ngenes)){   intercept_estimate[[j]]=spotGLM::run_model(y = data$total_gene_expression[,j],                                              X = matrix(1,nrow(data$total_gene_expression),1),                                              lambda = data$deconv,                                              offset = log(data$library_size),                                              initialization = T,                                              family = \"spot poisson\",batch_size = 32, n_epoch = 500) }"},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_Long_Read_analysis.html","id":"step-2-fit-spotglm-model-to-get-estimate-isoform-specific-coefficients-for-each-cell-type-in-each-region-1-minute","dir":"Articles","previous_headings":"Overview","what":"Step 2: Fit SpotGLM model to get estimate isoform-specific coefficients for each cell type in each region (~1 minute)","title":"Spatial Long-Read Isoform Analysis","text":"Next, fit binomial spotGLM described . use run_model function. time, however, family ‚Äúspot binomial‚Äù since running binomial model. additionally use two parameters specific binomial model: weights ct_cov_weights. binomial regression, necessary specify total number trials, case corresponds total gene expression vector. Additionally, unlike spot poisson model spot expression weighted mean cell type level expression weight corresponding œÄs,t\\pi_{s,t}, spot binomial model, additional cell type specific weight Œºg,t=exp(Œ≤0,gt)\\mu_{g,t} = \\exp(\\beta_{0,g}^t). vector needs given ct_cov_weights argument. Thus, fit binomial model follows:","code":"isoform_DE = vector(\"list\",ngenes) names(isoform_DE) = colnames(data$total_gene_expression) for(j in c(1:ngenes)){   if(length(intercept_estimate[[j]])==0){     next   }   #get gene name    gene = names(isoform_DE)[j]   #get weights    weights = data$total_gene_expression[,gene]   #get covariate weights    ct_covariate_weights  = exp(intercept_estimate[[gene]]$beta_estimate)   #run model    isoform_DE[[j]] = spotGLM::run_model(y = data$isoform_expression[[gene]][[1]],                                        X = data$regions,                                        lambda = data$deconv,                                        family = \"spot binomial\",                                        weights = weights,                                        ct_cov_weights = ct_covariate_weights,                                        initialization = T,batch_size = 32, n_epoch = 500) }"},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_Long_Read_analysis.html","id":"step-3-contrast-regions-for-a-given-cell-type-to-detect-spatial-isoform-switching-1-minute","dir":"Articles","previous_headings":"Overview","what":"Step 3: Contrast regions for a given cell type to detect spatial isoform switching (<1 minute)","title":"Spatial Long-Read Isoform Analysis","text":"now test cell type specific isoform switching across regions. uses compute_contrast_significance() function, need input specific cell type regions want compare. , simply loop cell types region-pairs. store results data frame combined_contrast_tests can viewed filtered get significant genes specific region-pairs interest. Compute false discovery q-value using Benjamini-Hochberg: Use 10% false discovery rate threshold, get significant cell type-specific isoform switching events regions:","code":"cell_types = colnames(data$deconv) regions = colnames(data$regions) nregion = length(regions) counter = 1 all_contrast_tests = list()  # list to store results  # loop over all cell types and region pairs  for(ct in cell_types){   for(j in c(1:nregion)){     for(k in c(j:nregion)){       if(j==k){         next       }       region_A = regions[j]       region_B = regions[k]       #compute pvalues       pvals = suppressWarnings(spotGLM::compute_contrast_significance(input_list = isoform_DE,                                            cell_type = ct,                                            effect_names = c(region_A,region_B),                                            beta_name = \"beta_estimate\",                                            covariance_name = \"vcov\",                                            sided = 2))              contrast_tests = data.frame(gene = pvals$name, cell_type = ct,                                    region_A = region_A, region_B = region_B,                                    pval = pvals$pval)       #add results to list        all_contrast_tests[[counter]] = contrast_tests       counter = counter + 1     }   } } combined_contrast_tests <- dplyr::bind_rows(all_contrast_tests)%>%                                                     dplyr::filter(!is.na(pval)) combined_contrast_tests$qval = p.adjust(combined_contrast_tests$pval,method = \"BH\") significant_isoform_switches = combined_contrast_tests%>%filter(qval < 0.1)"},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_Long_Read_analysis.html","id":"example-gene-ap3s1","dir":"Articles","previous_headings":"Overview > Step 3: Contrast regions for a given cell type to detect spatial isoform switching (<1 minute)","what":"Example Gene: Ap3s1","title":"Spatial Long-Read Isoform Analysis","text":"show gene showed , Ap3s1, significant isoform switching granule layer layers Neurons (q-value < 0.05 table ). Thus, let‚Äôs compare relative expression isoform 1 gene granule layer layers.  Now, let‚Äôs plot relative isoform 1 expression gene separately Granule Layer layers:","code":"gene <- \"Ap3s1\"  # Isoform ratio isoform_vals <- data$isoform_expression[[gene]][[1]] gene_total <- data$total_gene_expression[, gene] ratio <- isoform_vals / gene_total ratio[!is.finite(ratio)] <- NA  # Region labels region <- apply(data$regions, 1, function(x) {   colnames(data$regions)[which(x == 1)] })  # Binary group region_group <- ifelse(region == \"regionGranule Cell Layer (GCL+RMS)\", \"Granule Layer\", \"Other\")  # Combined dataframe df <- data.frame(   x = data$coords[,1],   y = data$coords[,2],   ratio = ratio,   region = region_group ) %>% filter(!is.na(ratio))  # === Plot 1: Violin + boxplot === p1 <- ggplot(df, aes(x = region, y = ratio, fill = region)) +   geom_violin(trim = FALSE, alpha = 0.6) +   geom_boxplot(width = 0.2, outlier.shape = NA) +   theme_minimal() +   labs(     title = paste(gene, \"Isoform/Gene Ratio\"),     x = \"\", y = \"Ratio\"   ) +   scale_fill_manual(values = c(\"Granule Layer\" = \"tomato\", \"Other\" = \"skyblue\")) +   theme(legend.position = \"none\")  ggsave(\"olfactory_Ap3s1_violin.png\", plot=p1, width=8, height=4, dpi=300) # === Plot 2: Spatial plot - Granule Layer only === p2 <- df %>%   filter(region == \"Granule Layer\") %>%   ggplot(aes(x = x, y = y, color = ratio)) +   geom_point(size = 2) +   scale_color_viridis_c(na.value = \"grey90\") +   coord_fixed() +   theme_minimal() +   labs(title = \"Granule Layer\", x = NULL, y = NULL, color = \"Ratio\")  # === Plot 3: Spatial plot - Other regions === p3 <- df %>%   filter(region == \"Other\") %>%   ggplot(aes(x = x, y = y, color = ratio)) +   geom_point(size = 2) +   scale_color_viridis_c(na.value = \"grey90\") +   coord_fixed() +   theme_minimal() +   labs(title = \"Other Regions\", x = NULL, y = NULL, color = \"Ratio\") ggsave(\"olfactory_Ap3s1_spatial.png\", plot=p2+p3, width=8, height=4, dpi=300)"},{"path":"https://github.com/kaishumason/spotGLM/articles/Vignette_VisiumHD_Mouse_Kidney_analysis.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Visium HD Workflow - SpotGLM w/ SPARROW","text":"vignette demonstrates full analysis workflow using SpotGLM cell type-specific niche differential expression analysis Visium HD data set. also demonstrate SPARROW can used power-preserving data selection, speed analysis. use publicly available Visium HD mouse kidney dataset, can downloaded form 10X Genomics. runtimes reported Windows 11 (64-bit) machine 64GB ram Intel(R) Core(TM) Ultra 7 165U 1700 Mhz processor 12 cores. total runtime script <30 minutes. parts script runtime reported finish instantaneously.","code":""},{"path":"https://github.com/kaishumason/spotGLM/articles/Vignette_VisiumHD_Mouse_Kidney_analysis.html","id":"setup-and-preparing-data-matrices","dir":"Articles","previous_headings":"","what":"Setup and preparing data matrices","title":"Visium HD Workflow - SpotGLM w/ SPARROW","text":"First, load required packages. SpotGLM requires three input matrices‚Äù Spot--gene counts matrix: raw count matrix directly output 10X Spot--cell type compositions matrix: spot deconvolution result, giving contribution cell type spot. use RCTD example, can use method. Deconvolution can take hours, provide matrix, can skip step now. Spot--niche covariate matrix: contains spatial niche covariates right-hand-side spotGLM regression. analysis, use kidney anatomical regions defined via clustering histological image features extracted -slide H&E image. feature extraction clustering takes hours GPU, provide matrix use. can define spatial niches/domains/neighborhoods using methods well. like try pre-processing steps , can use script provide . Otherwise, skip directly next section. load libraries used specifically RCTD. also load Seurat, used read Visium files extract counts spatial coordinates. described paper, bin Visium HD data 8 micron squares. alleviates extreme sparsity data. can download binned data , well cell type reference file deconvolution using RCTD. Simply download zip file, extract files folder named ‚Äúmouse_kidney_data_input‚Äù, put foler root directory analysis. Read data, run RCTD. take . Now, take RCTD output, make spot composition matrix input spotGLM: Write matrix containing spatial coordinates: Write matrix containing counts:","code":"library(spotGLM) library(ggplot2) # for plots library(patchwork) # for plots library(ggrepel) # for labeling points in qqplot library(dplyr) # for fast manipulation of gene tables library(tidyverse) library(arrow) library(spacexr) library(Seurat) localdir <- \"mouse_kidney_data_input/data/binned_outputs/square_008um\" output_dir <- \"mouse_kidney_data_input/preprocessed_data/\" dir.create(output_dir, showWarnings = F) reference <- readRDS( \"mouse_kidney_data_input/RCTD_reference_data/Mouse_kidney_RCTD_reference.rds\") counts<-Read10X_h5(file.path(localdir, \"filtered_feature_bc_matrix.h5\")) coords<-read_parquet(file.path(localdir, \"spatial/tissue_positions.parquet\"), as_data_frame = TRUE) coords <- as.data.frame(coords) rownames(coords)<-coords$barcode coords <- coords[coords$barcode %in% colnames(counts),] coords<-coords[,3:4] nUMI <- colSums(counts) puck <- SpatialRNA(coords, counts, nUMI) barcodes <- colnames(puck@counts) myRCTD <- create.RCTD(puck, reference, max_cores = 12) myRCTD <- run.RCTD(myRCTD, doublet_mode = 'doublet') saveRDS(myRCTD,file=file.path(output_dir,\"Deconvolution_HD.rds\")) cell_types = unique(reference@cell_types) cell_types = droplevels(cell_types) types = unique(cell_types) coords <-  myRCTD@spatialRNA@coords deconv_est = matrix(0,nrow(coords),length(types)) colnames(deconv_est) = types rownames(deconv_est) = rownames(myRCTD@spatialRNA@coords) for(j in c(1:nrow(myRCTD@results$results_df))){   fills = match(unlist(myRCTD@results$results_df[j,c(\"first_type\", \"second_type\")]), types)   deconv_est[j,fills] = myRCTD@results$weights_doublet[j,] } deconv_df <- as.data.frame(deconv_est) saveRDS(deconv_df , file.path(output_dir, \"deconv_matrix.rds\")) coords_all<-read_parquet(file.path(localdir, \"spatial/tissue_positions.parquet\"),as_data_frame = TRUE) coords_all <- as.data.frame(coords_all) rownames(coords_all)<-coords_all$barcode coord_df <- coords_all[coords_all$barcode %in% rownames(deconv_df),] coord_df <- coord_df[rownames(deconv_df),] coord_df <- coord_df %>% select(-barcode) head(coord_df) saveRDS(coord_df , file.path(output_dir, \"coords.rds\")) data <- Load10X_Spatial(data.dir = localdir) count <- data@assays$Spatial$counts count <- count[, rownames(deconv_df)] saveRDS(count, file.path(output_dir, \"count_matrix.rds\"))"},{"path":"https://github.com/kaishumason/spotGLM/articles/Vignette_VisiumHD_Mouse_Kidney_analysis.html","id":"load-data-matrices-and-initial-data-clean","dir":"Articles","previous_headings":"","what":"Load data matrices and initial data clean","title":"Visium HD Workflow - SpotGLM w/ SPARROW","text":"first load data prepare spotGLM, defining following variables: deconv: deconvolution spot, dimension number spots cell types EN: spatial niche vector (case, mouse kidney regions) spot, dimension number spots kidney regions coords: Coordinate matrix, dimension number spots 2 counts: counts matrix spot--gene matrix, dimension number spots number genes data, spots didn‚Äôt anatomical annotation. Thus, keep spots EN environment covariate matrix. get sense working , can now visualize data. First, let‚Äôs plot spatial niches (EN spatial covariate matrix).  Next, let‚Äôs plot distribution endothelial cells (Endothelial cell column deconv matrix). Later, finding endothelial cell-specific niche markers.  Next, let‚Äôs try plotting gene, Slc5a12:  deconvolved cell type proportions sometimes cell types contributing small amounts spot denoise setting proportions 0. SpotGLM gene-specific analysis can parallelized across genes. tutorial, show spotGLM small list genes, analysis can completed minutes. also provide parallelization script can run full transcriptome. always recommend filtering lowly expressed genes, genes increase number tests need adjust , reduces power genes. Filtering also avoids unnecessary computation. Finally, put gene counts, cell type proportions, niche environment one list object passing functions. Next, use SPARROW reduce data smaller size preserving power analysis. optional, can skip next section want simply run full data set.","code":"data_dir <- \"mouse_kidney_data_input/preprocessed_data/\" deconv = readRDS(file.path(data_dir,\"deconv_matrix.rds\")) EN = readRDS(file.path(data_dir,\"EN_covariate_matrix.rds\")) coords = readRDS(file.path(data_dir, \"coords.rds\"))[,2:5] counts = t(readRDS(file.path(data_dir,\"count_matrix.rds\"))) coords = coords[rownames(EN), ] counts = counts[rownames(EN), ] deconv = deconv[rownames(EN), ] # Convert one-hot matrix to factor of region names region_vector <- factor(colnames(EN)[max.col(EN, ties.method = \"first\")],levels = colnames(EN))  # Create plotting data frame plot_df <- data.frame(   x = coords[, 2],   y = coords[, 1],   region = region_vector,   Endothelial = deconv[,\"Endothelial cells\"] )  p1=ggplot(plot_df, aes(x=x,y=y,fill=region))+   geom_raster()+   scale_fill_brewer(palette=\"Set1\")+   coord_fixed()+   theme_minimal()  ggsave(\"kidney_niches.png\", plot=p1, width=4, height=4, dpi=300) p1=ggplot(plot_df[,], aes(x = x, y = y, fill = Endothelial)) +   geom_raster() +   scale_fill_viridis_c() +   coord_fixed() +   theme_minimal()   ggsave(\"kidney_endothelial.png\", plot=p1, width=4, height=4, dpi=300) plot_df$Slc5a12 = log(1+counts[,\"Slc5a12\"]) p1=ggplot(plot_df[,], aes(x = x, y = y, fill = Slc5a12)) +   geom_raster() +   scale_fill_viridis_c() +   coord_fixed() +   theme_minimal()  ggsave(\"kidney_Slc5a12.png\", plot=p1, width=4, height=4, dpi=300) deconv[deconv < 0.1] = 0 deconv = t(apply(deconv,1,function(x){x/sum(x)})) genelist <- readRDS(file.path(data_dir,\"genelist.rds\"))  counts = counts[, genelist] data = list(niche=EN, deconv=deconv, counts=counts, coords=coords)"},{"path":"https://github.com/kaishumason/spotGLM/articles/Vignette_VisiumHD_Mouse_Kidney_analysis.html","id":"use-sparrow-for-power-preserving-data-reduction","dir":"Articles","previous_headings":"","what":"Use SPARROW for power-preserving data reduction","title":"Visium HD Workflow - SpotGLM w/ SPARROW","text":"SPARROW method selects small representative sub-sample large dataset reduce computation time. sub-sample chosen maximize power downstream analysis, , case, SpotGLM given spatial covariates cell type decomposition. SPARROW computes number spots needed high power, chooses spots get balanced representation across cell type-niche configurations. , demonstration, use sparrow select 10,000 spots 18 cell types 7 spatial niches. full data analysis, let SPARROW automatically select number spots based power calculations. compute time part script takes 2 minutes, remove 10,000 spot restriction, take 20 minutes. However, gene selection step can cut run-time spotGLM analysis 1 week overnight, minimal loss power. First, create expanded covariate matrix, described paper. can take look columns expanded_X, get sense matrix holds. gives weight spot every possible (cell type √ó\\times spatial niche) combination. Next, remove covariates many zero entries, compute target standard error. target standard error standard error needed achieve power target_power_approx (set 99\\%) effects size min_effect (set 0.05). target standard errors used next step determine much data reduction can tolerate, spots select, guarantee desired power. data_selection function Sparrow selects spots based expanded covariate matrix target standard errors. , set maximum 10,000 spots. full data analysis, recommend increasing maximum 100,000 spots. can visualize indices selected, overlayed spatial map anatomical niches:  see selected spots distributed across anatomic regions, regions represented. However, spots uniformly distributed dense regions; regions higher complexity cell types cell type-niche combinations. explore deconvolved cell types proportions within niche, find every cell type-niche combination also evenly represented. allows us retain desired power differential tests involving cell types spatial niches. Now, can subset data selected indices downstream analysis","code":"cutoff = -6.5 expanded_X = sparrow::expand_covariate_matrix(X = data$niche, lambda = data$deconv,                                               family = \"negative binomial\",lib_size = rowSums(data$counts),min_reads_per_1000 = 1000*exp(cutoff)) freq <- apply(expanded_X, 2, function(x) sum(x > 0) ) bad_cov <- which(freq < 30) expanded_X <- expanded_X[, -bad_cov] target_standard_errors = sparrow::compute_target_standard_error(X = expanded_X,min_effect = 0.05,target_power_approx = 0.99) selected_indices = sparrow::data_selection(X = t(expanded_X),                                            max_data_size = 10000,                                            min_standard_error = target_standard_errors,                                            log = TRUE,period = 5000) selected_indices = selected_indices[!is.na(selected_indices)] print(paste0(\"#Cells Subsampled: \", length(selected_indices))) p1=ggplot(plot_df, aes(x=x,y=y,fill=region))+   geom_raster()+   scale_fill_brewer(palette=\"Set1\")+   coord_fixed()+   theme_minimal() # overlay with selected indices overlay_df <- plot_df[selected_indices, ] p1=p1 + geom_point(data = overlay_df, aes(x = x, y = y),              color = \"black\", shape = 21, size = 1.2, stroke = 0.4)  ggsave(\"kidney_selected_indices.png\", plot=p1, width=8, height=8, dpi=300) data$deconv = data$deconv[selected_indices,] data$counts = data$counts[selected_indices,] data$coords = data$coords[selected_indices,] data$niche = data$niche[selected_indices,] data$library_size = rowSums(data$counts)"},{"path":"https://github.com/kaishumason/spotGLM/articles/Vignette_VisiumHD_Mouse_Kidney_analysis.html","id":"fit-spotglm-model-and-identify-cell-type-specific-niche-markers","dir":"Articles","previous_headings":"","what":"Fit SpotGLM model and identify cell type-specific niche markers","title":"Visium HD Workflow - SpotGLM w/ SPARROW","text":"now ready run spotGLM selected data. proceeds two steps. First, fit spotglm model (using spotGLM::run_model) gene estimate cell type-specific coefficients spatial covariate. time-consuming step analysis, parallelized across genes. fitting model, can test sorts hypotheses , contrasting two spatial niches identify cell type-specific niche markers. Let XX covariate matrix ss-th row vector describing spatial domain spot ss. example, ss-th row dimension 7, 7 anatomic domains, one-hot encoding spot‚Äôs anatomic domain. model expression gene spot ss Poisson, mean dependent spatial covariates: Ys,g‚àºPois(ùîº[Ys,g|Xs])Y_{s,g} \\sim Pois(\\mathbb{E}[Y_{s,g}|X_{s}]) mean expression equal sum contributions across cell types belong spot,","code":""},{"path":"https://github.com/kaishumason/spotGLM/articles/Vignette_VisiumHD_Mouse_Kidney_analysis.html","id":"testing-on-a-reduced-set-of-genes","dir":"Articles","previous_headings":"Fit SpotGLM model and identify cell type-specific niche markers","what":"Testing on a reduced set of genes","title":"Visium HD Workflow - SpotGLM w/ SPARROW","text":"tutorial, first test model ~230 genes. process takes ~15 minutes. run spotGLM genes, recommend using parallel computing library parallel. Please expand get script . Now fit spotglm model gene, can identify cell type-specific gene markers spatial niches.","code":"t1=Sys.time() num_genes = ncol(data$counts) spotglm_fit = vector(\"list\",num_genes) for(j in c(1:num_genes)){   if(j%%5 == 0){     print(paste(\"fitting model for gene\", j, \"out of\",num_genes))     print(Sys.time() - t1)   }   spotglm_fit[[j]] = spotGLM::run_model(y = data$counts[,j], X = data$niche, lambda = data$deconv,                              family = \"spot negative binomial\", offset = log(data$library_size),                              batch_size = 250, learning_rate = 0.1) } print(\"done!\") names(spotglm_fit) = colnames(data$counts) library(parallel) library(foreach) family <- \"spot negative binomial\" G = 0.1 data_size = 8 * prod(dim(counts))/1e+09 #number of chunks needed nchunks = ceiling(data_size/G) chunk_size = ceiling(ncol(counts)/nchunks) grouping <- rep(1:nchunks, each = chunk_size, length.out = ncol(counts)) index_chunks = split(1:ncol(counts), grouping) chunk_counter = 1 T_1 = Sys.time() for (I in c(1:length(index_chunks))) {   t1 = Sys.time()   print(\"Initializing cluster\")   cluster <- parallel::makeCluster(5, outfile = \"\")   doParallel::registerDoParallel(cluster)   clusterExport(cluster, varlist = c(\"spot_negative_binomial\"))   print(paste0(\"Evaluating chunk \", I, \" out of \",                nchunks))   counts_chunk = as.matrix(counts[, index_chunks[[I]]])   NC = ncol(counts_chunk)   results_chunk = foreach::foreach(i = 1:NC, .export = c(\"X\", \"lambda\", \"family\",\"offset\",                                                          \"counts_chunk\")) %dopar% {                                                            if(i%%1 == 1){                                                              print(i)                                                              print(Sys.time())                                                            }                                                                                                                        print(Sys.time())                                                            Y = counts_chunk[, i]                                                            spotglm::run_model(Y, X = X, lambda = lambda,family = family, offset = offset,learning_rate = 0.1, batch_size = 128,n_epoch = 250)                                                          }   if (chunk_counter == 1) {     spotglm_fit = results_chunk   }   else {     spotglm_fit = c(spotglm_fit, results_chunk)   }   rm(counts_chunk)   gc()   chunk_counter = chunk_counter + 1   print(\"Closing cluster\")   parallel::stopCluster(cluster)   print(paste0(\"Chunk took \",Sys.time() - t1)) } names(spotglm_fit) = colnames(counts) T_2 = Sys.time()  print(T_1) print(T_2)"},{"path":"https://github.com/kaishumason/spotGLM/articles/Vignette_VisiumHD_Mouse_Kidney_analysis.html","id":"identifying-cell-type-specific-niche-marker-genes","dir":"Articles","previous_headings":"","what":"Identifying cell type-specific niche marker genes","title":"Visium HD Workflow - SpotGLM w/ SPARROW","text":"identify niche marker genes, perform contrast test, contrasting cell type-specific niche coefficients gene, spatial niches interest. can using compute_contrast_significance() function. need tell function spatial covariates (.e.¬†niches) contrasting. example, let‚Äôs find niche marker genes differentiating Endothelial cells Papilla region vs Cortex region. papilla region markers, want genes upregulated papilla region. Thus, specify want one-sided test positive direction (side = 1, direction = ‚Äúpos‚Äù).","code":"cell_type = \"Endothelial cells\" niche1 = \".data_Papilla\"  niche2 = \".data_Cortex\" sig_genes = compute_contrast_significance(input_list = spotglm_fit,                                           cell_type = cell_type,                                           effect_names = c(niche1, niche2),                                           beta_name = \"beta_estimate\",covariance_name = \"vcov\",                                           sided = 1,direction = \"pos\") sig_genes = sig_genes%>%dplyr::filter(!is.na(pval))"},{"path":[]},{"path":"https://github.com/kaishumason/spotGLM/articles/Vignette_VisiumHD_Mouse_Kidney_analysis.html","id":"qqplot","dir":"Articles","previous_headings":"Data Visualization","what":"QQplot","title":"Visium HD Workflow - SpotGLM w/ SPARROW","text":"First, use QQ plot get sense p-value distribution look like, highlight significant genes.","code":"sig_genes_df <- sig_genes[order(sig_genes$test_statistic, decreasing = TRUE), ] sig_genes_df$gene <- rownames(sig_genes_df)  qq <- qqnorm(sig_genes_df$test_statistic, plot.it = FALSE) sig_genes_df$theoretical <- qq$x  # theoretical quantiles sig_genes_df$sample <- qq$y       # sample quantiles # Compute the slope and intercept for the QQ line q1_sample <- quantile(sig_genes_df$test_statistic, 0.25, na.rm=TRUE) q3_sample <- quantile(sig_genes_df$test_statistic, 0.75, na.rm=TRUE) q1_theor  <- qnorm(0.25) q3_theor  <- qnorm(0.75) slope     <- (q3_sample - q1_sample) / (q3_theor - q1_theor) intercept <- q1_sample - slope * q1_theor  # Select the top genes by highest t_test_stat top_n <- 35 top_df <- sig_genes_df[order(sig_genes_df$test_statistic, decreasing = TRUE)[1:top_n], ] # Create the QQ plot using ggplot2 with ggrepel for labeled boxes p <- ggplot(sig_genes_df, aes(x = theoretical, y = sample)) +   geom_point() +   geom_abline(intercept = intercept, slope = slope, color = \"red\", size = 1) +   geom_label_repel(data = top_df, aes(label = gene),                    box.padding = 0.35, point.padding = 0.5, # size = 10,                     segment.color = \"grey50\", max.overlaps = 50) +   labs(x = \"Theoretical Quantiles\",         y = \"Sample Quantiles\",         title = paste0(cell_type, \": \", str_replace(niche1, \".data_\", \"\"), \" vs.\", str_replace(niche2, \".data_\", \"\"))) +   theme_minimal() +   theme(plot.title = element_text(face = \"bold\", hjust = 0.5))  ggsave(\"kidney_qqplot.png\", plot=p, width=8, height=8, dpi=300)"},{"path":"https://github.com/kaishumason/spotGLM/articles/Vignette_VisiumHD_Mouse_Kidney_analysis.html","id":"spatial-map-of-example-gene-igfbp3","dir":"Articles","previous_headings":"Data Visualization","what":"Spatial map of example gene: Igfbp3","title":"Visium HD Workflow - SpotGLM w/ SPARROW","text":"can also visualize spatial distribution specific gene. First, normalized counts: $$ \\hbox{normalized count} = \\log\\left(1+10000\\times \\frac{\\hbox{count}}{\\hbox{library-size}}\\right)$$ didn‚Äôt now, SPARROW SpotGLM package internally accounts library size computations. plotting, need use normalized values. Let‚Äôs look marker just identified distinguishing endothelial cells Papilla region versus Cortex region.  see endothelial cells present cortex IM, endothelial gene Igfbp3 visible expression enrichment cortex.","code":"counts_data <- data$counts total_counts <- colSums(counts_data) scale_factor <- 1e4 scaled_counts <- t(t(counts) / total_counts) * scale_factor normalized_counts <- log1p(scaled_counts) data$normcounts <- normalized_counts gene <- \"Igfbp3\"  # Filter for spots only in the two regions being compared region_filter <- data$niche[, \".data_Cortex\"] == 1 | data$niche[, \".data_IM\"] == 1 gene_expr <- data$normcounts[region_filter, gene] cellprop_score <- data$deconv[region_filter, \"Endothelial cells\" ] region_label <- ifelse(data$niche[region_filter, \".data_Cortex\"] == 1, \"Cortex\", \"IM\")  # Create plotting data frame plot_df <- data.frame(   x = data_sparrow$coords[region_filter, 2],   y = data_sparrow$coords[region_filter, 1],   Gene = gene_expr,   region = region_label,   celltype = cellprop_score )  # === Plot 1: Gene expression levels === p1 <- ggplot(plot_df, aes(x = x, y = y, color = Gene)) +   geom_point(size = 2, alpha=0.5) +   scale_color_viridis_c() +   labs(title = paste0(gene, \" Gene expression value\"), color = gene) +   coord_fixed() +   theme_minimal() +    scale_color_gradient(low = \"blue\", high = \"red\")   # === Plot 2: Region annotation === p2 <- ggplot(plot_df, aes(x = x, y = y, color = region)) +   geom_point(size = 2, alpha=0.5) +   scale_color_manual(values = c(\"Cortex\" = \"#1f78b4\", \"IM\" = \"#33a02c\")) +   labs(title = \"Region Membership\", color = \"Region\") +   coord_fixed() +   theme_minimal()  # === Plot 3: Endoehelial cell type proportion === p3 <- ggplot(plot_df, aes(x = x, y = y, color = celltype)) +   geom_point(size = 2, alpha=0.5) +   scale_color_viridis_c() +   labs(title = \"Deconvolution Proportion\") +   coord_fixed() +   theme_minimal()     combined_plot = p1+p2+p3 ggsave(\"example_gene.png\", plot=combined_plot, width=15, height=5, dpi=300)"},{"path":"https://github.com/kaishumason/spotGLM/articles/Visium_analysis.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Visium Niche DE Analysis","text":"vignette demonstrates full analysis workflow using SpotGLM cell type-specific niche differential expression analysis Visium data set. dataset comes colorectal cancer patient, initially published study. already identified 3 normal cell types: hepatocytes, myeloid cells, stromal cells, well two subclones tumor found via Clonalscope. spot, summarize cellular niche computing weighted sum cell type concentrations spots surrounding , closer spots weighted higher. use spotGLM identify genes display significant niche associations cell type specific way.","code":""},{"path":"https://github.com/kaishumason/spotGLM/articles/Visium_analysis.html","id":"setup-and-data-loading","dir":"Articles","previous_headings":"Overview","what":"Setup and data loading","title":"Visium Niche DE Analysis","text":"First, load following packages needed plotting data table manipulation: Next, read colorectal cancer data read_example_visium_colorectal_cancer_data() function. function reads public repository data stored, returns list following fields: coords: Coordinate matrix. dimension 3826 2 niche: niche vector spot. dimension 3826 7 deconv: deconvolution spot. dimension 3826 7 counts: counts matrix 2000 genes. dimension 3826 2000 library size: library size spot. vector length 3826","code":"library(spotGLM) library(ggplot2) # for plotting library(dplyr) # for manipulating data tables library(patchwork) # for qqplots side-by-side data = spotGLM::read_example_visium_colorectal_cancer_data()"},{"path":"https://github.com/kaishumason/spotGLM/articles/Visium_analysis.html","id":"plotting-the-data","dir":"Articles","previous_headings":"Overview","what":"Plotting the data","title":"Visium Niche DE Analysis","text":"mentioned, spot‚Äôs spatial niche encoded vector length TT TT number cell types sample. vector becomes covariate spotGLM model. larger value given cell type, higher concentration cell type neighborhood spot. example, get feel data, let‚Äôs plot niche covariate term tumor subclone 1, contrast tumor cell concentration spot: Display side side:  see tumor subclone 1 niche covariate high regions tumor deconvolution also high.","code":"# Prepare data for plotting plot_df_deconv <- data.frame(   x = data$coords[, 1],   y = data$coords[, 2],   subclone_1 = data$deconv[, \"subclone_1\"] )  plot_df_niche <- data.frame(   x = data$coords[, 1],   y = data$coords[, 2],   subclone_1 = data$niche[, \"subclone_1\"] )  # Plot 1: deconv p1 <- ggplot(plot_df_deconv, aes(x = x, y = y, color = subclone_1)) +   geom_point(size = 1) +   scale_color_viridis_c() +   labs(title = \"Deconvolution - Subclone 1\", color = \"Subclone 1\") +   theme_minimal()  # Plot 2: niche p2 <- ggplot(plot_df_niche, aes(x = x, y = y, color = subclone_1)) +   geom_point(size = 1) +   scale_color_viridis_c() +   labs(title = \"Niche Covariate - Subclone 1\", color = \"Subclone 1\") +   theme_minimal() ggsave(\"colorectal_tumor_subclone_side-by-side.png\", plot=p1+p2, width=12, height=6, dpi=300)"},{"path":"https://github.com/kaishumason/spotGLM/articles/Visium_analysis.html","id":"spotglm-model-details","dir":"Articles","previous_headings":"Overview","what":"SpotGLM model details","title":"Visium Niche DE Analysis","text":"describe SpotGLM model use data. model also described paper. Let XX covariate matrix iith row X, XiX_i corresponds TT dimensional effective niche vector described . single cell glm model cell type Yi,g‚àºPois(ùîº[Yi,g|Xi])Y_{,g} \\sim Pois(\\mathbb{E}[Y_{,g}|X_{}])log(ùîº[Yi,g|Xi])=XiŒ≤gCT()+log(Li)\\log(\\mathbb{E}[Y_{,g}|X_{}]) = X_i\\beta^{CT()}_g + \\log(L_i) LiL_i library size cell ii, CT()CT() cell type assignment cell ii Œ≤gCT()\\beta^{CT()}_g vector dimension T√ó1T \\times 1 acts weight vector cells type CT()CT() gene gg. index Œ≤gCT()\\beta^{CT()}_g, Œ≤t‚Ä≤,gCT()\\beta^{CT()}_{t',g} equal 0, amount cell t‚Ä≤t' niche affects expression gene gg cells type CT()CT(). called (CT(),t‚Äô) niche differential gene. spot ss, gene expression modeled sum cells make sot thus can modeled Ys,g‚àºPois(ùîº[Ys,g|Xs])Y_{s,g} \\sim Pois(\\mathbb{E}[Y_{s,g}|X_{s}])ùîº[Ys,g|Xi]=log(Ls)+‚àëtœÄs,texp(XsŒ≤gt)\\mathbb{E}[Y_{s,g}|X_{}] = \\log(L_s) + \\sum_{t} \\pi_{s,t}\\exp(X_s\\beta^{t}_g)  LsL_s library size spot ss œÄs,t\\pi_{s,t} deconvolution estimate cell type tt spot ss. model can fit using spotGLM. use ‚Äúrun model‚Äù function. function takes several arguments, important .","code":""},{"path":"https://github.com/kaishumason/spotGLM/articles/Visium_analysis.html","id":"fitting-the-spotglm-model-10-minutes","dir":"Articles","previous_headings":"Overview","what":"Fitting the SpotGLM model (~ 10 minutes)","title":"Visium Niche DE Analysis","text":"detect cell type-specific niche-associated genes, run SpotGLM two steps. First, use run_model() function estimate Œ≤gt\\beta_g^t parameters genes, capture cell type-specific niche associations. , use compute_significance function identify significant associations. Running run_model() time consuming step, take 20 minutes 2000 genes filtering. However, step can parallelized across genes. first show without parallelization, small set genes:","code":"num_genes = ncol(data$counts) res = vector(\"list\",num_genes) # container for the results t1 = Sys.time() for(j in c(1:num_genes)){   if(j%%100 == 0){     cat(\"Fitting model for gene \",j,\" out of \", num_genes,\"\\n\")     print(Sys.time() - t1)   }   res[[j]] = spotGLM::run_model(y = data$counts[,j],X = data$niche, lambda = data$deconv,family = \"spot poisson\",offset = log(data$library_size),initialization = T,batch_size = 250) } names(res) = colnames(data$counts)"},{"path":"https://github.com/kaishumason/spotGLM/articles/Visium_analysis.html","id":"identifying-significant-niche-differential-genes","dir":"Articles","previous_headings":"Overview","what":"Identifying significant niche differential genes","title":"Visium Niche DE Analysis","text":"fitting spotGLM model, can evaluate genes niche-associated. index cell type (say, fibroblasts) niche cell type n (say, tumor), gene (,n) associated expression cell type associated concentration cell type n spatial niche. identify genes, use function compute_significance, parameter cell_type set index cell type, parameter effect_name set niche cell type. example, let‚Äôs focus genes whose expression fibroblasts depend concentration tumor subclone-1 niche. set side=1 direction=\"pos\", get genes upregulated fibroblasts tumor subclone-1 present.","code":"sig_genes = compute_significance(input_list = res,cell_type = \"stromal\",                                  effect_name = \"subclone_1\",                                  beta_name = \"beta_estimate\",                                  standard_error_name = \"standard_error_matrix\",                                  sided = 1,direction = \"pos\") sig_genes = sig_genes%>%filter(!is.na(pval)) print(\"The following genes are (fibroblast,tumor subclone 1) niche differential\") print(rownames(sig_genes)[sig_genes$qval < 0.05])"},{"path":"https://github.com/kaishumason/spotGLM/articles/Visium_analysis.html","id":"contrasting-two-niches-for-a-cell-type","dir":"Articles","previous_headings":"Overview","what":"Contrasting two niches for a cell type","title":"Visium Niche DE Analysis","text":"can also perform contrast test see gene niche-marker gene. niche marker gene cell type tt one Œ≤t1,gt‚â†Œ≤t2,gt.\\beta^{t}_{t_1,g} \\neq \\beta^{t}_{t_2,g}. test rejects, means can differentiate whether cell type tt resides niche enriched cell type t1t_1 cell type t2t_2 looking gene expression gene gg. can also using compute_contrast_significance() function, giving cell type interest (cell_type) effects contrast(effect_names). example, let‚Äôs find niche marker genes fibroblasts can distinguish tumor subclone-1 vs tumor subclone-2. set side = 1 direction = ‚Äúpos‚Äù genes small p-value correspond upregulated fibroblasts presence tumor subclone-1.","code":"#compute contrast test sig_genes = compute_contrast_significance(input_list = res,                                     cell_type = \"stromal\",                                     effect_names = c(\"subclone_1\",\"subclone_2\"),                                beta_name = \"beta_estimate\",covariance_name = \"vcov\",                                sided = 1,direction = \"pos\") sig_genes = sig_genes%>%filter(!is.na(pval)) m = paste0(\"The following genes are niche marker genes for fibroblasts near\",             \" tumor sublcone 1 vs tumor subclone 2\") print(m) print(rownames(sig_genes)[sig_genes$qval < 0.05])"},{"path":[]},{"path":"https://github.com/kaishumason/spotGLM/articles/Visium_analysis.html","id":"example-isg15","dir":"Articles","previous_headings":"Overview > Visualization of significant genes","what":"Example: ISG15","title":"Visium Niche DE Analysis","text":"Note ISG15 (fibroblast,subclone-1) niche differential gene well niche marker gene differentiating subclone-1 versus subclone-2. plot expression ISG15 see visually. First, threshold outliers don‚Äôt drive color axes plots.  fibroblasts tumor subclone 2 region express much less ISG15 subclone 1 region. Additionally, non tumor region (‚Äú) shows little expression ISG15.","code":"gene <- \"ISG15\"  # Expression clipping expression <- data$counts[, gene] expression <- pmax(expression, quantile(expression, 0.05)) expression <- pmin(expression, quantile(expression, 0.95))  #deconvolution clipping deconv_prop = data$deconv[, \"stromal\"] deconv_prop = pmax(deconv_prop , quantile(deconv_prop , 0.01)) deconv_prop = pmin(deconv_prop , quantile(deconv_prop , 0.99)) # === Plot 1: ISG15 Expression === df1 <- data.frame(   x = data$coords[, 1],   y = data$coords[, 2],   gene = expression )  p1 <- ggplot(df1, aes(x = x, y = y, color = gene)) +   geom_point(size = 1) +   scale_color_viridis_c() +   coord_fixed() +   theme_minimal() +   labs(     title = paste0(gene, \" Expression\"),     x = \"X\", y = \"Y\", color = gene   )  # === Plot 2: Majority subclones === majority_subclone <- colnames(data$deconv)[max.col(data$deconv,                                                    ties.method = \"first\")] df2 <- data.frame(   x = data$coords[, 1],   y = data$coords[, 2],   majority = majority_subclone )  df2$highlight <- case_when(   df2$majority == \"subclone_1\" ~ \"subclone_1\",   df2$majority == \"subclone_2\" ~ \"subclone_2\",   TRUE ~ \"other\" )  p2 <- ggplot(df2, aes(x = x, y = y, color = highlight)) +   geom_point(size = 1) +   scale_color_manual(     values = c(       \"subclone_1\" = \"red\",       \"subclone_2\" = \"blue\",       \"other\" = \"grey80\"     )   ) +   coord_fixed() +   theme_minimal() +   labs(title = \"Majority Subclone Regions\", color = \"Majority Subclone\")  # === Plot 3: Stromal proportions === df3 <- data.frame(   x = data$coords[, 1],   y = data$coords[, 2],   stromal = deconv_prop )  p3 <- ggplot(df3, aes(x = x, y = y, color = stromal)) +   geom_point(size = 1) +   scale_color_viridis_c() +   coord_fixed() +   theme_minimal() +   labs(title = \"Stromal Proportion\", color = \"Stromal\")  # === Combine all plots === ggsave(\"colorectal_tumor_subclone_ISG15.png\", plot=p1+p2+p3, width=18, height=6, dpi=300)"},{"path":"https://github.com/kaishumason/spotGLM/articles/Visium_analysis.html","id":"example-col4a1","dir":"Articles","previous_headings":"Overview > Visualization of significant genes","what":"Example: COL4A1","title":"Visium Niche DE Analysis","text":"Next, consider COL4A1, (fibroblast,subclone-1) niche differential gene significant contrast subclone-1 versus subclone-2. plot expression COL4A1 can also see visually.","code":"gene <- \"COL4A1\"  # Expression clipping expression <- data$counts[, gene] expression <- pmax(expression, quantile(expression, 0.05)) expression <- pmin(expression, quantile(expression, 0.95))  #deconvolution clipping deconv_prop = data$deconv[, \"stromal\"] deconv_prop = pmax(deconv_prop , quantile(deconv_prop , 0.01)) deconv_prop = pmin(deconv_prop , quantile(deconv_prop , 0.99))  # === Plot 1: ISG15 Expression === df1 <- data.frame(   x = data$coords[, 1],   y = data$coords[, 2],   gene = expression )  p1 <- ggplot(df1, aes(x = x, y = y, color = gene)) +   geom_point(size = 1) +   scale_color_viridis_c() +   coord_fixed() +   theme_minimal() +   labs(     title = paste0(gene, \" Expression\"),     x = \"X\", y = \"Y\", color = gene   )  # === Plot 2: Majority subclones === majority_subclone <- colnames(data$deconv)[max.col(data$deconv,                                                    ties.method = \"first\")]  df2 <- data.frame(   x = data$coords[, 1],   y = data$coords[, 2],   majority = majority_subclone )  df2$highlight <- case_when(   df2$majority == \"subclone_1\" ~ \"subclone_1\",   df2$majority == \"subclone_2\" ~ \"subclone_2\",   TRUE ~ \"other\" )  p2 <- ggplot(df2, aes(x = x, y = y, color = highlight)) +   geom_point(size = 1) +   scale_color_manual(     values = c(       \"subclone_1\" = \"red\",       \"subclone_2\" = \"blue\",       \"other\" = \"grey80\"     )   ) +   coord_fixed() +   theme_minimal() +   labs(title = \"Majority Subclone Regions\", color = \"Majority Subclone\")  # === Plot 3: Stromal proportions === df3 <- data.frame(   x = data$coords[, 1],   y = data$coords[, 2],   stromal = deconv_prop )  p3 <- ggplot(df3, aes(x = x, y = y, color = stromal)) +   geom_point(size = 1) +   scale_color_viridis_c() +   coord_fixed() +   theme_minimal() +   labs(title = \"Stromal Proportion\", color = \"Stromal\")  # === Combine all plots === ggsave(\"colorectal_tumor_subclone_COL4A1.png\", plot=p1+p2+p3, width=18, height=6, dpi=300)"},{"path":"https://github.com/kaishumason/spotGLM/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Kaishu Mason. Author. Yijia Jiang. Author. Nancy R. Zhang. Author, maintainer.","code":""},{"path":"https://github.com/kaishumason/spotGLM/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Mason K, Jiang Y, Zhang N (2025). spotGLM: SpotGLM. R package version 0.1.0, https://github.com/kaishumason/spotGLM.","code":"@Manual{,   title = {spotGLM: SpotGLM},   author = {Kaishu Mason and Yijia Jiang and Nancy R. Zhang},   year = {2025},   note = {R package version 0.1.0},   url = {https://github.com/kaishumason/spotGLM}, }"},{"path":"https://github.com/kaishumason/spotGLM/index.html","id":"spotglm","dir":"","previous_headings":"","what":"SpotGLM: Cell-Type-Specific Differential Testing for Spatial Omics Data","title":"SpotGLM: Cell-Type-Specific Differential Testing for Spatial Omics Data","text":"SpotGLM R package performing cell type-specific differential testing spatial omics data. adapts different data modalities, gene expression, chromatin accessibility, isoform usage, identifies cell type specific changes associated local tissue context. SpotGLM accounts mixed-cell composition inherent spatial barcoding technologies. SpotGLM integrated SPARROW package, making fast ultra-scalable data sets millions spots.","code":""},{"path":"https://github.com/kaishumason/spotGLM/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"SpotGLM: Cell-Type-Specific Differential Testing for Spatial Omics Data","text":"install SpotGLM GitHub: strongly recommend using SpotGLM SPARROW, power-preserving data reduction method can speed analyses. SPARROW can also installed GitHUB:","code":"install.packages(\"devtools\") devtools::install_github(\"kaishumason/SpotGLM\") # install install.packages(\"devtools\") devtools::install_github(\"kaishumason/SPARROW\") # install"},{"path":"https://github.com/kaishumason/spotGLM/index.html","id":"getting-started","dir":"","previous_headings":"","what":"Getting Started","title":"SpotGLM: Cell-Type-Specific Differential Testing for Spatial Omics Data","text":"Please follow tutorials get started data: Using SpotGLM SPARROW Visium HD Using SpotGLM Visium data SpotGLM isoform switching analysis spatial long read data SpotGLM spatial ATAC analysis technical tutorial applies spotGLM simulation data. working simulation data, can see generative model used spotGLM: Demonstration SpotGLM simulation data","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/binomial_lik.html","id":null,"dir":"Reference","previous_headings":"","what":"Binomial Log-Likelihood ‚Äî binomial_lik","title":"Binomial Log-Likelihood ‚Äî binomial_lik","text":"Computes negative log-likelihood Binomial distribution.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/binomial_lik.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Binomial Log-Likelihood ‚Äî binomial_lik","text":"","code":"binomial_lik(x, mu, num_obs)"},{"path":"https://github.com/kaishumason/spotGLM/reference/binomial_lik.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Binomial Log-Likelihood ‚Äî binomial_lik","text":"x Vector observed successes. mu Vector predicted probabilities. num_obs Number trials observation.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/binomial_lik.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Binomial Log-Likelihood ‚Äî binomial_lik","text":"Negative log-likelihood value.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_contrast.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute P-values for Pairwise Contrasts ‚Äî compute_contrast","title":"Compute P-values for Pairwise Contrasts ‚Äî compute_contrast","text":"Computes Z-scores p-values contrasts two covariates within single cell type.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_contrast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute P-values for Pairwise Contrasts ‚Äî compute_contrast","text":"","code":"compute_contrast(   input_list,   cell_type,   effect_names,   beta_name = \"beta_estimate\",   covariance_name = \"vcov\",   sided = 2,   direction = \"pos\" )"},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_contrast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute P-values for Pairwise Contrasts ‚Äî compute_contrast","text":"input_list list model outputs beta covariance matrices. cell_type Character. Cell type interest. effect_names Character vector length 2 indicating two covariates contrast. beta_name Name beta matrix model output (default: \"beta_estimate\"). covariance_name Name covariance matrix model output (default: \"vcov\"). sided Integer. 1 one-sided, 2 two-sided test. direction Character. \"pos\" \"neg\", used sided = 1.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_contrast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute P-values for Pairwise Contrasts ‚Äî compute_contrast","text":"named list p-values model input list.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_contrast_significance.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Significance for Pairwise Covariate Contrast ‚Äî compute_contrast_significance","title":"Compute Significance for Pairwise Covariate Contrast ‚Äî compute_contrast_significance","text":"Calculates p-values adjusted q-values contrasts two effects within specific cell type.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_contrast_significance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Significance for Pairwise Covariate Contrast ‚Äî compute_contrast_significance","text":"","code":"compute_contrast_significance(   input_list,   cell_type,   effect_names,   beta_name = \"beta_estimate\",   covariance_name = \"vcov\",   sided = 2,   direction = \"pos\" )"},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_contrast_significance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Significance for Pairwise Covariate Contrast ‚Äî compute_contrast_significance","text":"input_list list model outputs beta covariance matrices. cell_type Character. Cell type interest. effect_names Character vector length 2 indicating covariates contrast. beta_name Name beta matrix (default: \"beta_estimate\"). covariance_name Name covariance matrix (default: \"vcov\"). sided Integer. 1 one-sided, 2 two-sided test. direction Character. \"pos\" \"neg\", used sided = 1.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_contrast_significance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Significance for Pairwise Covariate Contrast ‚Äî compute_contrast_significance","text":"data frame columns: name, pval, qval.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_pvals.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute P-values for Single Covariate ‚Äî compute_pvals","title":"Compute P-values for Single Covariate ‚Äî compute_pvals","text":"Computes Z-scores p-values single covariate specific cell type.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_pvals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute P-values for Single Covariate ‚Äî compute_pvals","text":"","code":"compute_pvals(   input_list,   cell_type,   effect_name,   beta_name = \"beta_estimate\",   standard_error_name = \"standard_error_matrix\",   sided = 2,   direction = \"pos\" )"},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_pvals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute P-values for Single Covariate ‚Äî compute_pvals","text":"input_list list model outputs beta standard error matrices. cell_type Character. Cell type interest. effect_name Character. Name covariate/effect interest. beta_name Name beta matrix model output (default: \"beta_estimate\"). standard_error_name Name standard error matrix (default: \"standard_error_matrix\"). sided Integer. 1 one-sided, 2 two-sided test. direction Character. \"pos\" \"neg\", used sided = 1.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_pvals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute P-values for Single Covariate ‚Äî compute_pvals","text":"named list p-values model input list.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_qvals.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Q-values from P-value List ‚Äî compute_qvals","title":"Compute Q-values from P-value List ‚Äî compute_qvals","text":"Applies Benjamini-Hochberg correction across list p-value vectors reconstructs q-values structure.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_qvals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Q-values from P-value List ‚Äî compute_qvals","text":"","code":"compute_qvals(pval_list)"},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_qvals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Q-values from P-value List ‚Äî compute_qvals","text":"pval_list named list numeric vectors containing p-values.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_qvals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Q-values from P-value List ‚Äî compute_qvals","text":"named list numeric vectors q-values corresponding input p-values.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_significance.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Significance for a Single Covariate ‚Äî compute_significance","title":"Compute Significance for a Single Covariate ‚Äî compute_significance","text":"Calculates p-values adjusted q-values given effect specific cell type.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_significance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Significance for a Single Covariate ‚Äî compute_significance","text":"","code":"compute_significance(   input_list,   cell_type,   effect_name,   beta_name = \"beta_estimate\",   standard_error_name = \"standard_error_matrix\",   sided = 2,   direction = \"pos\" )"},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_significance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Significance for a Single Covariate ‚Äî compute_significance","text":"input_list list model outputs beta standard error matrices. cell_type Character. Cell type interest. effect_name Character. Name covariate/effect interest. beta_name Name beta matrix (default: \"beta_estimate\"). standard_error_name Name standard error matrix (default: \"standard_error_matrix\"). sided Integer. 1 one-sided, 2 two-sided test. direction Character. \"pos\" \"neg\", used sided = 1.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_significance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Significance for a Single Covariate ‚Äî compute_significance","text":"data frame columns: name, pval, qval.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_standard_errors.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Standard Errors via Fisher Information ‚Äî compute_standard_errors","title":"Compute Standard Errors via Fisher Information ‚Äî compute_standard_errors","text":"Computes variance-covariance matrix estimates Fisher Information Matrix.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_standard_errors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Standard Errors via Fisher Information ‚Äî compute_standard_errors","text":"","code":"compute_standard_errors(   X,   y,   lambda,   family,   beta,   good_beta,   dispersion,   weights,   offset )"},{"path":"https://github.com/kaishumason/spotGLM/reference/gaussian_lik.html","id":null,"dir":"Reference","previous_headings":"","what":"Gaussian Log-Likelihood ‚Äî gaussian_lik","title":"Gaussian Log-Likelihood ‚Äî gaussian_lik","text":"Computes negative log-likelihood Gaussian distribution.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/gaussian_lik.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gaussian Log-Likelihood ‚Äî gaussian_lik","text":"","code":"gaussian_lik(x, mu, sigma)"},{"path":"https://github.com/kaishumason/spotGLM/reference/gaussian_lik.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gaussian Log-Likelihood ‚Äî gaussian_lik","text":"x Vector observed values. mu Vector predicted means. sigma Standard deviation.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/gaussian_lik.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gaussian Log-Likelihood ‚Äî gaussian_lik","text":"Negative log-likelihood value.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/glm_fisher.html","id":null,"dir":"Reference","previous_headings":"","what":"Fisher Information Matrix for Spot-GLM ‚Äî glm_fisher","title":"Fisher Information Matrix for Spot-GLM ‚Äî glm_fisher","text":"Computes Fisher Information matrix given GLM family model.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/glm_fisher.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fisher Information Matrix for Spot-GLM ‚Äî glm_fisher","text":"","code":"glm_fisher(   X,   y,   lambda,   family,   beta,   good_beta,   dispersion,   weights = NULL,   offset = rep(0, length(y)) )"},{"path":"https://github.com/kaishumason/spotGLM/reference/gradient_descent_update.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Gradient Descent Updates for Spot-GLM ‚Äî gradient_descent_update","title":"Compute Gradient Descent Updates for Spot-GLM ‚Äî gradient_descent_update","text":"Computes gradients negative log-likelihood supported GLM families.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/gradient_descent_update.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Gradient Descent Updates for Spot-GLM ‚Äî gradient_descent_update","text":"","code":"gradient_descent_update(   family,   X,   y,   beta,   lambda,   offset,   disp = 1e+08,   weights = rep(1, length(y)) )"},{"path":"https://github.com/kaishumason/spotGLM/reference/hello.html","id":null,"dir":"Reference","previous_headings":"","what":"Hello, World! ‚Äî hello","title":"Hello, World! ‚Äî hello","text":"Prints 'Hello, world!'.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/hello.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hello, World! ‚Äî hello","text":"","code":"hello()"},{"path":"https://github.com/kaishumason/spotGLM/reference/hello.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hello, World! ‚Äî hello","text":"","code":"hello() #> Error in hello(): could not find function \"hello\""},{"path":"https://github.com/kaishumason/spotGLM/reference/initialize_fix_coef.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialize Fixed Coefficient Matrix ‚Äî initialize_fix_coef","title":"Initialize Fixed Coefficient Matrix ‚Äî initialize_fix_coef","text":"Automatically sets coefficients fix based low signal coverage.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/initialize_fix_coef.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialize Fixed Coefficient Matrix ‚Äî initialize_fix_coef","text":"","code":"initialize_fix_coef(   X,   lambda,   fix_coef = matrix(FALSE, ncol(X), ncol(lambda)),   weights = NULL,   min_deconv = 0.1,   min_freq = 100 )"},{"path":"https://github.com/kaishumason/spotGLM/reference/nb_lik.html","id":null,"dir":"Reference","previous_headings":"","what":"Negative Binomial Log-Likelihood ‚Äî nb_lik","title":"Negative Binomial Log-Likelihood ‚Äî nb_lik","text":"Computes negative log-likelihood Negative Binomial distribution.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/nb_lik.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Negative Binomial Log-Likelihood ‚Äî nb_lik","text":"","code":"nb_lik(x, mu, disp)"},{"path":"https://github.com/kaishumason/spotGLM/reference/nb_lik.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Negative Binomial Log-Likelihood ‚Äî nb_lik","text":"x Vector observed counts. mu Vector expected means. disp Dispersion parameter.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/nb_lik.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Negative Binomial Log-Likelihood ‚Äî nb_lik","text":"Negative log-likelihood value.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/poisson_lik.html","id":null,"dir":"Reference","previous_headings":"","what":"Poisson Log-Likelihood ‚Äî poisson_lik","title":"Poisson Log-Likelihood ‚Äî poisson_lik","text":"Computes negative log-likelihood Poisson distribution.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/poisson_lik.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Poisson Log-Likelihood ‚Äî poisson_lik","text":"","code":"poisson_lik(x, mu)"},{"path":"https://github.com/kaishumason/spotGLM/reference/poisson_lik.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Poisson Log-Likelihood ‚Äî poisson_lik","text":"x Vector observed counts. mu Vector predicted means (Poisson rates).","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/poisson_lik.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Poisson Log-Likelihood ‚Äî poisson_lik","text":"Negative log-likelihood value.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_merfish.html","id":null,"dir":"Reference","previous_headings":"","what":"Read MERFISH Example Data from GitHub ‚Äî read_merfish","title":"Read MERFISH Example Data from GitHub ‚Äî read_merfish","text":"Downloads loads MERFISH example data public GitHub repository. function retrieves cell type annotations, spatial region labels, gene expression count matrices (10 chunks), returns list.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_merfish.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read MERFISH Example Data from GitHub ‚Äî read_merfish","text":"","code":"read_merfish(num_chunks = 10)"},{"path":"https://github.com/kaishumason/spotGLM/reference/read_merfish.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read MERFISH Example Data from GitHub ‚Äî read_merfish","text":"num_chunks Integer 0 10. Controls many count matrix chunks download load. Defaults 10 (chunks). Use 0 skip loading counts.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_merfish.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read MERFISH Example Data from GitHub ‚Äî read_merfish","text":"named list three elements: counts matrix data frame gene expression counts (combined multiple chunks). regions vector factor region labels cell. CT vector factor cell types cell.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_merfish.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read MERFISH Example Data from GitHub ‚Äî read_merfish","text":"function requires internet connection download data https://github.com/kaishumason/SpotGLM-Example-Data. function assumes repository structure filenames consistent expected format.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_merfish.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read MERFISH Example Data from GitHub ‚Äî read_merfish","text":"","code":"if (FALSE) { # \\dontrun{ data_list <- read_merfish_data(num_chunks = 5) head(data_list$counts) table(data_list$CT) } # }"},{"path":"https://github.com/kaishumason/spotGLM/reference/read_spatial_atac.html","id":null,"dir":"Reference","previous_headings":"","what":"Read Spatial ATAC-Seq Example Data ‚Äî read_spatial_atac","title":"Read Spatial ATAC-Seq Example Data ‚Äî read_spatial_atac","text":"Loads spatial ATAC-seq data GitHub repository, including coordinates, deconvolution, region-level features, motif score matrices.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_spatial_atac.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read Spatial ATAC-Seq Example Data ‚Äî read_spatial_atac","text":"","code":"read_spatial_atac()"},{"path":"https://github.com/kaishumason/spotGLM/reference/read_spatial_atac.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read Spatial ATAC-Seq Example Data ‚Äî read_spatial_atac","text":"list containing: coords Spatial coordinates matrix. regions Matrix data frame spatial regions per spot. deconv Cell type deconvolution matrix. motif_scores Matrix motif activity scores per region.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_spatial_atac.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read Spatial ATAC-Seq Example Data ‚Äî read_spatial_atac","text":"","code":"if (FALSE) { # \\dontrun{ atac_data <- read_spatial_atac() names(atac_data) } # }"},{"path":"https://github.com/kaishumason/spotGLM/reference/read_spatial_long_read.html","id":null,"dir":"Reference","previous_headings":"","what":"Read Spatial Long-Read RNA-Seq Data ‚Äî read_spatial_long_read","title":"Read Spatial Long-Read RNA-Seq Data ‚Äî read_spatial_long_read","text":"Loads spatial long-read RNA-seq data GitHub repository. Includes coordinates, region annotations, deconvolution, library sizes, expression matrices genes isoforms.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_spatial_long_read.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read Spatial Long-Read RNA-Seq Data ‚Äî read_spatial_long_read","text":"","code":"read_spatial_long_read()"},{"path":"https://github.com/kaishumason/spotGLM/reference/read_spatial_long_read.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read Spatial Long-Read RNA-Seq Data ‚Äî read_spatial_long_read","text":"list containing: coords Matrix spatial coordinates. regions Spatial region annotations. deconv Cell type deconvolution matrix. library_size Vector library sizes per spot. total_gene_expression Matrix total gene expression. isoform_expression Matrix isoform-level expression.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_spatial_long_read.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read Spatial Long-Read RNA-Seq Data ‚Äî read_spatial_long_read","text":"","code":"if (FALSE) { # \\dontrun{ long_read_data <- read_spatial_long_read() str(long_read_data) } # }"},{"path":"https://github.com/kaishumason/spotGLM/reference/read_visium.html","id":null,"dir":"Reference","previous_headings":"","what":"Read Visium Example Data from GitHub ‚Äî read_visium","title":"Read Visium Example Data from GitHub ‚Äî read_visium","text":"Downloads loads Visium spatial transcriptomics data GitHub repository. Includes coordinates, deconvolution, effective niche covariates, library sizes, gene counts.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_visium.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read Visium Example Data from GitHub ‚Äî read_visium","text":"","code":"read_visium()"},{"path":"https://github.com/kaishumason/spotGLM/reference/read_visium.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read Visium Example Data from GitHub ‚Äî read_visium","text":"list containing: coords Matrix spatial coordinates. niche Effective niche covariate matrix. deconv Cell type deconvolution matrix. counts Gene expression count matrix. library_size Vector library sizes per spot.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_visium.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read Visium Example Data from GitHub ‚Äî read_visium","text":"","code":"if (FALSE) { # \\dontrun{ visium_data <- read_visium() str(visium_data) } # }"},{"path":"https://github.com/kaishumason/spotGLM/reference/read_visiumHD.html","id":null,"dir":"Reference","previous_headings":"","what":"Read Visium HD Example Data from GitHub ‚Äî read_visiumHD","title":"Read Visium HD Example Data from GitHub ‚Äî read_visiumHD","text":"Downloads loads spatial transcriptomics data Visium HD example dataset hosted public GitHub repository. includes spatial coordinates, gene expression counts, deconvolution results, effective niche estimates.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_visiumHD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read Visium HD Example Data from GitHub ‚Äî read_visiumHD","text":"","code":"read_visiumHD()"},{"path":"https://github.com/kaishumason/spotGLM/reference/read_visiumHD.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read Visium HD Example Data from GitHub ‚Äî read_visiumHD","text":"named list four elements: coords matrix data frame spatial coordinates (x y) spot. niche matrix, data frame, list representing effective niche composition per spot. deconv matrix data frame cell type deconvolution proportions per spot. counts gene expression count matrix (genes √ó spots).","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_visiumHD.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read Visium HD Example Data from GitHub ‚Äî read_visiumHD","text":"function requires internet connection download data https://github.com/kaishumason/SpotGLM-Example-Data. repository must contain files coords.rds, deconv_matrix.rds, count_matrix_subset.rds, niche.rds visiumHD folder.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_visiumHD.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read Visium HD Example Data from GitHub ‚Äî read_visiumHD","text":"","code":"if (FALSE) { # \\dontrun{ data_list <- read_visiumHD() head(data_list$coords) dim(data_list$counts) } # }"},{"path":"https://github.com/kaishumason/spotGLM/reference/run_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a Spatial GLM with Initialization and Optimization ‚Äî run_model","title":"Fit a Spatial GLM with Initialization and Optimization ‚Äî run_model","text":"Fits generalized linear model (GLM) spatial deconvolution single response variable (e.g., gene expression), supporting Poisson, Gaussian, Binomial, Negative Binomial families. function handles coefficient initialization, model fitting via mini-batch gradient descent, automatic coefficient filtering weak covariates poorly represented cell types.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/run_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a Spatial GLM with Initialization and Optimization ‚Äî run_model","text":"","code":"run_model(   y,   X,   lambda,   family = \"spot gaussian\",   beta_0 = NULL,   fix_coef = NULL,   offset = rep(0, length(y)),   initialization = T,   CT = NULL,   weights = rep(1, length(y)),   ct_cov_weights = rep(1, ncol(lambda)),   n_epochs = 100,   batch_size = 500,   learning_rate = 1,   max_diff = 1 - 1e-06,   improvement_threshold = 1e-06,   max_conv = 10 )"},{"path":"https://github.com/kaishumason/spotGLM/reference/run_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a Spatial GLM with Initialization and Optimization ‚Äî run_model","text":"y Numeric response vector (e.g., gene expression one gene across spots). X Covariate matrix (spots √ó covariates). lambda Deconvolution matrix (spots √ó cell types). family GLM family: \"spot gaussian\", \"spot poisson\", \"spot negative binomial\", \"spot binomial\". beta_0 Optional initial coefficient matrix (covariates √ó cell types). fix_coef Logical matrix (covariates √ó cell types) indicating coefficients fix optimization. offset Optional numeric vector (length y), used Poisson NB normalization. initialization Boolean initialization via single cell approximation performed. Default TRUE. CT Optional vector dominant cell type labels per spot. weights Observation weights (length y). ct_cov_weights Optional vector cell-type‚Äìspecific weights (length = number cell types). n_epochs Number training epochs gradient descent. batch_size Size mini-batches used gradient descent. learning_rate Initial learning rate optimization. max_diff Convergence threshold based likelihood ratio. improvement_threshold Minimum required improvement likelihood ratio epochs. max_conv Number consecutive low-improvement epochs convergence assumed.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/run_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a Spatial GLM with Initialization and Optimization ‚Äî run_model","text":"list containing: beta_estimate Estimated coefficient matrix (covariates √ó cell types). standard_error_matrix Standard error matrix coefficient. time Elapsed fitting time (seconds). disp Estimated dispersion (NB models). converged Logical indicating convergence reached. likelihood Final negative log-likelihood. vcov Variance-covariance matrix. niter Number optimization epochs completed. fixed_coef Final matrix indicating fixed coefficients.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/run_model_parallel_mac.html","id":null,"dir":"Reference","previous_headings":"","what":"Parallelized Spot-GLM Model Fitting (macOS / Linux) ‚Äî run_model_parallel_mac","title":"Parallelized Spot-GLM Model Fitting (macOS / Linux) ‚Äî run_model_parallel_mac","text":"Fits Spot-GLM model multiple responses (e.g., genes) parallel using memory-safe chunking pbmclapply, relies mclapply. available Unix-based systems.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/run_model_parallel_mac.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parallelized Spot-GLM Model Fitting (macOS / Linux) ‚Äî run_model_parallel_mac","text":"","code":"run_model_parallel_mac(   Y,   X,   lambda,   family = \"spot gaussian\",   beta_0 = NULL,   fix_coef = NULL,   initialization = T,   G = 0.1,   num_cores = 1,   offset = NULL,   CT = NULL,   weights = NULL,   ct_cov_weights = NULL,   n_epochs = 100,   batch_size = 500,   learning_rate = 1,   max_diff = 1 - 1e-06,   improvement_threshold = 1e-06,   max_conv = 10 )"},{"path":"https://github.com/kaishumason/spotGLM/reference/run_model_parallel_mac.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parallelized Spot-GLM Model Fitting (macOS / Linux) ‚Äî run_model_parallel_mac","text":"Y Response matrix (spots √ó responses). X Covariate matrix (spots √ó covariates). lambda Deconvolution matrix (spots √ó cell types). family GLM family use. One : \"spot gaussian\", \"spot poisson\", \"spot negative binomial\", \"spot binomial\". beta_0 Optional initial coefficient matrix (covariates √ó cell types). fix_coef Optional logical matrix indicating coefficients fix (dimensions beta_0). initialization Boolean initialization via single cell approximation performed. Default TRUE. G Maximum chunk size (GB) control memory usage parallelization. num_cores Number CPU cores use parallel. offset Optional numeric vector (length equal number spots). CT Optional vector dominant cell types per spot. weights Optional observation-level weight matrix (spots √ó genes). ct_cov_weights Optional cell-type-specific weight matrix (cell types √ó genes). n_epochs Number training epochs. batch_size Size mini-batch. learning_rate Initial learning rate. max_diff Convergence threshold based likelihood improvement ratio. improvement_threshold Minimum improvement ratio epochs. max_conv Number low-improvement epochs stopping.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/run_model_parallel_mac.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parallelized Spot-GLM Model Fitting (macOS / Linux) ‚Äî run_model_parallel_mac","text":"version uses pbmcapply::pbmclapply parallelism. Windows systems, please use run_spot_glm_windows.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/run_model_parallel_windows.html","id":null,"dir":"Reference","previous_headings":"","what":"Parallelized Spot-GLM Model Fitting (Windows) ‚Äî run_model_parallel_windows","title":"Parallelized Spot-GLM Model Fitting (Windows) ‚Äî run_model_parallel_windows","text":"Fits Spot-GLM model multiple response variables (e.g., genes) parallel using foreach doParallel. Optimized Windows systems mclapply available.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/run_model_parallel_windows.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parallelized Spot-GLM Model Fitting (Windows) ‚Äî run_model_parallel_windows","text":"","code":"run_model_parallel_windows(   Y,   X,   lambda,   family = \"spot\",   beta_0 = NULL,   fix_coef = NULL,   offset = NULL,   initialization = T,   G = 0.1,   num_cores = 1,   CT = NULL,   weights = NULL,   ct_cov_weights = NULL,   n_epochs = 100,   batch_size = 500,   learning_rate = 1,   max_diff = 1 - 1e-06,   improvement_threshold = 1e-06,   max_conv = 10 )"},{"path":"https://github.com/kaishumason/spotGLM/reference/run_model_parallel_windows.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parallelized Spot-GLM Model Fitting (Windows) ‚Äî run_model_parallel_windows","text":"Y Response matrix (spots √ó responses). X Covariate matrix (spots √ó covariates). lambda Deconvolution matrix (spots √ó cell types). family GLM family use. One : \"spot gaussian\", \"spot poisson\", \"spot negative binomial\", \"spot binomial\". beta_0 Optional initial coefficient matrix (covariates √ó cell types). fix_coef Optional logical matrix indicating coefficients fix (dimensions beta_0). offset Optional numeric vector (length equal number spots). initialization Boolean initialization via single cell approximation performed. Default TRUE. G Maximum chunk size (GB) control memory usage parallelization. num_cores Number CPU cores use parallel. CT Optional vector dominant cell types per spot. weights Optional observation-level weight matrix (spots √ó genes). ct_cov_weights Optional cell-type-specific weight matrix (cell types √ó genes). n_epochs Number training epochs. batch_size Size mini-batch. learning_rate Initial learning rate. max_diff Convergence threshold based likelihood improvement ratio. improvement_threshold Minimum improvement ratio epochs. max_conv Number low-improvement epochs stopping.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/run_model_parallel_windows.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parallelized Spot-GLM Model Fitting (Windows) ‚Äî run_model_parallel_windows","text":"named list model results (one per gene), containing: beta_estimate Estimated coefficients. standard_error_matrix Standard error matrix. disp Dispersion estimate (applicable). likelihood Final log-likelihood. converged Convergence status. niter Number epochs run. vcov Variance-covariance matrix. fixed_coef Final fixed coefficients matrix.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/run_model_parallel_windows.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parallelized Spot-GLM Model Fitting (Windows) ‚Äî run_model_parallel_windows","text":"function splits gene expression matrix memory-safe chunks, evaluates chunk parallel using foreach doParallel. Mac/Linux, use run_spot_glm_mac. External dependencies include Matrix, MASS, LaplacesDemon.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/run_single_cell.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Single-Cell GLM per Cell Type ‚Äî run_single_cell","title":"Run Single-Cell GLM per Cell Type ‚Äî run_single_cell","text":"Fits individual GLMs cell type using pseudo-bulked single-cell data.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/run_single_cell.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Single-Cell GLM per Cell Type ‚Äî run_single_cell","text":"","code":"run_single_cell(   y,   X,   lambda,   sc_family = \"gaussian\",   offset = rep(0, length(y)),   weights = rep(1, length(y)),   fix_coef = matrix(FALSE, ncol(X), ncol(lambda)),   CT = NULL )"},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_binomial.html","id":null,"dir":"Reference","previous_headings":"","what":"Custom GLM Object: Spot Binomial ‚Äî spot_binomial","title":"Custom GLM Object: Spot Binomial ‚Äî spot_binomial","text":"Defines Binomial-based GLM family object modeling bounded expression data proportions spatial transcriptomics. Supports deconvolution optimization logistic link functions.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_binomial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Custom GLM Object: Spot Binomial ‚Äî spot_binomial","text":"","code":"spot_binomial"},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_binomial.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Custom GLM Object: Spot Binomial ‚Äî spot_binomial","text":"list class-specific functions: link Logistic-based link inverse link functions derivatives. marginal_mu Marginal mean function (inverse logit). original_class Base GLM family used (Binomial). predict Predict probabilities X, beta, lambda. likelihood Negative log-likelihood function. grad Gradient function respect beta.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_gaussian.html","id":null,"dir":"Reference","previous_headings":"","what":"Custom GLM Object: Spot Gaussian ‚Äî spot_gaussian","title":"Custom GLM Object: Spot Gaussian ‚Äî spot_gaussian","text":"Defines Gaussian-based GLM family object spatial transcriptomics data, incorporating link functions gradient-based optimization continuous-valued expression deconvolution.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_gaussian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Custom GLM Object: Spot Gaussian ‚Äî spot_gaussian","text":"","code":"spot_gaussian"},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_gaussian.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Custom GLM Object: Spot Gaussian ‚Äî spot_gaussian","text":"list class-specific functions: link Link inverse link functions derivatives. marginal_mu Marginal mean function. original_class Base GLM family used (Gaussian). predict Predict means X, beta, lambda. likelihood Negative log-likelihood function.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_glm.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a Spatial GLM with Deconvolution ‚Äî spot_glm","title":"Fit a Spatial GLM with Deconvolution ‚Äî spot_glm","text":"Fits generalized linear model (GLM) deconvolution spatial transcriptomics data, supporting Poisson, Gaussian, Negative Binomial, Binomial families. Optimization performed via gradient descent (closed-form Gaussian).","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_glm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a Spatial GLM with Deconvolution ‚Äî spot_glm","text":"","code":"spot_glm(   X,   y,   lambda,   family,   beta_0 = matrix(0, ncol(X), ncol(lambda)),   offset = rep(0, nrow(X)),   weights = NULL,   fix_coef = matrix(FALSE, ncol(X), ncol(lambda)),   learning_rate = 0.1,   n_epochs = 50,   batch_size = 128,   max_diff = 1 - 1e-06,   improvement_threshold = 1e-06,   max_conv = 10 )"},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_glm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a Spatial GLM with Deconvolution ‚Äî spot_glm","text":"X Design matrix covariates (spots √ó covariates). y Response vector (e.g., gene expression). lambda Deconvolution matrix (spots √ó cell types). family GLM family: one \"spot poisson\", \"spot gaussian\", \"spot binomial\", \"spot negative binomial\". beta_0 Initial coefficients (matrix: covariates √ó cell types). offset Optional offset term (numeric vector). weights Optional observation-level weights. fix_coef Logical matrix indicating coefficients fix. learning_rate Initial learning rate gradient descent. n_epochs Number epochs (iterations full data). batch_size Size mini-batches gradient descent. max_diff Convergence threshold likelihood improvement ratio. improvement_threshold Minimum change ratio epochs signal progress. max_conv Number consecutive small-improvement epochs trigger convergence.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_glm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a Spatial GLM with Deconvolution ‚Äî spot_glm","text":"list : beta Estimated coefficient matrix. vcov Variance-covariance matrix estimates. dispersion Estimated dispersion (NB models). likelihood Final negative log-likelihood. converged Logical indicating convergence reached. num_epoch Number epochs used. fixed_coef Final fix coefficient matrix.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_glm_gaussian.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Gaussian Spot-GLM Solver ‚Äî spot_glm_gaussian","title":"Internal Gaussian Spot-GLM Solver ‚Äî spot_glm_gaussian","text":"Fits Gaussian GLM spatial transcriptomics data optional fixed coefficients. Used internally spot_glm family \"spot gaussian\".","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_glm_gaussian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Gaussian Spot-GLM Solver ‚Äî spot_glm_gaussian","text":"","code":"spot_glm_gaussian(X, y, lambda, fix_coef, beta_0)"},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_glm_gaussian.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Gaussian Spot-GLM Solver ‚Äî spot_glm_gaussian","text":"X Design matrix (spots √ó covariates). y Response vector. lambda Deconvolution matrix (spots √ó cell types). fix_coef Logical matrix indicating coefficients fix (TRUE = update). beta_0 Initial coefficient matrix (covariates √ó cell types).","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_glm_gaussian.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Gaussian Spot-GLM Solver ‚Äî spot_glm_gaussian","text":"list containing: beta Estimated coefficient matrix. vcov Variance-covariance matrix estimated coefficients. sigma.sq Residual variance estimate.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_lm.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit Spatial Linear Model (Spot-GLM Gaussian) ‚Äî spot_lm","title":"Fit Spatial Linear Model (Spot-GLM Gaussian) ‚Äî spot_lm","text":"Fits linear model spatial transcriptomics data using deconvolution fixed coefficients.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_lm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit Spatial Linear Model (Spot-GLM Gaussian) ‚Äî spot_lm","text":"","code":"spot_lm(y, X, lambda, big_X = NULL, fix_coef = NULL, beta_0 = NULL)"},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_lm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit Spatial Linear Model (Spot-GLM Gaussian) ‚Äî spot_lm","text":"y Response vector. X Covariate matrix (spots √ó covariates). lambda Deconvolution matrix (spots √ó cell types). big_X Optional full design matrix (covariates √ó cell types). fix_coef Logical matrix specifying coefficients fix. beta_0 Initial coefficients.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_lm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit Spatial Linear Model (Spot-GLM Gaussian) ‚Äî spot_lm","text":"list : beta Estimated coefficients. vcov Variance-covariance matrix. standard_error_matrix Standard error matrix. sigma.sq Residual variance estimate.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_negative_binomial.html","id":null,"dir":"Reference","previous_headings":"","what":"Custom GLM Object: Spot Negative Binomial ‚Äî spot_negative_binomial","title":"Custom GLM Object: Spot Negative Binomial ‚Äî spot_negative_binomial","text":"Defines Negative Binomial-based GLM family object suitable overdispersed spatial transcriptomics count data. Incorporates flexible link functions gradient computations regression coefficients dispersion parameters.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_negative_binomial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Custom GLM Object: Spot Negative Binomial ‚Äî spot_negative_binomial","text":"","code":"spot_negative_binomial"},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_negative_binomial.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Custom GLM Object: Spot Negative Binomial ‚Äî spot_negative_binomial","text":"list class-specific functions: link Negative binomial link inverse link functions derivatives. marginal_mu Marginal mean function. original_class Base GLM family used (Poisson Negative Binomial). predict Predict means X, beta, lambda. likelihood Negative log-likelihood function. grad Gradient function respect beta dispersion.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_poisson.html","id":null,"dir":"Reference","previous_headings":"","what":"Custom GLM Object: Spot Poisson ‚Äî spot_poisson","title":"Custom GLM Object: Spot Poisson ‚Äî spot_poisson","text":"Defines Poisson-based GLM family object tailored modeling spatial transcriptomics count data using deconvolution. Includes link functions, marginal mean, likelihood, gradient computation, prediction utilities.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_poisson.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Custom GLM Object: Spot Poisson ‚Äî spot_poisson","text":"","code":"spot_poisson"},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_poisson.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Custom GLM Object: Spot Poisson ‚Äî spot_poisson","text":"list class-specific functions: link Link inverse link functions derivatives. marginal_mu Marginal mean function. original_class Base GLM family used (Poisson). predict Predict means X, beta, lambda. likelihood Negative log-likelihood function. grad Gradient function respect beta.","code":""}]
