[{"path":"https://github.com/kaishumason/spotGLM/articles/Intro_to_SpotGLM.html","id":"step-1-simulating-data","dir":"Articles","previous_headings":"","what":"Step 1: Simulating Data","title":"Intro to SpotGLM","text":"use simulate data function sparrow simulate 100,000 spots 8 cell types. spot contains 2 cell types. simulate data according model Yi‚àºPois(‚àët=1TŒªi,texp(XiŒ≤t+log(1000)))Y_i \\sim Pois(\\sum_{t=1}^{T}\\lambda_{,t}\\exp(X_i\\beta^t + \\log(1000))) YiY_i response (e.g.¬†gene expression) spot ii, XiX_i covariate vector spot ii,tt denotes cell type, Œªi,t\\lambda_{,t} deconvolution estimate cell type tt spot ii, Œ≤t\\beta^t effect vector cell type tt. Note cell type gets different effect vector. Also note columns XX bounded 0 1. Bounding columns interval recommended prevent scaling issues make interpretation easier.","code":"data = sparrow::simulate_data(n = 1e5, nct = 8,family = \"poisson\",                               effect_range = c(-2,2),                               min_effect = 0.05,                               intercept_range = c(-6,-4),                               library_size = 1000, spot_ct = 2,                               p = 8,num_null = 2,prob_ct = NULL)  colnames(data$X) = paste0(\"effect_\",c(1:ncol(data$X))-1) colnames(data$X)[1] = \"intercept\"  colnames(data$lambda) = paste0(\"cell_type_\",c(1:ncol(data$lambda)))"},{"path":"https://github.com/kaishumason/spotGLM/articles/Intro_to_SpotGLM.html","id":"step-2-formulating-a-spotglm","dir":"Articles","previous_headings":"","what":"Step 2: Formulating a SpotGLM","title":"Intro to SpotGLM","text":"SpotGLM method fitting model form Ys|Xs‚àºGY_s|X_s \\sim Gùîº[Ys|Xs]=‚àëtŒªs,tF‚àí1(XsŒ≤t)\\mathbb{E}[Y_{s}|X_{s}] = \\sum_{t}\\lambda_{s,t}F^{-1}(X_{s}\\beta^t) tt index cell type Œªs,t\\lambda_{s,t} weighting cell type tt spot ss. Œ≤t\\beta^t weight vector cell type tt XsX_s covariate vector spot ss. general,specify spotGLM one needs first specify single cell level models, models used data single cell resolution. relate response spot ss cell types belong spot. example, consider single cell level generalized linear model cell iiF(ùîº[Yi|Xi])=XiŒ≤CT()F(\\mathbb{E}[Y_{}|X_{}]) = X_i\\beta^{CT()} CT()CT() cell type identity cell ii. Common formulations FF include F(x)=xF(x) = x (ordinary least squares), F(x)=log(x)F(x) = \\log(x) (poisson negative binomial regression), F(x)=logit(x)F(x) = \\text{logit}(x) (logistic regression). now let us assume using poisson negative binomial model common spatial transcriptomic data. case log(ùîº[Yi|Xi])=log(Li)+XiŒ≤CT()\\log(\\mathbb{E}[Y_{}|X_{}]) = \\log(L_i) + X_i\\beta^{CT()} LiL_i library size cell ii. Now need relate spot‚Äôs response responses cells lay spot. Accounting library size spot ss, LsL_s, can model response spot ss weighted average cells belong spot. Let LtL_t expected library size cell type tt. ThenYs|Xs‚àºPois(ùîº[Yi|Xs])Y_{s}|X_{s} \\sim Pois(\\mathbb{E}[Y_{}|X_{s}])ùîº[Ys|Xs]=‚àë:‚ààsùîº[Yi|Xs]=‚àëtns,tLtexp(XsŒ≤t)‚âàLs‚àëtœÄs,texp(XsŒ≤t)=‚àëtœÄs,texp(XsŒ≤t+log(Ls))\\mathbb{E}[Y_{s}|X_{s}] = \\sum_{:\\s}\\mathbb{E}[Y_{}|X_{s}] = \\sum_{t}n_{s,t}L_t\\exp(X_s\\beta^{t}) \\approx L_s\\sum_{t}\\pi_{s,t}\\exp(X_s\\beta^t) = \\sum_{t}\\pi_{s,t}\\exp(X_s\\beta^t + \\log(L_s)) LsL_s library size spot ss, œÄs,t\\pi_{s,t} can thought deconvolution amount cell type tt spot ss. form matches spotGLM form thus can use spotGLM package fit model.","code":""},{"path":"https://github.com/kaishumason/spotGLM/articles/Intro_to_SpotGLM.html","id":"fitting-spotglm","dir":"Articles","previous_headings":"","what":"Fitting SpotGLM","title":"Intro to SpotGLM","text":"y: vector observed response values (e.g., gene expression spatial counts). X: design matrix covariates predictors. family: description error distribution link function used model (e.g., \"spot poisson\" \"spot binomial\"). offset: poisson/negative binomial models: optional numeric vector used offset model (useful normalization exposure adjustment).Generally set log library size spot. initialization : Boolean initialization via single cell approximation performed. Default TRUE. learning_rate: learning rate used gradient descent. advised pick large value since learning rate changes dynamically throughout fitting. Default value 1. n_epochs: number epochs use fitting. Default value 50. -batch_size: Batch size use mini-batch gradient descent. Default value 128 -max_diff: Stopping criterion: change likelihood epochs less max diff, terminate fitting. Default value 1-1e-6 run_model() function returns list following elements: beta_estimate: Estimated regression coefficients. dimension #Columns X #Cell Types standard_error_matrix: Standard error matrix beta coefficients time: Time elapsed fit model. including initialization disp: dispersion parameter (negative binomial gaussian models) converged: Logical flag indicating whether optimization algorithm converged likelihood: log-likelihood fitted model vcov: variance covariance matrix beta coefficients niter: Number epochs used fixed coef: coefficients insufficient sample size expression fit case spot binomial model ran, additional weight argument must specified. weight argument standard logistic regression corresponds number trials response variable. interpretation used spot binomial model. Additionally, one knows wants set Œªs,=Cs,*WT√ó1\\lambda_{s,} = C_{s,}*W_{T \\times 1} WW vector length equal number cell types TT, one can set lambda argument equal CC set ct_cov_weights argument equal WW. case, spotGLM normalize row Œª\\lambda sum 1. can useful fitting many models serially, Œªs,=Cs,*W\\lambda_{s,} = C_{s,}*W Cs,C_{s,} change iteration (e.g.¬†deconvolution estimates) WW (e.g.¬†weighting depends relative gene expression across cell types). linear spotGLM, known ‚Äúspot gaussian‚Äù model fit, one can simply use spot_lm function. spot_lm function direct analog standard lm function R take following arguments. y: vector observed response values (e.g., gene expression spatial counts). X: design matrix covariates predictors. lambda: deconvolution matrix. fix_coef: matrix dimension beta: Estimated regression coefficients. dimension #Columns X #Cell Types standard_error_matrix: Standard error matrix. sigma.sq: Residual variance estimate. vcov: Variance-covariance matrix beta coefficients Finally, recommend scaling features range [0,1] [-1,1] possible.","code":"model = spotglm::run_model(y = data$y,X = data$X,lambda = data$lambda,                            family = \"spot poisson\",offset=rep(log(1000),                           length(data$y)),n_epochs = 100,batch_size= 500,                           learning_rate = 1,max_diff = 1-1e-6,                           initialization = T)"},{"path":[]},{"path":"https://github.com/kaishumason/spotGLM/articles/Intro_to_SpotGLM.html","id":"plotting-results","dir":"Articles","previous_headings":"Downstream Analyses","what":"Plotting Results","title":"Intro to SpotGLM","text":"","code":"plot(data$beta[-1,],model$beta_estimate[-1,]) abline(a=0,b=1,col = \"red\")"},{"path":"https://github.com/kaishumason/spotGLM/articles/Intro_to_SpotGLM.html","id":"interpretting-outputs","dir":"Articles","previous_headings":"Downstream Analyses","what":"Interpretting Outputs","title":"Intro to SpotGLM","text":"beta estimates can found via beta_estimate index. see column names correspond cell types row names correspond effect names. find estimated effect vector Œ≤t\\beta^t, one simply needs look relevant column matrix. standard error matrix gives corresponding standard errors estimated coefficient can found standard_error_matrix index. structure coefficient matrix. vcov index gives us variance covariance matrix beta coefficients. dimension (T√óp)√ó(T√óp)(T\\times p)\\times(T \\times p) TT number cell types pp number features. columns correspond coefficients traversing column wise throughout coefficient matrix. Therefore, first 9 columns variance-covariance matrix correspond first column coefficient matrix.","code":"model$beta_estimate model$standard_error_matrix model$vcov[1:9,1:9]"},{"path":"https://github.com/kaishumason/spotGLM/articles/Intro_to_SpotGLM.html","id":"assessing-significance","dir":"Articles","previous_headings":"Downstream Analyses","what":"Assessing Significance","title":"Intro to SpotGLM","text":"One can compute pvalues qvalues testing significance via compute_significance function. function takes following arguments: input_list: list spotglm outputs. element list contain list holds beta estimates standard errors. cell_type: cell type interest effect_names: effects wish assess significance cell type interest. beta_name: beta coefficient estimate matrix held element input list. Default beta_estimate standard_error_name: beta coefficient estimate matrix held element input list. Default std_error_mat sided: test one sided (1) two-sided (2) difference effects? Default value 2 direction: one sided, test positive effects(effect > 0) negative? output matrix 8 columns; name response, cell type,effect, sidedness test, direction test,test statistic,pvalue, qvalue. qvalue designed used scenarios one testing across many responses (e.g.¬†genes) interested assessing significance cell type specific effect across responses.input must list lists, example use list(model) argument. Note input list names, names replaced prefix ‚ÄúTest‚Äù. easy interpretation results suggested one name list.","code":"spotglm::compute_significance(input_list = list(model),                               cell_type = \"cell_type_1\",                               \"effect_name\" = \"effect_1\",sided = 2)"},{"path":"https://github.com/kaishumason/spotGLM/articles/Intro_to_SpotGLM.html","id":"contrasts","dir":"Articles","previous_headings":"Downstream Analyses","what":"Contrasts","title":"Intro to SpotGLM","text":"Another downstream analysis one can use contrast test. test whether Œ≤jt=Œ≤kt\\beta^{t}_j = \\beta^{t}_k cell type tt effects jj kk. One can compute pvalues qvalues testing significance via compute_contrast_significance function. function takes following arguments: input_list: list spotglm outputs. element list contain list holds beta estimates variance-covariance matrix. cell_type: cell type interest effect_names: vector length two lists effects wish compare cell type interest. beta_name: beta coefficient estimate matrix held element input list covariance_name: variance-covariance matrix beta coefficient estimate matrix held element input list. Default vcov sided: test one sided (1) two-sided (2) difference effects? Default 2. direction: one sided, test positive effects(effect 1 > effect 2) negative? output matrix 9 columns; name response, cell type,effects, sidedness test, direction test,test statistic, pvalue, qvalue.","code":"spotglm::compute_contrast_significance(input_list = list(model),                                        cell_type = \"cell_type_1\",                                        \"effect_name\" = c(\"effect_1\",\"effect_2\"),                                        sided = 2)"},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_ATAC_analysis.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Spatial ATAC Analysis","text":"vignette go typical analysis using spotGLM spatial ATAC dataset. dataset comes p22 mouse brain. dataset, identify 13 major cell types, important analysis oligodendrocytes. also given 14 distinct regions, important cortex (C0) corpus callosum (C3). reads dataset, compute motif score aggregating reads overlap various transcription factor motif signatures. goal identify changes motif signature accessibility across regions cell type specific manner.","code":""},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_ATAC_analysis.html","id":"read-data","dir":"Articles","previous_headings":"Overview","what":"Read Data","title":"Spatial ATAC Analysis","text":"coords: Coordinate matrix. dimension 9215 2 regions: one hot encoded region matrix spot. dimension 9215 14 deconv: deconvolution spot. dimension 9215 9 motif_scores: motif score spot. matrix dimension 9215 746.","code":"data = spotglm::read_spatial_atac()"},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_ATAC_analysis.html","id":"plot-of-spatial-regions","dir":"Articles","previous_headings":"Overview","what":"Plot of Spatial Regions","title":"Spatial ATAC Analysis","text":"","code":"#number of regions region = apply(data$regions,1,function(x){which(x == 1)}) n_regions <- length(unique(region))  # Create a data frame for plotting plot_df <- data.frame(   x = data$coords[, 1],   y = data$coords[, 2],   region = factor(region)  # convert to factor for discrete coloring )    ggplot(plot_df, aes(x = x, y = y, color = region)) +   geom_point(size = 2) +   scale_color_manual(values = hue_pal()(n_regions)) +   labs(title = \"Spots Colored by Region\", color = \"Region\") +   theme_minimal()"},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_ATAC_analysis.html","id":"model","dir":"Articles","previous_headings":"Overview","what":"Model","title":"Spatial ATAC Analysis","text":"Suppose single cell data. Let Yi,mY_{,m} motif score cell ii motif mm. model Yi,mY_{,m} follows Yi,m‚àºùí©(Œ≤m,riCT()+Œ≤m,0CT(),œÉm2)Y_{,m} \\sim \\mathcal{N}(\\beta^{CT()}_{m,r_i} + \\beta^{CT()}_{m,0},\\sigma_m^2) CT()CT() represents cell type cell ii rir_i represents region cell ii resides . Œ≤m,riCT()\\beta^{CT()}_{m,r_i} represents expected motif score cell type CT()CT() region rir_i. spot ss, motif score Ys,mY_{s,m} weighted average motif scores cell reside , .e Ys,m‚àºùí©(‚àëtœÄs,t(Œ≤m,rst+Œ≤m,0t),œÉm2)Y_{s,m} \\sim \\mathcal{N}( \\sum_{t}\\pi_{s,t}(\\beta^{t}_{m,r_s} + \\beta^{t}_{m,0}),\\sigma_m^2) weights cell type tt deconvolution amount cell type tt spot ss, œÄs,t\\pi_{s,t}. model can fit spotGLM. test differences motif accessibility cell type specific manner, test H0:Œ≤m,rt=Œ≤m,r‚Ä≤tH_0: \\beta^{t}_{m,r} = \\beta^{t}_{m,r'}","code":""},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_ATAC_analysis.html","id":"spotglm-of-motif-score-on-region-2-minutes","dir":"Articles","previous_headings":"Overview > Model","what":"SpotGLM of Motif Score on Region (~2 minutes)","title":"Spatial ATAC Analysis","text":"can fit model described via spot_lm function.","code":"num_motifs = ncol(data$motif_scores) res = vector(\"list\",num_motifs)  t1 = Sys.time() for(j in c(1:num_motifs)){   if(j%%100 == 0){     print(Sys.time() - t1)   }   res[[j]] = spot_lm(y = data$motif_scores[,j],X = data$regions,                      lambda = data$deconv) } names(res) = colnames(data$motif_scores)"},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_ATAC_analysis.html","id":"oligodendrocyte-differential-motif-accessibility","dir":"Articles","previous_headings":"Overview > Model","what":"Oligodendrocyte Differential Motif Accessibility","title":"Spatial ATAC Analysis","text":"can compute pvalues qvalues testing accessibility differences oligodendrocytes corpus callosum vs cortex using compute_contrast_significance() function.","code":"sig_genes = compute_contrast_significance(input_list = res,                                     cell_type = \"Oligodendrocytes\",                                     effect_names = c(\"regionC3\",\"regionC0\"),                                     beta_name = \"beta_estimate\",covariance_name = \"vcov\",                                     sided = 1,direction = \"pos\")  sig_genes = sig_genes%>%filter(!is.na(pval)) m = paste0(\"Motifs exhibiting differential accessibility in Oligodendrocytes\",            \" in corpus callosum vs cortex\") print(m) print(rownames(sig_genes)[sig_genes$qval < 0.05])"},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_ATAC_analysis.html","id":"qqplot","dir":"Articles","previous_headings":"Overview > Model","what":"QQplot","title":"Spatial ATAC Analysis","text":"","code":"#get pvalues from spotglm  pvals = sig_genes$pval P = pvals[is.na(pvals) == F] P[P>(1-1e-10)] = 1-1e-10 P[P<(1e-10)] = 1e-10  #get qvalues to color  pvals_adj = p.adjust(pvals,method=\"BH\") #convert to z-scores  zscores <- qnorm(1 - P)  # Inverse normal transformation  # Generate QQ-Plot of transformed p-values (Z-Scores) qqnorm(zscores, main= \"QQplot of pvalues\", xlab=\"\", ylab=\"\", axes=FALSE, pch=16,         col = ifelse(pvals_adj < 0.05, \"red\", \"black\")) #significant ones are red qqline(zscores, col=\"red\", lty=2)  # Add reference line  # Add surrounding box for clarity box()"},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_ATAC_analysis.html","id":"example-motif-sox4","dir":"Articles","previous_headings":"Overview > Model","what":"Example Motif: SOX4","title":"Spatial ATAC Analysis","text":"showcase example motif shows differential motif accessibility oligodendrocytes corpus callosum cortex.","code":"motif <- \"SOX4\"  # Filter spots in regionC3 or regionC0 region_filter <- data$regions[, \"regionC3\"] == 1 | data$regions[, \"regionC0\"] == 1  # Motif score with truncation Sox_score <- data$motif_scores[region_filter, motif] Sox_score <- pmin(Sox_score, quantile(Sox_score, 0.99, na.rm = TRUE)) Sox_score <- pmax(Sox_score, quantile(Sox_score, 0.01, na.rm = TRUE))  # Region labels region_label <- ifelse(data$regions[region_filter, \"regionC3\"] == 1, \"Corpus Callosum\", \"Cortex\")  # Oligodendrocyte proportion oligo_score <- data$deconv[region_filter, \"Oligodendrocytes\"]  # Create plotting data frame plot_df <- data.frame(   x = data$coords[region_filter, 1],   y = data$coords[region_filter, 2],   Sox = Sox_score,   region = region_label,   oligodendrocytes = oligo_score )  # === Plot 1: SOX4 Motif Scores === p1 <- ggplot(plot_df, aes(x = x, y = y, color = Sox)) +   geom_point(size = 2) +   scale_color_viridis_c() +   labs(title = paste0(motif, \" Motif Scores\"), color = motif) +   coord_fixed() +   theme_minimal()  # === Plot 2: Region membership === p2 <- ggplot(plot_df, aes(x = x, y = y, color = region)) +   geom_point(size = 2) +   scale_color_manual(values = c(\"Cortex\" = \"#1f78b4\", \"Corpus Callosum\" = \"#33a02c\")) +   labs(title = \"Region Membership\", color = \"Region\") +   coord_fixed() +   theme_minimal()  # === Plot 3: Oligodendrocyte proportion === p3 <- ggplot(plot_df, aes(x = x, y = y, color = oligodendrocytes)) +   geom_point(size = 2) +   scale_color_viridis_c() +   labs(title = \"Oligodendrocyte Deconvolution Proportion\", color = \"Oligos\") +   coord_fixed() +   theme_minimal()  p1 p2 p3"},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_Long_Read_analysis.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Spatial Long-Read Analysis","text":"vignette go typical analysis using spotGLM spatial long-read dataset. dataset comes mouse olfactory bulb. dataset, identify 11 major cell types;astrocytes, endothelial cells, mesenchymal cells, microglia, monocytes, mural cells, oligodendrocytes, neurons (N), olfactory ensheathing cells (OEC), oligodendrocyte progenitor cells (OPC), red blood cells. also given 5 distinct brain regions; olfactory nerve layer, glomerular layer, outer plexiform layer, mitral layer, granule layer. identify genes show evidence isoform switching cell type specific manner.","code":""},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_Long_Read_analysis.html","id":"read-in-data","dir":"Articles","previous_headings":"Overview","what":"Read in Data","title":"Spatial Long-Read Analysis","text":"coords: Coordinate matrix. dimension 918 2 niche: one hot encoded region matrix spot. dimension 918 5 deconv: deconvolution spot. dimension 918 11 library size: library size spot. vector length 918 total_gene_expression: gene, vector spot gene expression. matrix dimension 918 643 isoform expression: list element corresponding gene. isoform expression[[gene]] list length two contains spot level expression top two isoforms gene.","code":"data = spotglm::read_spatial_long_read() #filter out low deconvolutions (likely noise) data$deconv[data$deconv < 0.05] = 0 data$deconv = t(apply(data$deconv,1,function(x){x/sum(x)}))"},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_Long_Read_analysis.html","id":"plot-regions","dir":"Articles","previous_headings":"Overview","what":"Plot Regions","title":"Spatial Long-Read Analysis","text":"","code":"region = apply(data$regions,1,function(x){colnames(data$regions)[which(x == 1)]}) library(ggplot2)  df <- data.frame(   x = data$coords[, 1],   y = data$coords[, 2],   region = region )  ggplot(df, aes(x = x, y = y, color = region)) +   geom_point(size = 2) +   coord_fixed() +   theme_minimal() +   labs(title = \"Spots by Region\", color = \"Region\")"},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_Long_Read_analysis.html","id":"model-overview","dir":"Articles","previous_headings":"Overview","what":"Model Overview","title":"Spatial Long-Read Analysis","text":"return mouse olfactory bulb data. restrict analysis genes exactly two isoforms whose summed expression comprise least 20% isoforms expressed gene. limited genes total expression across spots > 50 UMIs. total, 643 genes passed two criteria. gene, identified cell types gene adequately expressed. gene gg defined adequately expressed within cell type tt total proportion transcripts belonging genegg cell type tt greater 1/60000. exact proportion found fitting SpotGLM intercept term. exact model Ys,g‚àºPois(exp(log(Ls)+‚àëtœÄs,texp(Œ≤0,gt)))Y_{s,g} \\sim Pois(\\exp(\\log(L_s) + \\sum_{t} \\pi_{s,t}\\exp(\\beta_{0,g}^t))) model, LsL_s represents library size spot ss,œÄs,t\\pi_{s,t} represents deconvolution estimate cell type tt spot ss, Œ≤0,gt\\beta_{0,g}^t represents intercept estimate cell type tt. focused cell types applied SpotGLM compare cell type-specific isoform relative expression pairs regions. SpotGLM corresponding test described follows: gene gg let isoform relative proportion isoform interest spot ss Œ≥sg\\gamma_s^g. isoform relative proportion defined ‚Ñô[UMI isoform |UMI gene isoform belongs ]\\mathbb{P}[\\text{UMI isoform |UMI gene isoform belongs }] Œ≥sg\\gamma_s^g weighted average isoform relative proportions cell types make ss cell type tt‚Äôs weight equal cell type mean expression gene gg, Œºg,t\\mu_{g,t} times proportion cell type tt spot ss, œÄs,t\\pi_{s,t}.Let Œ≥tg\\gamma_t^g isoform relative proportion cell type tt. Œ≥sg=‚àëtœÄs,tŒ≥tgŒºg,t‚àët‚Ä≤‚ààsœÄs,t‚Ä≤Œºg,t‚Ä≤\\gamma_s^g = \\frac{\\sum_{t}\\pi_{s,t}\\gamma_t^g\\mu_{g,t}}{\\sum_{t'\\s}\\pi_{s,t'}\\mu_{g,t'}} single cell level, fit cell type specific logistic regression model covariate matrix ùëã one hot encoded region cell. Yig‚àºBin(nig,Œ≥ig)Y_i^g \\sim Bin(n_{}^g, \\gamma^g_i)logit(Œ≥ig)=XiŒ≤CT(),g\\text{logit}(\\gamma^g_i) = X_i\\beta^{CT(),g} CT()CT() represents cell type cell ii. YigY_i^g represents number transcripts belong isoform interest. nign_{}^g represents total number transcripts belonging gene gg. Œ≤rt,g\\beta^{t,g}_r represents log odds event transcript belonging gene gg belongs isoform interest cell type tt region rr.Œ≤rt,g\\beta^{t,g}_r can estimated cell type specific manner spotGLM. simply weight deconvolution matrix œÄs,t\\pi_{s,t} corresponding gene weight Œºg,t\\mu_{g,t}. test cell type specific isoform switching regions rr r‚Ä≤r' cell type tt, test null hypothesis H0:Œ≤rt,g=Œ≤r‚Ä≤t,gH_0:\\beta^{t,g}_r = \\beta^{t,g}_{r'} Note models require use spotglm function run_model.","code":""},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_Long_Read_analysis.html","id":"step-1-get-average-expression-of-gene-for-each-cell-type-1-minute","dir":"Articles","previous_headings":"Overview > Model Overview","what":"Step 1: Get Average Expression of Gene For Each Cell Type (~1 minute)","title":"Spatial Long-Read Analysis","text":"first fit intercept model described .make use spotglm function ‚Äúrun_model‚Äù. specify response yy take gene expression values gene gg. covariates XX just intercept matrix. Œª\\lambda deconvolution make sure row sums sum 1. offset library size spot. initialization used TRUE since want initialize parameters. family ‚Äúspot poisson‚Äù since fitting poisson model.","code":"#get number of genes  ngenes = ncol(data$total_gene_expression) #initialize intercept estimates intercept_estimate = vector(\"list\",ngenes) names(intercept_estimate) = colnames(data$total_gene_expression) #iterate over each gene  for(j in c(1:ngenes)){   intercept_estimate[[j]]=spotglm::run_model(y = data$total_gene_expression[,j],                                              X = matrix(1,nrow(data$total_gene_expression),1),                                              lambda = data$deconv,                                              offset = log(data$library_size),                                              initialization = T,                                              family = \"spot poisson\",batch_size = 32, n_epoch = 500) }"},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_Long_Read_analysis.html","id":"step-2-spotglm-to-perform-isoform-differential-expression-1-minute","dir":"Articles","previous_headings":"Overview > Model Overview","what":"Step 2: SpotGLM to Perform Isoform Differential Expression (~1 minute)","title":"Spatial Long-Read Analysis","text":"next fit binomial spotGLM described . use ‚Äúrun model‚Äù function. time however,family ‚Äúspot binomial‚Äù since running binomial model. additionally use two parameters generally used running spotglm weights ct_cov_weights. binomial regression model, necessary weight observations number trials used. gene corresponds total gene expression vector. Additionally, unlike spot poisson model spot expression weighted mean cell type level expression weight corresponding œÄs,t\\pi_{s,t}, spot binomial model, additional cell type specific weight Œºg,t=exp(Œ≤0,gt)\\mu_{g,t} = \\exp(\\beta_{0,g}^t). can include vector ct_cov_weights argument. fit binomial model .","code":"isoform_DE = vector(\"list\",ngenes) names(isoform_DE) = colnames(data$total_gene_expression) for(j in c(1:ngenes)){   #get gene name    gene = names(isoform_DE)[j]   #get weights    weights = data$total_gene_expression[,gene]   #get covariate weights    ct_covariate_weights  = exp(intercept_estimate[[gene]]$beta_estimate)   #run model    isoform_DE[[j]] = spotglm::run_model(y = data$isoform_expression[[gene]][[1]],                                        X = data$regions,                                        lambda = data$deconv,                                        family = \"spot binomial\",                                        weights = weights,                                        ct_cov_weights = ct_covariate_weights,                                        initialization = T,batch_size = 32, n_epoch = 500) }"},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_Long_Read_analysis.html","id":"step-3-downstream-analysis-contrast-test-to-identify-isoform-switching-across-regions","dir":"Articles","previous_headings":"Overview > Model Overview","what":"Step 3: Downstream Analysis: Contrast Test to Identify Isoform Switching Across Regions","title":"Spatial Long-Read Analysis","text":"now test cell type specific isoform switching across regions. uses compute_contrast_test() function. append matrices outputted ‚Äúcompute contrast significance‚Äù function perform global BH correction. print genes show significant isoform switching.","code":"#Store all contrast tests  all_contrast_tests = list() cell_types = colnames(data$deconv) regions = colnames(data$regions) nregion = length(regions) counter = 1 #test over all cell types and region pairs  for(ct in cell_types){   for(j in c(1:nregion)){     for(k in c(j:nregion)){       if(j==k){         next       }       region_A = regions[j]       region_B = regions[k]       #compute pvalues       pvals = suppressWarnings(spotglm::compute_contrast_significance(input_list = isoform_DE,                                            cell_type = ct,                                            effect_names = c(region_A,region_B),                                            beta_name = \"beta_estimate\",                                            covariance_name = \"vcov\",                                            sided = 2))              contrast_tests = data.frame(gene = pvals$name, cell_type = ct,                                    region_A = region_A, region_B = region_B,                                    pval = pvals$pval)       #add results to list        all_contrast_tests[[counter]] = contrast_tests       counter = counter + 1     }   } } combined_contrast_tests <- dplyr::bind_rows(all_contrast_tests)%>%                                                     dplyr::filter(!is.na(pval))  #get significant switches combined_contrast_tests$qval = p.adjust(combined_contrast_tests$pval,method = \"BH\") significant_isoform_switches = combined_contrast_tests%>%filter(qval < 0.1)"},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_Long_Read_analysis.html","id":"results-of-contrast-test-as-a-table","dir":"Articles","previous_headings":"Overview > Model Overview","what":"Results of Contrast Test as a Table","title":"Spatial Long-Read Analysis","text":"","code":"head(significant_isoform_switches,10)"},{"path":"https://github.com/kaishumason/spotGLM/articles/Spatial_Long_Read_analysis.html","id":"example-gene-ap3s1","dir":"Articles","previous_headings":"Overview > Model Overview","what":"Example Gene: Ap3s1","title":"Spatial Long-Read Analysis","text":"show gene, Ap3s1, shows evidence isoform switching granule layer layers Neurons. Neurons important cell types gene, can safely just plot overall isoform relative proportion attribute differences Neurons.","code":"gene <- \"Ap3s1\"  # Isoform ratio isoform_vals <- data$isoform_expression[[gene]][[1]] gene_total <- data$total_gene_expression[, gene] ratio <- isoform_vals / gene_total ratio[!is.finite(ratio)] <- NA  # Region labels region <- apply(data$regions, 1, function(x) {   colnames(data$regions)[which(x == 1)] })  # Binary group region_group <- ifelse(region == \"regionGranule Cell Layer (GCL+RMS)\", \"Granule Layer\", \"Other\")  # Combined dataframe df <- data.frame(   x = data$coords[,1],   y = data$coords[,2],   ratio = ratio,   region = region_group ) %>% filter(!is.na(ratio))  # === Plot 1: Violin + boxplot === p1 <- ggplot(df, aes(x = region, y = ratio, fill = region)) +   geom_violin(trim = FALSE, alpha = 0.6) +   geom_boxplot(width = 0.2, outlier.shape = NA) +   theme_minimal() +   labs(     title = paste(gene, \"Isoform/Gene Ratio\"),     x = \"\", y = \"Ratio\"   ) +   scale_fill_manual(values = c(\"Granule Layer\" = \"tomato\", \"Other\" = \"skyblue\")) +   theme(legend.position = \"none\")  # === Plot 2: Spatial plot - Granule Layer only === p2 <- df %>%   filter(region == \"Granule Layer\") %>%   ggplot(aes(x = x, y = y, color = ratio)) +   geom_point(size = 2) +   scale_color_viridis_c(na.value = \"grey90\") +   coord_fixed() +   theme_minimal() +   labs(title = \"Granule Layer\", x = NULL, y = NULL, color = \"Ratio\")  # === Plot 3: Spatial plot - Other regions === p3 <- df %>%   filter(region == \"Other\") %>%   ggplot(aes(x = x, y = y, color = ratio)) +   geom_point(size = 2) +   scale_color_viridis_c(na.value = \"grey90\") +   coord_fixed() +   theme_minimal() +   labs(title = \"Other Regions\", x = NULL, y = NULL, color = \"Ratio\")   p1 p2 + p3"},{"path":"https://github.com/kaishumason/spotGLM/articles/Vignette_VisiumHD_Mouse_Kidney_analysis.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Visium Analysis","text":"vignette go analysis using 1) SPARROW submodular data selection, 2) spotGLM Visium Mouse Kidney dataset. show data preprocessing steps SPARROW spotGLM, well downstream analysis. dataset can downloaded 10X website (https://www.10xgenomics.com/datasets/visium-hd-cytassist-gene-expression-libraries--mouse-kidney). spot define niche covariate X anatomical regions. fit spotGLM identify cell type specific niche-differential genes.","code":""},{"path":"https://github.com/kaishumason/spotGLM/articles/Vignette_VisiumHD_Mouse_Kidney_analysis.html","id":"load-data","dir":"Articles","previous_headings":"Overview","what":"Load Data","title":"Visium Analysis","text":"first load data.","code":""},{"path":"https://github.com/kaishumason/spotGLM/articles/Vignette_VisiumHD_Mouse_Kidney_analysis.html","id":"reading-in-data","dir":"Articles","previous_headings":"","what":"Reading in Data","title":"Visium Analysis","text":"First read data input prepare spotGLM deconv: deconvolution spot. dimension number spots cell types EN: niche vector spot. dimension number spots kidney regions coords: Coordinate matrix. dimension number spots 2 counts: counts matrix spot--gene matrix","code":"data_dir <- \"mouse_kidney_data_input/\" # Load Deconvolution Matrix deconv = readRDS(file.path(data_dir,\"deconv_matrix.rds\")) EN = readRDS(file.path(data_dir,\"EN_covariate_matrix.rds\"))  # Prepare coordinates from 10X Output localdir <- \"mouse_kidney/data/binned_outputs/square_008um\" coords_all<-read_parquet(file.path(localdir, \"spatial/tissue_positions.parquet\"),as_data_frame = TRUE) coords_all <- as.data.frame(coords_all) rownames(coords_all)<-coords_all$barcode coord_df <- coords_all[coords_all$barcode %in% rownames(deconv),] coord_df <- coord_df[rownames(deconv),]  # Prepare count matrix from 10X Output data <- Load10X_Spatial(data.dir = localdir) count <- data@assays$Spatial$counts count <- count[, rownames(deconv)]  coords = coord_df[rownames(EN), ] counts = counts[rownames(EN), ] deconv = deconv[rownames(EN), ]"},{"path":"https://github.com/kaishumason/spotGLM/articles/Vignette_VisiumHD_Mouse_Kidney_analysis.html","id":"preprocess-data","dir":"Articles","previous_headings":"Reading in Data","what":"Preprocess data","title":"Visium Analysis","text":"filter lowly expressed genes perform SPARROW spotGLM genes enough expression","code":"# Filter Low expressed genes  gene_counts = colSums(counts) filtered_gene_counts <- gene_counts[gene_counts >= 30] filtered_gene_counts <- filtered_gene_counts[order(filtered_gene_counts,decreasing = T)] ngene = length(filtered_gene_counts) print(paste0(\"Numer of genes after filtering: \", ngene)) # Order genes based on expression best_genes = order(filtered_gene_counts,decreasing = T)[1:ngene] counts = counts[, names(filtered_gene_counts[best_genes])] # Remove rare cell types deconv[deconv < 0.1] = 0 deconv = t(apply(deconv,1,function(x){x/sum(x)})) # Get spot library sizes spot_size = rowSums(counts) # Get niche-DE covariates CT_weights = rep(1,ncol(deconv)) deconv_weighted = t(apply(deconv,1,function(x){x*CT_weights})) deconv_weighted = t(apply(deconv,1,function(x){x/sum(x)})) original_CT = colnames(deconv)  data = list() data$niche <- EN data$deconv <- deconv_weighted data$counts <- counts"},{"path":"https://github.com/kaishumason/spotGLM/articles/Vignette_VisiumHD_Mouse_Kidney_analysis.html","id":"perform-sparrow-for-submodular-data-selection","dir":"Articles","previous_headings":"Reading in Data","what":"Perform SPARROW for submodular data selection","title":"Visium Analysis","text":"","code":"cutoff = -6.5 data$library_size <- rowSums(counts)  expanded_X = sparrow::expand_covariate_matrix(X = data$niche, lambda = data$deconv,                                               family = \"negative binomial\",lib_size = rowSums(counts),                                               min_reads_per_1000 = 1000*exp(cutoff)) # Remove covariates with too many zero entries freq <- apply(expanded_X, 2, function(x) sum(x > 0) ) bad_cov <- which(freq < 30) expanded_X <- expanded_X[, -bad_cov]  target_standard_errors = sparrow::compute_target_standard_error(X = expanded_X,                                                                 min_effect = 0.05,target_power_approx = 0.99)  selected_indices = sparrow::data_selection(X = t(expanded_X),                                            max_data_size = 80000,                                            min_standard_error = target_standard_errors,                                            log = TRUE,period = 5000) selected_indices = selected_indices[is.na(selected_indices) == F] print(paste0(\"#Cells Subsampled: \", length(selected_indices)))  deconv_weighted = deconv_weighted[selected_indices,] counts = counts[selected_indices,] coords = coords[selected_indices,] spot_size = spot_size[selected_indices] EN = EN[selected_indices,]   lambda <- deconv_weighted X <- EN offset = log(spot_size)"},{"path":"https://github.com/kaishumason/spotGLM/articles/Vignette_VisiumHD_Mouse_Kidney_analysis.html","id":"initiate-beta-optional","dir":"Articles","previous_headings":"Reading in Data","what":"Initiate Beta (Optional):","title":"Visium Analysis","text":"can initialize beta coefficients first run spotGLM. want keep cell types express gene reasonable level. Therefore, beta initialization, cell types express low gene expression removed.","code":"initiate_beta <- function(Y, X, lambda, offset){   nCT = ncol(lambda)   CT_names = colnames(lambda)      # Run single cell level model   skip = TRUE   tryCatch({     single_cell_model = run_single_cell(y = Y, X = matrix(1, nrow = length(Y), ncol = 1),                                         lambda = lambda, family = \"poisson\", offset = offset)     skip = FALSE   }, error = function(e) {})      if (skip) {     return(NULL)   }      # Get t stats for each cell type   T_stats = single_cell_model$beta_est / single_cell_model$stand_err_mat      # Get which cell types express gene at a reasonable level   good_ct = which((T_stats < -1.96) & (single_cell_model$beta_est > -11))      if (length(good_ct) == 0) {     return(NULL)   }      # Remove bad cell types   lambda = lambda[, good_ct, drop = FALSE]      # Remove cell types that are rare in a spot   lambda[lambda < 0.05] = 0      # Remove bad spots (sparse spots)   bad_cells = which(rowSums(as.matrix(lambda)) < 0.05)      # Remove bad rows   if (length(bad_cells) > 0) {     X = X[-bad_cells, ]     Y = Y[-bad_cells]     lambda = as.matrix(lambda)[-bad_cells, , drop = FALSE]     offset = offset[-bad_cells]   }      # # Bind intercept   # X = cbind(1, X)   # colnames(X)[1] = \"intercept\"      # Run IRLS   # beta_0 = matrix(0, ncol(X), ncol(lambda))   beta_0 = matrix(0, ncol(X), ncol(lambda))   for(j in c(1:ncol(lambda))){     beta_0[,j] = single_cell_model$beta_est[,good_ct][j]   }      return(list(lambda, beta_0)) }"},{"path":"https://github.com/kaishumason/spotGLM/articles/Vignette_VisiumHD_Mouse_Kidney_analysis.html","id":"perform-spotglm","dir":"Articles","previous_headings":"Reading in Data","what":"Perform SpotGLM","title":"Visium Analysis","text":"now fit spotGLM model. Let XX covariate matrix iith row X, XiX_i corresponds TT dimensional effective niche vector described . spot ss, gene expression modeled sum cells make sot thus can modeled Ys,g‚àºPois(ùîº[Ys,g|Xs])Y_{s,g} \\sim Pois(\\mathbb{E}[Y_{s,g}|X_{s}])ùîº[Ys,g|Xi]=log(Ls)+‚àëtœÄs,texp(XsŒ≤gt)\\mathbb{E}[Y_{s,g}|X_{}] = \\log(L_s) + \\sum_{t} \\pi_{s,t}\\exp(X_s\\beta^{t}_g)  LsL_s library size spot ss œÄs,t\\pi_{s,t} deconvolution estimate cell type tt spot ss. model can fit using spotGLM. use ‚Äúrun model‚Äù function. function takes several arguments, important model can fit using spotGLM. , use run_model() function. model gene-specific, recommended run model parallel.","code":"family <- \"spot negative binomial\" G = 0.1 data_size = 8 * prod(dim(counts))/1e+09 #number of chunks needed nchunks = ceiling(data_size/G) chunk_size = ceiling(ncol(counts)/nchunks) grouping <- rep(1:nchunks, each = chunk_size, length.out = ncol(counts)) index_chunks = split(1:ncol(counts), grouping) chunk_counter = 1 T_1 = Sys.time() for (I in c(1:length(index_chunks))) {   t1 = Sys.time()   print(\"Initializing cluster\")   cluster <- parallel::makeCluster(5, outfile = \"\")   doParallel::registerDoParallel(cluster)   clusterExport(cluster, varlist = c(\"spot_negative_binomial\"))   print(paste0(\"Evaluating chunk \", I, \" out of \",                nchunks))   counts_chunk = as.matrix(counts[, index_chunks[[I]]])   NC = ncol(counts_chunk)   results_chunk = foreach::foreach(i = 1:NC, .export = c(\"X\", \"lambda\", \"family\",\"offset\",                                                          \"counts_chunk\")) %dopar% {                                                            if(i%%1 == 1){                                                              print(i)                                                              print(Sys.time())                                                            }                                                                                                                        print(Sys.time())                                                            Y = counts_chunk[, i]                                                            spotglm::run_model(Y,X = X, lambda = lambda,family = family, offset = offset,learning_rate = 0.1, batch_size = 128,n_epoch = 250)                                                          }   if (chunk_counter == 1) {     results = results_chunk   }   else {     results = c(results, results_chunk)   }   rm(counts_chunk)   gc()   chunk_counter = chunk_counter + 1   print(\"Closing cluster\")   parallel::stopCluster(cluster)   print(paste0(\"Chunk took \",Sys.time() - t1)) } names(results) = colnames(counts) T_2 = Sys.time()"},{"path":"https://github.com/kaishumason/spotGLM/articles/Vignette_VisiumHD_Mouse_Kidney_analysis.html","id":"downstream-analysis-determining-niche-differential-marker-genes","dir":"Articles","previous_headings":"Reading in Data > Perform SpotGLM","what":"Downstream Analysis: Determining Niche Differential Marker Genes","title":"Visium Analysis","text":"perform contrast test see gene niche-marker gene. niche marker gene cell type tt one Œ≤n1,gt‚â†Œ≤n2,gt\\beta^{t}_{n_1,g} \\neq \\beta^{t}_{n_2,g} can differentiate whether cell type tt near niche enriched niche1 n1n_1 niche n2n_2 looking gene expression gene gg. can using compute_contrast_significance() function. finding niche marker genes Endothelial cells near Papilla region vs Cortex region. set side = 1 direction = ‚Äúpos‚Äù genes correspond upregulated Endothelial cells Papilla region versus Cortex region.","code":"contrast_test_1 <- c(\"Endothelial cells\", \".data_Papilla\" , \".data_Cortex\") index <- contrast_test_1[1] niche1 <- contrast_test_1[2] niche2 <- contrast_test_1[3]  print(paste0(\"Index celltype is \", index, \", niche 1: \", niche1, \"; niche 2: \", niche2)) sig_genes = compute_contrast_significance(input_list = results,                                           cell_type = index,                                           effect_names = c(niche1, niche2),                                           beta_name = \"beta_estimate\",covariance_name = \"vcov\",                                           sided = 1,direction = \"pos\") sig_genes = sig_genes%>%dplyr::filter(!is.na(pval))"},{"path":"https://github.com/kaishumason/spotGLM/articles/Vignette_VisiumHD_Mouse_Kidney_analysis.html","id":"plots","dir":"Articles","previous_headings":"Reading in Data > Perform SpotGLM","what":"Plots","title":"Visium Analysis","text":"visualize set genes upregulated cell type tt (e.g.¬†Endothelial cells) region 1 n1n_1 versus region 2 n2n_2, (e.g.¬†Papilla region versus Cortex region) QQ plot.","code":"library(ggrepel)  sig_genes_df <- sig_genes[order(sig_genes$test_statistic, decreasing = TRUE), ] sig_genes_df$gene <- rownames(sig_genes_df)  qq <- qqnorm(sig_genes_df$test_statistic, plot.it = FALSE) sig_genes_df$theoretical <- qq$x  # theoretical quantiles sig_genes_df$sample <- qq$y       # sample quantiles mean(qq$x, na.rm=TRUE) var(qq$x, na.rm=TRUE) # Compute the slope and intercept for the QQ line q1_sample <- quantile(sig_genes_df$test_statistic, 0.25, na.rm=TRUE) q3_sample <- quantile(sig_genes_df$test_statistic, 0.75, na.rm=TRUE) q1_theor  <- qnorm(0.25) q3_theor  <- qnorm(0.75) slope     <- (q3_sample - q1_sample) / (q3_theor - q1_theor) intercept <- q1_sample - slope * q1_theor  # Select the top genes by highest t_test_stat top_n <- 35 top_df <- sig_genes_df[order(sig_genes_df$test_statistic, decreasing = TRUE)[1:top_n], ] # Create the QQ plot using ggplot2 with ggrepel for labeled boxes p <- ggplot(sig_genes_df, aes(x = theoretical, y = sample)) +   geom_point() +   geom_abline(intercept = intercept, slope = slope, color = \"red\", size = 1) +   geom_label_repel(data = top_df, aes(label = gene),                    box.padding = 0.35, point.padding = 0.5, # size = 10,                     segment.color = \"grey50\", max.overlaps = 50) +   labs(x = \"Theoretical Quantiles\",         y = \"Sample Quantiles\",         title = paste0(index, \": \", str_replace(niche1, \".data_\", \"\"), \" vs.\", str_replace(niche2, \".data_\", \"\"))) +   theme_minimal() +   theme(plot.title = element_text(face = \"bold\", hjust = 0.5)) print(p)"},{"path":"https://github.com/kaishumason/spotGLM/articles/Visium_analysis.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Visium Analysis","text":"vignette go typical analysis using spotGLM Visium dataset. dataset comes liver colorectal cancer patient. dataset, identify 6 major cell types, hepatocytes, macrophages/myeloid, fibroblasts/stromal, two subclones tumor found via clonalscope. spot summarize neighborhood/niche computing weighted sum deconvolutions closer spots weight. fit spotGLM identify cell type specific niche-differential genes.","code":""},{"path":"https://github.com/kaishumason/spotGLM/articles/Visium_analysis.html","id":"load-data","dir":"Articles","previous_headings":"Overview","what":"Load Data","title":"Visium Analysis","text":"first load data.","code":""},{"path":"https://github.com/kaishumason/spotGLM/articles/Visium_analysis.html","id":"reading-in-data","dir":"Articles","previous_headings":"","what":"Reading in Data","title":"Visium Analysis","text":"First read merfish data using function ‚Äòread merfish‚Äô. functions returns list following coords: Coordinate matrix. dimension 3826 2 niche: niche vector spot. dimension 3826 7 deconv: deconvolution spot. dimension 3826 7 counts: counts matrix 2000 genes. dimension 3826 2000 library size: library size spot. vector length 3826","code":"data = spotglm::read_visium()"},{"path":"https://github.com/kaishumason/spotGLM/articles/Visium_analysis.html","id":"example-of-covariate","dir":"Articles","previous_headings":"Reading in Data","what":"Example of Covariate","title":"Visium Analysis","text":"summarize spot‚Äôs niche vector length TT TT number cell types sample. covariate called effective niche.Without going much detail, larger covariate, corresponding cell type neighborhood spot. example, see tumor subclone 1 niche covariate high regions tumor deconvolution also high.","code":"# Prepare data for plotting plot_df_deconv <- data.frame(   x = data$coords[, 1],   y = data$coords[, 2],   subclone_1 = data$deconv[, \"subclone_1\"] )  plot_df_niche <- data.frame(   x = data$coords[, 1],   y = data$coords[, 2],   subclone_1 = data$niche[, \"subclone_1\"] )  # Plot 1: deconv p1 <- ggplot(plot_df_deconv, aes(x = x, y = y, color = subclone_1)) +   geom_point(size = 2) +   scale_color_viridis_c() +   labs(title = \"Deconvolution - Subclone 1\", color = \"Subclone 1\") +   theme_minimal()  # Plot 2: niche p2 <- ggplot(plot_df_niche, aes(x = x, y = y, color = subclone_1)) +   geom_point(size = 2) +   scale_color_viridis_c() +   labs(title = \"Niche Covariate - Subclone 1\", color = \"Subclone 1\") +   theme_minimal()  # Display side by side p1 + p2"},{"path":"https://github.com/kaishumason/spotGLM/articles/Visium_analysis.html","id":"perform-spotglm-approx-10-minutes","dir":"Articles","previous_headings":"Reading in Data","what":"Perform SpotGLM (Approx 10 minutes)","title":"Visium Analysis","text":"now fit spotGLM model. Let XX covariate matrix iith row X, XiX_i corresponds TT dimensional effective niche vector described . single cell glm model cell type Yi,g‚àºPois(ùîº[Yi,g|Xi])Y_{,g} \\sim Pois(\\mathbb{E}[Y_{,g}|X_{}])log(ùîº[Yi,g|Xi])=XiŒ≤gCT()+log(Li)\\log(\\mathbb{E}[Y_{,g}|X_{}]) = X_i\\beta^{CT()}_g + \\log(L_i) LiL_i library size cell ii, CT()CT() cell type assignment cell ii Œ≤gCT()\\beta^{CT()}_g vector dimension T√ó1T \\times 1 acts weight vector cells type CT()CT() gene gg. index Œ≤gCT()\\beta^{CT()}_g, Œ≤t‚Ä≤,gCT()\\beta^{CT()}_{t',g} equal 0, amount cell t‚Ä≤t' niche affects expression gene gg cells type CT()CT(). called (CT(),t‚Äô) niche differential gene. spot ss, gene expression modeled sum cells make sot thus can modeled Ys,g‚àºPois(ùîº[Ys,g|Xs])Y_{s,g} \\sim Pois(\\mathbb{E}[Y_{s,g}|X_{s}])ùîº[Ys,g|Xi]=log(Ls)+‚àëtœÄs,texp(XsŒ≤gt)\\mathbb{E}[Y_{s,g}|X_{}] = \\log(L_s) + \\sum_{t} \\pi_{s,t}\\exp(X_s\\beta^{t}_g)  LsL_s library size spot ss œÄs,t\\pi_{s,t} deconvolution estimate cell type tt spot ss. model can fit using spotGLM. use ‚Äúrun model‚Äù function. function takes several arguments, important model can fit using spotGLM. , use run_model() function.","code":"num_genes = ncol(data$counts) res = vector(\"list\",num_genes) t1 = Sys.time() #run spotGLM for each gene for(j in c(1:num_genes)){   if(j%%500 == 0){     print(j)     print(Sys.time() - t1)   }   res[[j]] = spotglm::run_model(y = data$counts[,j],X = data$niche, lambda = data$deconv,                              family = \"spot poisson\",offset = log(data$library_size),                              initialization = T,batch_size = 250) } names(res) = colnames(data$counts)"},{"path":"https://github.com/kaishumason/spotGLM/articles/Visium_analysis.html","id":"downstream-analysis-determining-niche-differential-genes","dir":"Articles","previous_headings":"Reading in Data > Perform SpotGLM (Approx 10 minutes)","what":"Downstream Analysis: Determining Niche Differential Genes","title":"Visium Analysis","text":"fitting spotGLM can evaluate genes (t,t‚Äô) niche differential. case get pvalues/qvalues testing genes (fibroblast,subclone 1) niche differential. can using compute_significance() function. set side = 1 direction = ‚Äúpos‚Äù niche differential genes correspond upregulated fibroblasts presence tumor subclone 1.","code":"#get significant genes sig_genes = compute_significance(input_list = res,cell_type = \"stromal\",                                  effect_name = \"subclone_1\",                                  beta_name = \"beta_estimate\",                                  standard_error_name = \"standard_error_matrix\",                                  sided = 1,direction = \"pos\") sig_genes = sig_genes%>%filter(!is.na(pval)) print(\"The following genes are (fibroblast,tumor subclone 1) niche differential\") print(rownames(sig_genes)[sig_genes$qval < 0.05])"},{"path":"https://github.com/kaishumason/spotGLM/articles/Visium_analysis.html","id":"downstream-analysis-determining-niche-differential-marker-genes","dir":"Articles","previous_headings":"Reading in Data > Perform SpotGLM (Approx 10 minutes)","what":"Downstream Analysis: Determining Niche Differential Marker Genes","title":"Visium Analysis","text":"can also perform contrast test see gene niche-marker gene. niche marker gene cell type tt one Œ≤t1,gt‚â†Œ≤t2,gt\\beta^{t}_{t_1,g} \\neq \\beta^{t}_{t_2,g} can differentiate whether cell type tt near niche enriched cell type t1t_1 cell type t2t_2 looking gene expression gene gg. can using compute_contrast_significance() function. finding niche marker genes fibroblasts near tumor subclone 1 vs tumor subclone 2. set side = 1 direction = ‚Äúpos‚Äù genes correspond upregulated fibroblasts presence tumor subclone 1 vs near tumor subclone 2.","code":"#compute contrast test sig_genes = compute_contrast_significance(input_list = res,                                     cell_type = \"stromal\",                                     effect_names = c(\"subclone_1\",\"subclone_2\"),                                beta_name = \"beta_estimate\",covariance_name = \"vcov\",                                sided = 1,direction = \"pos\") sig_genes = sig_genes%>%filter(!is.na(pval)) m = paste0(\"The following genes are niche marker genes for fibroblasts near\",             \" tumor sublcone 1 vs tumor subclone 2\") print(m) print(rownames(sig_genes)[sig_genes$qval < 0.05])"},{"path":"https://github.com/kaishumason/spotGLM/articles/Visium_analysis.html","id":"plots","dir":"Articles","previous_headings":"Reading in Data > Perform SpotGLM (Approx 10 minutes)","what":"Plots","title":"Visium Analysis","text":"Note ISG15 (fibroblast,subclone 1) niche differential gene well niche marker gene. plot expression ISG15 see visually. fibroblasts subclone 2 niche express much less ISG15 subclone 1 niche. Additionally, non tumor region (‚Äú) shows little expression ISG15. Note COL4A1 (fibroblast,subclone 1) niche differential gene niche marker gene. plot expression COL4A1 see visually.","code":"gene <- \"ISG15\"  # Expression clipping expression <- data$counts[, gene] expression <- pmax(expression, quantile(expression, 0.05)) expression <- pmin(expression, quantile(expression, 0.95))  #deconvolution clipping deconv_prop = data$deconv[, \"stromal\"] deconv_prop = pmax(deconv_prop , quantile(deconv_prop , 0.01)) deconv_prop = pmin(deconv_prop , quantile(deconv_prop , 0.99))  # === Plot 1: ISG15 Expression === df1 <- data.frame(   x = data$coords[, 1],   y = data$coords[, 2],   gene = expression )  p1 <- ggplot(df1, aes(x = x, y = y, color = gene)) +   geom_point(size = 2) +   scale_color_viridis_c() +   coord_fixed() +   theme_minimal() +   labs(     title = paste0(gene, \" Expression\"),     x = \"X\", y = \"Y\", color = gene   )  # === Plot 2: Majority subclones === majority_subclone <- colnames(data$deconv)[max.col(data$deconv,                                                    ties.method = \"first\")]  df2 <- data.frame(   x = data$coords[, 1],   y = data$coords[, 2],   majority = majority_subclone )  df2$highlight <- case_when(   df2$majority == \"subclone_1\" ~ \"subclone_1\",   df2$majority == \"subclone_2\" ~ \"subclone_2\",   TRUE ~ \"other\" )  p2 <- ggplot(df2, aes(x = x, y = y, color = highlight)) +   geom_point(size = 2) +   scale_color_manual(     values = c(       \"subclone_1\" = \"red\",       \"subclone_2\" = \"blue\",       \"other\" = \"grey80\"     )   ) +   coord_fixed() +   theme_minimal() +   labs(title = \"Majority Subclone Regions\", color = \"Majority Subclone\")  # === Plot 3: Stromal proportions === df3 <- data.frame(   x = data$coords[, 1],   y = data$coords[, 2],   stromal = deconv_prop )  p3 <- ggplot(df3, aes(x = x, y = y, color = stromal)) +   geom_point(size = 2) +   scale_color_viridis_c() +   coord_fixed() +   theme_minimal() +   labs(title = \"Stromal Proportion\", color = \"Stromal\")  # === Combine all plots === p1 p2 p3 gene <- \"COL4A1\"  # Expression clipping expression <- data$counts[, gene] expression <- pmax(expression, quantile(expression, 0.05)) expression <- pmin(expression, quantile(expression, 0.95))  #deconvolution clipping deconv_prop = data$deconv[, \"stromal\"] deconv_prop = pmax(deconv_prop , quantile(deconv_prop , 0.01)) deconv_prop = pmin(deconv_prop , quantile(deconv_prop , 0.99))  # === Plot 1: ISG15 Expression === df1 <- data.frame(   x = data$coords[, 1],   y = data$coords[, 2],   gene = expression )  p1 <- ggplot(df1, aes(x = x, y = y, color = gene)) +   geom_point(size = 2) +   scale_color_viridis_c() +   coord_fixed() +   theme_minimal() +   labs(     title = paste0(gene, \" Expression\"),     x = \"X\", y = \"Y\", color = gene   )  # === Plot 2: Majority subclones === majority_subclone <- colnames(data$deconv)[max.col(data$deconv,                                                    ties.method = \"first\")]  df2 <- data.frame(   x = data$coords[, 1],   y = data$coords[, 2],   majority = majority_subclone )  df2$highlight <- case_when(   df2$majority == \"subclone_1\" ~ \"subclone_1\",   df2$majority == \"subclone_2\" ~ \"subclone_2\",   TRUE ~ \"other\" )  p2 <- ggplot(df2, aes(x = x, y = y, color = highlight)) +   geom_point(size = 2) +   scale_color_manual(     values = c(       \"subclone_1\" = \"red\",       \"subclone_2\" = \"blue\",       \"other\" = \"grey80\"     )   ) +   coord_fixed() +   theme_minimal() +   labs(title = \"Majority Subclone Regions\", color = \"Majority Subclone\")  # === Plot 3: Stromal proportions === df3 <- data.frame(   x = data$coords[, 1],   y = data$coords[, 2],   stromal = deconv_prop )  p3 <- ggplot(df3, aes(x = x, y = y, color = stromal)) +   geom_point(size = 2) +   scale_color_viridis_c() +   coord_fixed() +   theme_minimal() +   labs(title = \"Stromal Proportion\", color = \"Stromal\")  # === Combine all plots === p1 p2 p3"},{"path":"https://github.com/kaishumason/spotGLM/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Kaishu Mason. Author. Yijia Jiang. Author. Nancy R. Zhang. Author, maintainer.","code":""},{"path":"https://github.com/kaishumason/spotGLM/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Mason K, Jiang Y, Zhang N (2025). spotGLM: SpotGLM. R package version 0.1.0, https://github.com/kaishumason/spotGLM.","code":"@Manual{,   title = {spotGLM: SpotGLM},   author = {Kaishu Mason and Yijia Jiang and Nancy R. Zhang},   year = {2025},   note = {R package version 0.1.0},   url = {https://github.com/kaishumason/spotGLM}, }"},{"path":"https://github.com/kaishumason/spotGLM/index.html","id":"spotglm","dir":"","previous_headings":"","what":"SpotGLM: Cell-Type-Specific Differential Testing for Spatial Omics Data","title":"SpotGLM: Cell-Type-Specific Differential Testing for Spatial Omics Data","text":"SpotGLM R package performing cell type-specific differential analysis spatial omics data. adapts different data modalities, gene expression, chromatin accessibility, isoform usage, identifies cell type specific changes associated local tissue context. SpotGLM accounts mixed-cell composition inherent spatial barcoding technologies. improved speed scalability, SpotGLM can paired SPARROW package, selects power-preserving subset spatial spots efficient downstream analysis without sacrificing power.","code":""},{"path":"https://github.com/kaishumason/spotGLM/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"SpotGLM: Cell-Type-Specific Differential Testing for Spatial Omics Data","text":"install SpotGLM GitHub:","code":"install.packages(\"devtools\") devtools::install_github(\"kaishumason/SpotGLM\") # install"},{"path":"https://github.com/kaishumason/spotGLM/index.html","id":"getting-started","dir":"","previous_headings":"","what":"Getting Started","title":"SpotGLM: Cell-Type-Specific Differential Testing for Spatial Omics Data","text":"Please follow tutorials get started data: Introduction SpotGLM Using SpotGLM SPARROW Visium HD Another example Visium HD Analysis SpotGLM isoform switching analysis spatial long read data SpotGLM spatial ATAC analysis","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/binomial_lik.html","id":null,"dir":"Reference","previous_headings":"","what":"Binomial Log-Likelihood ‚Äî binomial_lik","title":"Binomial Log-Likelihood ‚Äî binomial_lik","text":"Computes negative log-likelihood Binomial distribution.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/binomial_lik.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Binomial Log-Likelihood ‚Äî binomial_lik","text":"","code":"binomial_lik(x, mu, num_obs)"},{"path":"https://github.com/kaishumason/spotGLM/reference/binomial_lik.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Binomial Log-Likelihood ‚Äî binomial_lik","text":"x Vector observed successes. mu Vector predicted probabilities. num_obs Number trials observation.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/binomial_lik.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Binomial Log-Likelihood ‚Äî binomial_lik","text":"Negative log-likelihood value.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_contrast.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute P-values for Pairwise Contrasts ‚Äî compute_contrast","title":"Compute P-values for Pairwise Contrasts ‚Äî compute_contrast","text":"Computes Z-scores p-values contrasts two covariates within single cell type.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_contrast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute P-values for Pairwise Contrasts ‚Äî compute_contrast","text":"","code":"compute_contrast(   input_list,   cell_type,   effect_names,   beta_name = \"beta_estimate\",   covariance_name = \"vcov\",   sided = 2,   direction = \"pos\" )"},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_contrast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute P-values for Pairwise Contrasts ‚Äî compute_contrast","text":"input_list list model outputs beta covariance matrices. cell_type Character. Cell type interest. effect_names Character vector length 2 indicating two covariates contrast. beta_name Name beta matrix model output (default: \"beta_estimate\"). covariance_name Name covariance matrix model output (default: \"vcov\"). sided Integer. 1 one-sided, 2 two-sided test. direction Character. \"pos\" \"neg\", used sided = 1.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_contrast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute P-values for Pairwise Contrasts ‚Äî compute_contrast","text":"named list p-values model input list.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_contrast_significance.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Significance for Pairwise Covariate Contrast ‚Äî compute_contrast_significance","title":"Compute Significance for Pairwise Covariate Contrast ‚Äî compute_contrast_significance","text":"Calculates p-values adjusted q-values contrasts two effects within specific cell type.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_contrast_significance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Significance for Pairwise Covariate Contrast ‚Äî compute_contrast_significance","text":"","code":"compute_contrast_significance(   input_list,   cell_type,   effect_names,   beta_name = \"beta_estimate\",   covariance_name = \"vcov\",   sided = 2,   direction = \"pos\" )"},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_contrast_significance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Significance for Pairwise Covariate Contrast ‚Äî compute_contrast_significance","text":"input_list list model outputs beta covariance matrices. cell_type Character. Cell type interest. effect_names Character vector length 2 indicating covariates contrast. beta_name Name beta matrix (default: \"beta_estimate\"). covariance_name Name covariance matrix (default: \"vcov\"). sided Integer. 1 one-sided, 2 two-sided test. direction Character. \"pos\" \"neg\", used sided = 1.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_contrast_significance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Significance for Pairwise Covariate Contrast ‚Äî compute_contrast_significance","text":"data frame columns: name, pval, qval.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_pvals.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute P-values for Single Covariate ‚Äî compute_pvals","title":"Compute P-values for Single Covariate ‚Äî compute_pvals","text":"Computes Z-scores p-values single covariate specific cell type.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_pvals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute P-values for Single Covariate ‚Äî compute_pvals","text":"","code":"compute_pvals(   input_list,   cell_type,   effect_name,   beta_name = \"beta_estimate\",   standard_error_name = \"standard_error_matrix\",   sided = 2,   direction = \"pos\" )"},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_pvals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute P-values for Single Covariate ‚Äî compute_pvals","text":"input_list list model outputs beta standard error matrices. cell_type Character. Cell type interest. effect_name Character. Name covariate/effect interest. beta_name Name beta matrix model output (default: \"beta_estimate\"). standard_error_name Name standard error matrix (default: \"standard_error_matrix\"). sided Integer. 1 one-sided, 2 two-sided test. direction Character. \"pos\" \"neg\", used sided = 1.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_pvals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute P-values for Single Covariate ‚Äî compute_pvals","text":"named list p-values model input list.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_qvals.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Q-values from P-value List ‚Äî compute_qvals","title":"Compute Q-values from P-value List ‚Äî compute_qvals","text":"Applies Benjamini-Hochberg correction across list p-value vectors reconstructs q-values structure.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_qvals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Q-values from P-value List ‚Äî compute_qvals","text":"","code":"compute_qvals(pval_list)"},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_qvals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Q-values from P-value List ‚Äî compute_qvals","text":"pval_list named list numeric vectors containing p-values.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_qvals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Q-values from P-value List ‚Äî compute_qvals","text":"named list numeric vectors q-values corresponding input p-values.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_significance.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Significance for a Single Covariate ‚Äî compute_significance","title":"Compute Significance for a Single Covariate ‚Äî compute_significance","text":"Calculates p-values adjusted q-values given effect specific cell type.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_significance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Significance for a Single Covariate ‚Äî compute_significance","text":"","code":"compute_significance(   input_list,   cell_type,   effect_name,   beta_name = \"beta_estimate\",   standard_error_name = \"standard_error_matrix\",   sided = 2,   direction = \"pos\" )"},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_significance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Significance for a Single Covariate ‚Äî compute_significance","text":"input_list list model outputs beta standard error matrices. cell_type Character. Cell type interest. effect_name Character. Name covariate/effect interest. beta_name Name beta matrix (default: \"beta_estimate\"). standard_error_name Name standard error matrix (default: \"standard_error_matrix\"). sided Integer. 1 one-sided, 2 two-sided test. direction Character. \"pos\" \"neg\", used sided = 1.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_significance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Significance for a Single Covariate ‚Äî compute_significance","text":"data frame columns: name, pval, qval.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_standard_errors.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Standard Errors via Fisher Information ‚Äî compute_standard_errors","title":"Compute Standard Errors via Fisher Information ‚Äî compute_standard_errors","text":"Computes variance-covariance matrix estimates Fisher Information Matrix.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/compute_standard_errors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Standard Errors via Fisher Information ‚Äî compute_standard_errors","text":"","code":"compute_standard_errors(   X,   y,   lambda,   family,   beta,   good_beta,   dispersion,   weights,   offset )"},{"path":"https://github.com/kaishumason/spotGLM/reference/gaussian_lik.html","id":null,"dir":"Reference","previous_headings":"","what":"Gaussian Log-Likelihood ‚Äî gaussian_lik","title":"Gaussian Log-Likelihood ‚Äî gaussian_lik","text":"Computes negative log-likelihood Gaussian distribution.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/gaussian_lik.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gaussian Log-Likelihood ‚Äî gaussian_lik","text":"","code":"gaussian_lik(x, mu, sigma)"},{"path":"https://github.com/kaishumason/spotGLM/reference/gaussian_lik.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gaussian Log-Likelihood ‚Äî gaussian_lik","text":"x Vector observed values. mu Vector predicted means. sigma Standard deviation.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/gaussian_lik.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gaussian Log-Likelihood ‚Äî gaussian_lik","text":"Negative log-likelihood value.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/glm_fisher.html","id":null,"dir":"Reference","previous_headings":"","what":"Fisher Information Matrix for Spot-GLM ‚Äî glm_fisher","title":"Fisher Information Matrix for Spot-GLM ‚Äî glm_fisher","text":"Computes Fisher Information matrix given GLM family model.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/glm_fisher.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fisher Information Matrix for Spot-GLM ‚Äî glm_fisher","text":"","code":"glm_fisher(   X,   y,   lambda,   family,   beta,   good_beta,   dispersion,   weights = NULL,   offset = rep(0, length(y)) )"},{"path":"https://github.com/kaishumason/spotGLM/reference/gradient_descent_update.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Gradient Descent Updates for Spot-GLM ‚Äî gradient_descent_update","title":"Compute Gradient Descent Updates for Spot-GLM ‚Äî gradient_descent_update","text":"Computes gradients negative log-likelihood supported GLM families.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/gradient_descent_update.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Gradient Descent Updates for Spot-GLM ‚Äî gradient_descent_update","text":"","code":"gradient_descent_update(   family,   X,   y,   beta,   lambda,   offset,   disp = 1e+08,   weights = rep(1, length(y)) )"},{"path":"https://github.com/kaishumason/spotGLM/reference/hello.html","id":null,"dir":"Reference","previous_headings":"","what":"Hello, World! ‚Äî hello","title":"Hello, World! ‚Äî hello","text":"Prints 'Hello, world!'.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/hello.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hello, World! ‚Äî hello","text":"","code":"hello()"},{"path":"https://github.com/kaishumason/spotGLM/reference/hello.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hello, World! ‚Äî hello","text":"","code":"hello() #> Error in hello(): could not find function \"hello\""},{"path":"https://github.com/kaishumason/spotGLM/reference/initialize_fix_coef.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialize Fixed Coefficient Matrix ‚Äî initialize_fix_coef","title":"Initialize Fixed Coefficient Matrix ‚Äî initialize_fix_coef","text":"Automatically sets coefficients fix based low signal coverage.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/initialize_fix_coef.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialize Fixed Coefficient Matrix ‚Äî initialize_fix_coef","text":"","code":"initialize_fix_coef(   X,   lambda,   fix_coef = matrix(FALSE, ncol(X), ncol(lambda)),   weights = NULL,   min_deconv = 0.1,   min_freq = 100 )"},{"path":"https://github.com/kaishumason/spotGLM/reference/nb_lik.html","id":null,"dir":"Reference","previous_headings":"","what":"Negative Binomial Log-Likelihood ‚Äî nb_lik","title":"Negative Binomial Log-Likelihood ‚Äî nb_lik","text":"Computes negative log-likelihood Negative Binomial distribution.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/nb_lik.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Negative Binomial Log-Likelihood ‚Äî nb_lik","text":"","code":"nb_lik(x, mu, disp)"},{"path":"https://github.com/kaishumason/spotGLM/reference/nb_lik.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Negative Binomial Log-Likelihood ‚Äî nb_lik","text":"x Vector observed counts. mu Vector expected means. disp Dispersion parameter.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/nb_lik.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Negative Binomial Log-Likelihood ‚Äî nb_lik","text":"Negative log-likelihood value.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/poisson_lik.html","id":null,"dir":"Reference","previous_headings":"","what":"Poisson Log-Likelihood ‚Äî poisson_lik","title":"Poisson Log-Likelihood ‚Äî poisson_lik","text":"Computes negative log-likelihood Poisson distribution.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/poisson_lik.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Poisson Log-Likelihood ‚Äî poisson_lik","text":"","code":"poisson_lik(x, mu)"},{"path":"https://github.com/kaishumason/spotGLM/reference/poisson_lik.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Poisson Log-Likelihood ‚Äî poisson_lik","text":"x Vector observed counts. mu Vector predicted means (Poisson rates).","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/poisson_lik.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Poisson Log-Likelihood ‚Äî poisson_lik","text":"Negative log-likelihood value.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_merfish.html","id":null,"dir":"Reference","previous_headings":"","what":"Read MERFISH Example Data from GitHub ‚Äî read_merfish","title":"Read MERFISH Example Data from GitHub ‚Äî read_merfish","text":"Downloads loads MERFISH example data public GitHub repository. function retrieves cell type annotations, spatial region labels, gene expression count matrices (10 chunks), returns list.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_merfish.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read MERFISH Example Data from GitHub ‚Äî read_merfish","text":"","code":"read_merfish(num_chunks = 10)"},{"path":"https://github.com/kaishumason/spotGLM/reference/read_merfish.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read MERFISH Example Data from GitHub ‚Äî read_merfish","text":"num_chunks Integer 0 10. Controls many count matrix chunks download load. Defaults 10 (chunks). Use 0 skip loading counts.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_merfish.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read MERFISH Example Data from GitHub ‚Äî read_merfish","text":"named list three elements: counts matrix data frame gene expression counts (combined multiple chunks). regions vector factor region labels cell. CT vector factor cell types cell.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_merfish.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read MERFISH Example Data from GitHub ‚Äî read_merfish","text":"function requires internet connection download data https://github.com/kaishumason/SpotGLM-Example-Data. function assumes repository structure filenames consistent expected format.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_merfish.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read MERFISH Example Data from GitHub ‚Äî read_merfish","text":"","code":"if (FALSE) { # \\dontrun{ data_list <- read_merfish_data(num_chunks = 5) head(data_list$counts) table(data_list$CT) } # }"},{"path":"https://github.com/kaishumason/spotGLM/reference/read_spatial_atac.html","id":null,"dir":"Reference","previous_headings":"","what":"Read Spatial ATAC-Seq Example Data ‚Äî read_spatial_atac","title":"Read Spatial ATAC-Seq Example Data ‚Äî read_spatial_atac","text":"Loads spatial ATAC-seq data GitHub repository, including coordinates, deconvolution, region-level features, motif score matrices.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_spatial_atac.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read Spatial ATAC-Seq Example Data ‚Äî read_spatial_atac","text":"","code":"read_spatial_atac()"},{"path":"https://github.com/kaishumason/spotGLM/reference/read_spatial_atac.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read Spatial ATAC-Seq Example Data ‚Äî read_spatial_atac","text":"list containing: coords Spatial coordinates matrix. regions Matrix data frame spatial regions per spot. deconv Cell type deconvolution matrix. motif_scores Matrix motif activity scores per region.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_spatial_atac.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read Spatial ATAC-Seq Example Data ‚Äî read_spatial_atac","text":"","code":"if (FALSE) { # \\dontrun{ atac_data <- read_spatial_atac() names(atac_data) } # }"},{"path":"https://github.com/kaishumason/spotGLM/reference/read_spatial_long_read.html","id":null,"dir":"Reference","previous_headings":"","what":"Read Spatial Long-Read RNA-Seq Data ‚Äî read_spatial_long_read","title":"Read Spatial Long-Read RNA-Seq Data ‚Äî read_spatial_long_read","text":"Loads spatial long-read RNA-seq data GitHub repository. Includes coordinates, region annotations, deconvolution, library sizes, expression matrices genes isoforms.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_spatial_long_read.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read Spatial Long-Read RNA-Seq Data ‚Äî read_spatial_long_read","text":"","code":"read_spatial_long_read()"},{"path":"https://github.com/kaishumason/spotGLM/reference/read_spatial_long_read.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read Spatial Long-Read RNA-Seq Data ‚Äî read_spatial_long_read","text":"list containing: coords Matrix spatial coordinates. regions Spatial region annotations. deconv Cell type deconvolution matrix. library_size Vector library sizes per spot. total_gene_expression Matrix total gene expression. isoform_expression Matrix isoform-level expression.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_spatial_long_read.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read Spatial Long-Read RNA-Seq Data ‚Äî read_spatial_long_read","text":"","code":"if (FALSE) { # \\dontrun{ long_read_data <- read_spatial_long_read() str(long_read_data) } # }"},{"path":"https://github.com/kaishumason/spotGLM/reference/read_visium.html","id":null,"dir":"Reference","previous_headings":"","what":"Read Visium Example Data from GitHub ‚Äî read_visium","title":"Read Visium Example Data from GitHub ‚Äî read_visium","text":"Downloads loads Visium spatial transcriptomics data GitHub repository. Includes coordinates, deconvolution, effective niche covariates, library sizes, gene counts.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_visium.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read Visium Example Data from GitHub ‚Äî read_visium","text":"","code":"read_visium()"},{"path":"https://github.com/kaishumason/spotGLM/reference/read_visium.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read Visium Example Data from GitHub ‚Äî read_visium","text":"list containing: coords Matrix spatial coordinates. niche Effective niche covariate matrix. deconv Cell type deconvolution matrix. counts Gene expression count matrix. library_size Vector library sizes per spot.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_visium.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read Visium Example Data from GitHub ‚Äî read_visium","text":"","code":"if (FALSE) { # \\dontrun{ visium_data <- read_visium() str(visium_data) } # }"},{"path":"https://github.com/kaishumason/spotGLM/reference/read_visiumHD.html","id":null,"dir":"Reference","previous_headings":"","what":"Read Visium HD Example Data from GitHub ‚Äî read_visiumHD","title":"Read Visium HD Example Data from GitHub ‚Äî read_visiumHD","text":"Downloads loads spatial transcriptomics data Visium HD example dataset hosted public GitHub repository. includes spatial coordinates, gene expression counts, deconvolution results, effective niche estimates.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_visiumHD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read Visium HD Example Data from GitHub ‚Äî read_visiumHD","text":"","code":"read_visiumHD()"},{"path":"https://github.com/kaishumason/spotGLM/reference/read_visiumHD.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read Visium HD Example Data from GitHub ‚Äî read_visiumHD","text":"named list four elements: coords matrix data frame spatial coordinates (x y) spot. niche matrix, data frame, list representing effective niche composition per spot. deconv matrix data frame cell type deconvolution proportions per spot. counts gene expression count matrix (genes √ó spots).","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_visiumHD.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read Visium HD Example Data from GitHub ‚Äî read_visiumHD","text":"function requires internet connection download data https://github.com/kaishumason/SpotGLM-Example-Data. repository must contain files coords.rds, deconv_matrix.rds, count_matrix_subset.rds, niche.rds visiumHD folder.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/read_visiumHD.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read Visium HD Example Data from GitHub ‚Äî read_visiumHD","text":"","code":"if (FALSE) { # \\dontrun{ data_list <- read_visiumHD() head(data_list$coords) dim(data_list$counts) } # }"},{"path":"https://github.com/kaishumason/spotGLM/reference/run_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a Spatial GLM with Initialization and Optimization ‚Äî run_model","title":"Fit a Spatial GLM with Initialization and Optimization ‚Äî run_model","text":"Fits generalized linear model (GLM) spatial deconvolution single response variable (e.g., gene expression), supporting Poisson, Gaussian, Binomial, Negative Binomial families. function handles coefficient initialization, model fitting via mini-batch gradient descent, automatic coefficient filtering weak covariates poorly represented cell types.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/run_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a Spatial GLM with Initialization and Optimization ‚Äî run_model","text":"","code":"run_model(   y,   X,   lambda,   family = \"spot gaussian\",   beta_0 = NULL,   fix_coef = NULL,   offset = rep(0, length(y)),   initialization = T,   CT = NULL,   weights = rep(1, length(y)),   ct_cov_weights = rep(1, ncol(lambda)),   n_epochs = 100,   batch_size = 500,   learning_rate = 1,   max_diff = 1 - 1e-06,   improvement_threshold = 1e-06,   max_conv = 10 )"},{"path":"https://github.com/kaishumason/spotGLM/reference/run_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a Spatial GLM with Initialization and Optimization ‚Äî run_model","text":"y Numeric response vector (e.g., gene expression one gene across spots). X Covariate matrix (spots √ó covariates). lambda Deconvolution matrix (spots √ó cell types). family GLM family: \"spot gaussian\", \"spot poisson\", \"spot negative binomial\", \"spot binomial\". beta_0 Optional initial coefficient matrix (covariates √ó cell types). fix_coef Logical matrix (covariates √ó cell types) indicating coefficients fix optimization. offset Optional numeric vector (length y), used Poisson NB normalization. initialization Boolean initialization via single cell approximation performed. Default TRUE. CT Optional vector dominant cell type labels per spot. weights Observation weights (length y). ct_cov_weights Optional vector cell-type‚Äìspecific weights (length = number cell types). n_epochs Number training epochs gradient descent. batch_size Size mini-batches used gradient descent. learning_rate Initial learning rate optimization. max_diff Convergence threshold based likelihood ratio. improvement_threshold Minimum required improvement likelihood ratio epochs. max_conv Number consecutive low-improvement epochs convergence assumed.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/run_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a Spatial GLM with Initialization and Optimization ‚Äî run_model","text":"list containing: beta_estimate Estimated coefficient matrix (covariates √ó cell types). standard_error_matrix Standard error matrix coefficient. time Elapsed fitting time (seconds). disp Estimated dispersion (NB models). converged Logical indicating convergence reached. likelihood Final negative log-likelihood. vcov Variance-covariance matrix. niter Number optimization epochs completed. fixed_coef Final matrix indicating fixed coefficients.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/run_model_parallel_mac.html","id":null,"dir":"Reference","previous_headings":"","what":"Parallelized Spot-GLM Model Fitting (macOS / Linux) ‚Äî run_model_parallel_mac","title":"Parallelized Spot-GLM Model Fitting (macOS / Linux) ‚Äî run_model_parallel_mac","text":"Fits Spot-GLM model multiple responses (e.g., genes) parallel using memory-safe chunking pbmclapply, relies mclapply. available Unix-based systems.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/run_model_parallel_mac.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parallelized Spot-GLM Model Fitting (macOS / Linux) ‚Äî run_model_parallel_mac","text":"","code":"run_model_parallel_mac(   Y,   X,   lambda,   family = \"spot gaussian\",   beta_0 = NULL,   fix_coef = NULL,   initialization = T,   G = 0.1,   num_cores = 1,   offset = NULL,   CT = NULL,   weights = NULL,   ct_cov_weights = NULL,   n_epochs = 100,   batch_size = 500,   learning_rate = 1,   max_diff = 1 - 1e-06,   improvement_threshold = 1e-06,   max_conv = 10 )"},{"path":"https://github.com/kaishumason/spotGLM/reference/run_model_parallel_mac.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parallelized Spot-GLM Model Fitting (macOS / Linux) ‚Äî run_model_parallel_mac","text":"Y Response matrix (spots √ó responses). X Covariate matrix (spots √ó covariates). lambda Deconvolution matrix (spots √ó cell types). family GLM family use. One : \"spot gaussian\", \"spot poisson\", \"spot negative binomial\", \"spot binomial\". beta_0 Optional initial coefficient matrix (covariates √ó cell types). fix_coef Optional logical matrix indicating coefficients fix (dimensions beta_0). initialization Boolean initialization via single cell approximation performed. Default TRUE. G Maximum chunk size (GB) control memory usage parallelization. num_cores Number CPU cores use parallel. offset Optional numeric vector (length equal number spots). CT Optional vector dominant cell types per spot. weights Optional observation-level weight matrix (spots √ó genes). ct_cov_weights Optional cell-type-specific weight matrix (cell types √ó genes). n_epochs Number training epochs. batch_size Size mini-batch. learning_rate Initial learning rate. max_diff Convergence threshold based likelihood improvement ratio. improvement_threshold Minimum improvement ratio epochs. max_conv Number low-improvement epochs stopping.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/run_model_parallel_mac.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parallelized Spot-GLM Model Fitting (macOS / Linux) ‚Äî run_model_parallel_mac","text":"version uses pbmcapply::pbmclapply parallelism. Windows systems, please use run_spot_glm_windows.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/run_model_parallel_windows.html","id":null,"dir":"Reference","previous_headings":"","what":"Parallelized Spot-GLM Model Fitting (Windows) ‚Äî run_model_parallel_windows","title":"Parallelized Spot-GLM Model Fitting (Windows) ‚Äî run_model_parallel_windows","text":"Fits Spot-GLM model multiple response variables (e.g., genes) parallel using foreach doParallel. Optimized Windows systems mclapply available.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/run_model_parallel_windows.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parallelized Spot-GLM Model Fitting (Windows) ‚Äî run_model_parallel_windows","text":"","code":"run_model_parallel_windows(   Y,   X,   lambda,   family = \"spot\",   beta_0 = NULL,   fix_coef = NULL,   offset = NULL,   initialization = T,   G = 0.1,   num_cores = 1,   CT = NULL,   weights = NULL,   ct_cov_weights = NULL,   n_epochs = 100,   batch_size = 500,   learning_rate = 1,   max_diff = 1 - 1e-06,   improvement_threshold = 1e-06,   max_conv = 10 )"},{"path":"https://github.com/kaishumason/spotGLM/reference/run_model_parallel_windows.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parallelized Spot-GLM Model Fitting (Windows) ‚Äî run_model_parallel_windows","text":"Y Response matrix (spots √ó responses). X Covariate matrix (spots √ó covariates). lambda Deconvolution matrix (spots √ó cell types). family GLM family use. One : \"spot gaussian\", \"spot poisson\", \"spot negative binomial\", \"spot binomial\". beta_0 Optional initial coefficient matrix (covariates √ó cell types). fix_coef Optional logical matrix indicating coefficients fix (dimensions beta_0). offset Optional numeric vector (length equal number spots). initialization Boolean initialization via single cell approximation performed. Default TRUE. G Maximum chunk size (GB) control memory usage parallelization. num_cores Number CPU cores use parallel. CT Optional vector dominant cell types per spot. weights Optional observation-level weight matrix (spots √ó genes). ct_cov_weights Optional cell-type-specific weight matrix (cell types √ó genes). n_epochs Number training epochs. batch_size Size mini-batch. learning_rate Initial learning rate. max_diff Convergence threshold based likelihood improvement ratio. improvement_threshold Minimum improvement ratio epochs. max_conv Number low-improvement epochs stopping.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/run_model_parallel_windows.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parallelized Spot-GLM Model Fitting (Windows) ‚Äî run_model_parallel_windows","text":"named list model results (one per gene), containing: beta_estimate Estimated coefficients. standard_error_matrix Standard error matrix. disp Dispersion estimate (applicable). likelihood Final log-likelihood. converged Convergence status. niter Number epochs run. vcov Variance-covariance matrix. fixed_coef Final fixed coefficients matrix.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/run_model_parallel_windows.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parallelized Spot-GLM Model Fitting (Windows) ‚Äî run_model_parallel_windows","text":"function splits gene expression matrix memory-safe chunks, evaluates chunk parallel using foreach doParallel. Mac/Linux, use run_spot_glm_mac. External dependencies include Matrix, MASS, LaplacesDemon.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/run_single_cell.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Single-Cell GLM per Cell Type ‚Äî run_single_cell","title":"Run Single-Cell GLM per Cell Type ‚Äî run_single_cell","text":"Fits individual GLMs cell type using pseudo-bulked single-cell data.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/run_single_cell.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Single-Cell GLM per Cell Type ‚Äî run_single_cell","text":"","code":"run_single_cell(   y,   X,   lambda,   sc_family = \"gaussian\",   offset = rep(0, length(y)),   weights = rep(1, length(y)),   fix_coef = matrix(FALSE, ncol(X), ncol(lambda)),   CT = NULL )"},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_binomial.html","id":null,"dir":"Reference","previous_headings":"","what":"Custom GLM Object: Spot Binomial ‚Äî spot_binomial","title":"Custom GLM Object: Spot Binomial ‚Äî spot_binomial","text":"Defines Binomial-based GLM family object modeling bounded expression data proportions spatial transcriptomics. Supports deconvolution optimization logistic link functions.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_binomial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Custom GLM Object: Spot Binomial ‚Äî spot_binomial","text":"","code":"spot_binomial"},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_binomial.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Custom GLM Object: Spot Binomial ‚Äî spot_binomial","text":"list class-specific functions: link Logistic-based link inverse link functions derivatives. marginal_mu Marginal mean function (inverse logit). original_class Base GLM family used (Binomial). predict Predict probabilities X, beta, lambda. likelihood Negative log-likelihood function. grad Gradient function respect beta.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_gaussian.html","id":null,"dir":"Reference","previous_headings":"","what":"Custom GLM Object: Spot Gaussian ‚Äî spot_gaussian","title":"Custom GLM Object: Spot Gaussian ‚Äî spot_gaussian","text":"Defines Gaussian-based GLM family object spatial transcriptomics data, incorporating link functions gradient-based optimization continuous-valued expression deconvolution.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_gaussian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Custom GLM Object: Spot Gaussian ‚Äî spot_gaussian","text":"","code":"spot_gaussian"},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_gaussian.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Custom GLM Object: Spot Gaussian ‚Äî spot_gaussian","text":"list class-specific functions: link Link inverse link functions derivatives. marginal_mu Marginal mean function. original_class Base GLM family used (Gaussian). predict Predict means X, beta, lambda. likelihood Negative log-likelihood function.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_glm.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a Spatial GLM with Deconvolution ‚Äî spot_glm","title":"Fit a Spatial GLM with Deconvolution ‚Äî spot_glm","text":"Fits generalized linear model (GLM) deconvolution spatial transcriptomics data, supporting Poisson, Gaussian, Negative Binomial, Binomial families. Optimization performed via gradient descent (closed-form Gaussian).","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_glm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a Spatial GLM with Deconvolution ‚Äî spot_glm","text":"","code":"spot_glm(   X,   y,   lambda,   family,   beta_0 = matrix(0, ncol(X), ncol(lambda)),   offset = rep(0, nrow(X)),   weights = NULL,   fix_coef = matrix(FALSE, ncol(X), ncol(lambda)),   learning_rate = 0.1,   n_epochs = 50,   batch_size = 128,   max_diff = 1 - 1e-06,   improvement_threshold = 1e-06,   max_conv = 10 )"},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_glm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a Spatial GLM with Deconvolution ‚Äî spot_glm","text":"X Design matrix covariates (spots √ó covariates). y Response vector (e.g., gene expression). lambda Deconvolution matrix (spots √ó cell types). family GLM family: one \"spot poisson\", \"spot gaussian\", \"spot binomial\", \"spot negative binomial\". beta_0 Initial coefficients (matrix: covariates √ó cell types). offset Optional offset term (numeric vector). weights Optional observation-level weights. fix_coef Logical matrix indicating coefficients fix. learning_rate Initial learning rate gradient descent. n_epochs Number epochs (iterations full data). batch_size Size mini-batches gradient descent. max_diff Convergence threshold likelihood improvement ratio. improvement_threshold Minimum change ratio epochs signal progress. max_conv Number consecutive small-improvement epochs trigger convergence.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_glm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a Spatial GLM with Deconvolution ‚Äî spot_glm","text":"list : beta Estimated coefficient matrix. vcov Variance-covariance matrix estimates. dispersion Estimated dispersion (NB models). likelihood Final negative log-likelihood. converged Logical indicating convergence reached. num_epoch Number epochs used. fixed_coef Final fix coefficient matrix.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_glm_gaussian.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Gaussian Spot-GLM Solver ‚Äî spot_glm_gaussian","title":"Internal Gaussian Spot-GLM Solver ‚Äî spot_glm_gaussian","text":"Fits Gaussian GLM spatial transcriptomics data optional fixed coefficients. Used internally spot_glm family \"spot gaussian\".","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_glm_gaussian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Gaussian Spot-GLM Solver ‚Äî spot_glm_gaussian","text":"","code":"spot_glm_gaussian(X, y, lambda, fix_coef, beta_0)"},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_glm_gaussian.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Gaussian Spot-GLM Solver ‚Äî spot_glm_gaussian","text":"X Design matrix (spots √ó covariates). y Response vector. lambda Deconvolution matrix (spots √ó cell types). fix_coef Logical matrix indicating coefficients fix (TRUE = update). beta_0 Initial coefficient matrix (covariates √ó cell types).","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_glm_gaussian.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Gaussian Spot-GLM Solver ‚Äî spot_glm_gaussian","text":"list containing: beta Estimated coefficient matrix. vcov Variance-covariance matrix estimated coefficients. sigma.sq Residual variance estimate.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_lm.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit Spatial Linear Model (Spot-GLM Gaussian) ‚Äî spot_lm","title":"Fit Spatial Linear Model (Spot-GLM Gaussian) ‚Äî spot_lm","text":"Fits linear model spatial transcriptomics data using deconvolution fixed coefficients.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_lm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit Spatial Linear Model (Spot-GLM Gaussian) ‚Äî spot_lm","text":"","code":"spot_lm(y, X, lambda, big_X = NULL, fix_coef = NULL, beta_0 = NULL)"},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_lm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit Spatial Linear Model (Spot-GLM Gaussian) ‚Äî spot_lm","text":"y Response vector. X Covariate matrix (spots √ó covariates). lambda Deconvolution matrix (spots √ó cell types). big_X Optional full design matrix (covariates √ó cell types). fix_coef Logical matrix specifying coefficients fix. beta_0 Initial coefficients.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_lm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit Spatial Linear Model (Spot-GLM Gaussian) ‚Äî spot_lm","text":"list : beta Estimated coefficients. vcov Variance-covariance matrix. standard_error_matrix Standard error matrix. sigma.sq Residual variance estimate.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_negative_binomial.html","id":null,"dir":"Reference","previous_headings":"","what":"Custom GLM Object: Spot Negative Binomial ‚Äî spot_negative_binomial","title":"Custom GLM Object: Spot Negative Binomial ‚Äî spot_negative_binomial","text":"Defines Negative Binomial-based GLM family object suitable overdispersed spatial transcriptomics count data. Incorporates flexible link functions gradient computations regression coefficients dispersion parameters.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_negative_binomial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Custom GLM Object: Spot Negative Binomial ‚Äî spot_negative_binomial","text":"","code":"spot_negative_binomial"},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_negative_binomial.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Custom GLM Object: Spot Negative Binomial ‚Äî spot_negative_binomial","text":"list class-specific functions: link Negative binomial link inverse link functions derivatives. marginal_mu Marginal mean function. original_class Base GLM family used (Poisson Negative Binomial). predict Predict means X, beta, lambda. likelihood Negative log-likelihood function. grad Gradient function respect beta dispersion.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_poisson.html","id":null,"dir":"Reference","previous_headings":"","what":"Custom GLM Object: Spot Poisson ‚Äî spot_poisson","title":"Custom GLM Object: Spot Poisson ‚Äî spot_poisson","text":"Defines Poisson-based GLM family object tailored modeling spatial transcriptomics count data using deconvolution. Includes link functions, marginal mean, likelihood, gradient computation, prediction utilities.","code":""},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_poisson.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Custom GLM Object: Spot Poisson ‚Äî spot_poisson","text":"","code":"spot_poisson"},{"path":"https://github.com/kaishumason/spotGLM/reference/spot_poisson.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Custom GLM Object: Spot Poisson ‚Äî spot_poisson","text":"list class-specific functions: link Link inverse link functions derivatives. marginal_mu Marginal mean function. original_class Base GLM family used (Poisson). predict Predict means X, beta, lambda. likelihood Negative log-likelihood function. grad Gradient function respect beta.","code":""}]
